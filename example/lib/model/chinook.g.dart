// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'chinook.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Album.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Album TABLE
class TableAlbum extends SqfEntityTableBase {
  TableAlbum() {
    // declare properties of EntityTable
    tableName = 'Album';
    primaryKeyName = 'AlbumId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Title', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableArtist.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'ArtistId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAlbum();
  }
}

// Artist TABLE
class TableArtist extends SqfEntityTableBase {
  TableArtist() {
    // declare properties of EntityTable
    tableName = 'Artist';
    primaryKeyName = 'ArtistId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArtist();
  }
}

// Customer TABLE
class TableCustomer extends SqfEntityTableBase {
  TableCustomer() {
    // declare properties of EntityTable
    tableName = 'Customer';
    primaryKeyName = 'CustomerId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FirstName', DbType.text),
      SqfEntityFieldBase('LastName', DbType.text),
      SqfEntityFieldBase('Company', DbType.text),
      SqfEntityFieldBase('Address', DbType.text),
      SqfEntityFieldBase('City', DbType.text),
      SqfEntityFieldBase('State', DbType.text),
      SqfEntityFieldBase('Country', DbType.text),
      SqfEntityFieldBase('PostalCode', DbType.text),
      SqfEntityFieldBase('Phone', DbType.text),
      SqfEntityFieldBase('Fax', DbType.text),
      SqfEntityFieldBase('Email', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableEmployee.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'SupportRepId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCustomer();
  }
}

// Employee TABLE
class TableEmployee extends SqfEntityTableBase {
  TableEmployee() {
    // declare properties of EntityTable
    tableName = 'Employee';
    primaryKeyName = 'EmployeeId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('LastName', DbType.text),
      SqfEntityFieldBase('FirstName', DbType.text),
      SqfEntityFieldBase('Title', DbType.text),
      SqfEntityFieldBase('BirthDate', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('HireDate', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('Address', DbType.text),
      SqfEntityFieldBase('City', DbType.text),
      SqfEntityFieldBase('State', DbType.text),
      SqfEntityFieldBase('Country', DbType.text),
      SqfEntityFieldBase('PostalCode', DbType.text),
      SqfEntityFieldBase('Phone', DbType.text),
      SqfEntityFieldBase('Fax', DbType.text),
      SqfEntityFieldBase('Email', DbType.text),
      SqfEntityFieldRelationshipBase(null, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'ReportsTo'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEmployee();
  }
}

// Genre TABLE
class TableGenre extends SqfEntityTableBase {
  TableGenre() {
    // declare properties of EntityTable
    tableName = 'Genre';
    primaryKeyName = 'GenreId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableGenre();
  }
}

// Invoice TABLE
class TableInvoice extends SqfEntityTableBase {
  TableInvoice() {
    // declare properties of EntityTable
    tableName = 'Invoice';
    primaryKeyName = 'InvoiceId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('InvoiceDate', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('BillingAddress', DbType.text),
      SqfEntityFieldBase('BillingCity', DbType.text),
      SqfEntityFieldBase('BillingState', DbType.text),
      SqfEntityFieldBase('BillingCountry', DbType.text),
      SqfEntityFieldBase('BillingPostalCode', DbType.text),
      SqfEntityFieldBase('Total', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableCustomer.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'CustomerId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoice();
  }
}

// InvoiceLine TABLE
class TableInvoiceLine extends SqfEntityTableBase {
  TableInvoiceLine() {
    // declare properties of EntityTable
    tableName = 'InvoiceLine';
    primaryKeyName = 'InvoiceLineId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('UnitPrice', DbType.real),
      SqfEntityFieldBase('Quantity', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'TrackId'),
      SqfEntityFieldRelationshipBase(
          TableInvoice.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'InvoiceId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoiceLine();
  }
}

// MediaType TABLE
class TableMediaType extends SqfEntityTableBase {
  TableMediaType() {
    // declare properties of EntityTable
    tableName = 'MediaType';
    primaryKeyName = 'MediaTypeId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableMediaType();
  }
}

// Playlist TABLE
class TablePlaylist extends SqfEntityTableBase {
  TablePlaylist() {
    // declare properties of EntityTable
    tableName = 'Playlist';
    primaryKeyName = 'PlaylistId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylist();
  }
}

// Track TABLE
class TableTrack extends SqfEntityTableBase {
  TableTrack() {
    // declare properties of EntityTable
    tableName = 'Track';
    primaryKeyName = 'TrackId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
      SqfEntityFieldBase('Composer', DbType.text),
      SqfEntityFieldBase('Milliseconds', DbType.integer),
      SqfEntityFieldBase('Bytes', DbType.integer),
      SqfEntityFieldBase('UnitPrice', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableMediaType.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'MediaTypeId'),
      SqfEntityFieldRelationshipBase(
          TableGenre.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'GenreId'),
      SqfEntityFieldRelationshipBase(
          TableAlbum.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'AlbumId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTrack();
  }
}

// VTrack TABLE
class TableVTrack extends SqfEntityTableBase {
  TableVTrack() {
    // declare properties of EntityTable
    tableName = 'VTracks';
    objectType = ObjectType.view;
    sqlStatement = chinookdb.databaseTables![10].sqlStatement;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
      SqfEntityFieldBase('album', DbType.text),
      SqfEntityFieldBase('media', DbType.text),
      SqfEntityFieldBase('genres', DbType.text),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY, fieldName: 'TrackId'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVTrack();
  }
}

// PlaylistTrack TABLE
class TablePlaylistTrack extends SqfEntityTableBase {
  TablePlaylistTrack() {
    // declare properties of EntityTable
    tableName = 'PlaylistTrack';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'TrackId',
          isPrimaryKeyField: true),
      SqfEntityFieldRelationshipBase(
          TablePlaylist.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'PlaylistId',
          isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylistTrack();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class Chinookdb extends SqfEntityModelProvider {
  Chinookdb() {
    databaseName = chinookdb.databaseName;
    password = chinookdb.password;
    dbVersion = chinookdb.dbVersion;
    preSaveAction = chinookdb.preSaveAction;
    logFunction = chinookdb.logFunction;
    databaseTables = [
      TableAlbum.getInstance,
      TableArtist.getInstance,
      TableCustomer.getInstance,
      TableEmployee.getInstance,
      TableGenre.getInstance,
      TableInvoice.getInstance,
      TableInvoiceLine.getInstance,
      TableMediaType.getInstance,
      TablePlaylist.getInstance,
      TableTrack.getInstance,
      TableVTrack.getInstance,
      TablePlaylistTrack.getInstance,
    ];

    bundledDatabasePath = chinookdb
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = chinookdb.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['album'] = AlbumController.getController;
    controllers['artist'] = ArtistController.getController;
    controllers['customer'] = CustomerController.getController;
    controllers['employee'] = EmployeeController.getController;
    controllers['genre'] = GenreController.getController;
    controllers['invoice'] = InvoiceController.getController;
    controllers['invoiceline'] = InvoiceLineController.getController;
    controllers['mediatype'] = MediaTypeController.getController;
    controllers['playlist'] = PlaylistController.getController;
    controllers['track'] = TrackController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Album
class Album extends TableBase {
  Album({this.AlbumId, this.Title, this.ArtistId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Album.withFields(this.Title, this.ArtistId) {
    _setDefaultValues();
  }
  Album.withId(this.AlbumId, this.Title, this.ArtistId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Album.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    AlbumId = int.tryParse(o['AlbumId'].toString());
    if (o['Title'] != null) {
      Title = o['Title'].toString();
    }
    ArtistId = int.tryParse(o['ArtistId'].toString());

    // RELATIONSHIPS FromMAP
    plArtist = o['artist'] != null
        ? Artist.fromMap(o['artist'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Album)
  int? AlbumId;
  String? Title;
  int? ArtistId;

  // end FIELDS (Album)

// RELATIONSHIPS (Album)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plArtist', 'plField2'..]) or so on..
  Artist? plArtist;

  /// get Artist By ArtistId
  Future<Artist?> getArtist(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Artist().getById(ArtistId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Album)

// COLLECTIONS & VIRTUALS (Album)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track>? plTracks;

  /// get Track(s) filtered by AlbumId=AlbumId
  TrackFilterBuilder? getTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (AlbumId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .AlbumId
        .equals(AlbumId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Album)

  static const bool _softDeleteActivated = false;
  AlbumManager? __mnAlbum;

  AlbumManager get _mnAlbum {
    return __mnAlbum = __mnAlbum ?? AlbumManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['AlbumId'] = AlbumId;
    if (Title != null || !forView) {
      map['Title'] = Title;
    }
    if (ArtistId != null) {
      map['ArtistId'] = forView
          ? plArtist == null
              ? ArtistId
              : plArtist!.Name
          : ArtistId;
    } else if (ArtistId != null || !forView) {
      map['ArtistId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['AlbumId'] = AlbumId;
    if (Title != null || !forView) {
      map['Title'] = Title;
    }
    if (ArtistId != null) {
      map['ArtistId'] = forView
          ? plArtist == null
              ? ArtistId
              : plArtist!.Name
          : ArtistId;
    } else if (ArtistId != null || !forView) {
      map['ArtistId'] = null;
    }

// COLLECTIONS (Album)
    if (!forQuery) {
      map['Tracks'] = await getTracks()!.toMapList();
    }
// END COLLECTIONS (Album)

    return map;
  }

  /// This method returns Json String [Album]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Album]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Title, ArtistId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [AlbumId, Title, ArtistId];
  }

  static Future<List<Album>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Album.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Album>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Album>[];
    try {
      objList = list
          .map((album) => Album.fromMap(album as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Album.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Album>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Album> objList = <Album>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Album.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Album.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          obj.plArtist =
              obj.plArtist ?? await obj.getArtist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Album by ID if exist, otherwise returns null
  /// Primary Keys: int? AlbumId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Album] if exist, otherwise returns null
  Future<Album?> getById(int? AlbumId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (AlbumId == null) {
      return null;
    }
    Album? obj;
    final data = await _mnAlbum.getById([AlbumId]);
    if (data.length != 0) {
      obj = Album.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Album.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          obj.plArtist =
              obj.plArtist ?? await obj.getArtist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Album) object. If the AlbumId field is null, saves as a new record and returns new AlbumId, if AlbumId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns AlbumId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (AlbumId == null || AlbumId == 0) {
      AlbumId = await _mnAlbum.insert(this, ignoreBatch);
    } else {
      await _mnAlbum.update(this);
    }

    return AlbumId;
  }

  /// Saves the (Album) object. If the AlbumId field is null, saves as a new record and returns new AlbumId, if AlbumId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns AlbumId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (AlbumId == null || AlbumId == 0) {
      AlbumId = await _mnAlbum.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // AlbumId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAlbum.updateOrThrow(this);
    }

    return AlbumId;
  }

  /// saveAs Album. Returns a new Primary Key value of Album

  /// <returns>Returns a new Primary Key value of Album
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    AlbumId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Album> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Album> albums) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in albums) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < albums.length; i++) {
        if (albums[i].AlbumId == null) {
          albums[i].AlbumId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns AlbumId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAlbum.rawInsert(
          'INSERT OR REPLACE INTO Album (AlbumId, Title, ArtistId)  VALUES (?,?,?)',
          [AlbumId, Title, ArtistId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Album AlbumId=$AlbumId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Album AlbumId=$AlbumId did not update');
      }
      return AlbumId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Album Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Album>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Album> albums) async {
    final results = await _mnAlbum.rawInsertAll(
        'INSERT OR REPLACE INTO Album (AlbumId, Title, ArtistId)  VALUES (?,?,?)',
        albums);
    return results;
  }

  /// Deletes Album

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Album invoked (AlbumId=$AlbumId)');
    if (await Track().select().AlbumId.equals(AlbumId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.AlbumId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnAlbum.delete(
          QueryParams(whereString: 'AlbumId=?', whereArguments: [AlbumId]));
    } else {
      return _mnAlbum.updateBatch(
          QueryParams(whereString: 'AlbumId=?', whereArguments: [AlbumId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Album] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  AlbumFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AlbumFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  AlbumFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AlbumFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      AlbumId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion album

// region AlbumField
class AlbumField extends FilterBase {
  AlbumField(AlbumFilterBuilder albumFB) : super(albumFB);

  @override
  AlbumFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder isNull() {
    return super.isNull() as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as AlbumFilterBuilder;
  }

  @override
  AlbumField get not {
    return super.not as AlbumField;
  }
}
// endregion AlbumField

// region AlbumFilterBuilder
class AlbumFilterBuilder extends ConjunctionBase {
  AlbumFilterBuilder(Album obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnAlbum = obj._mnAlbum;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  AlbumManager? _mnAlbum;

  /// put the sql keyword 'AND'
  @override
  AlbumFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  AlbumFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  AlbumFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  AlbumFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  AlbumFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  AlbumFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  AlbumFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AlbumFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AlbumFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AlbumFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AlbumFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  AlbumField _setField(AlbumField? field, String colName, DbType dbtype) {
    return AlbumField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  AlbumField? _AlbumId;
  AlbumField get AlbumId {
    return _AlbumId = _setField(_AlbumId, 'AlbumId', DbType.integer);
  }

  AlbumField? _Title;
  AlbumField get Title {
    return _Title = _setField(_Title, 'Title', DbType.text);
  }

  AlbumField? _ArtistId;
  AlbumField get ArtistId {
    return _ArtistId = _setField(_ArtistId, 'ArtistId', DbType.integer);
  }

  /// Deletes List<Album> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYAlbumId = toListPrimaryKeySQL(false);
    final resTrackBYAlbumId = await Track()
        .select()
        .where('AlbumId IN (${idListTrackBYAlbumId['sql']})',
            parameterValue: idListTrackBYAlbumId['args'])
        .toCount();
    if (resTrackBYAlbumId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.AlbumId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnAlbum!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnAlbum!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'AlbumId IN (SELECT AlbumId from Album ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnAlbum!.updateBatch(qparams, values);
  }

  /// This method always returns [Album] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Album?
  @override
  Future<Album?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnAlbum!.toList(qparams);
    final data = await objFuture;
    Album? obj;
    if (data.isNotEmpty) {
      obj = Album.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Album.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          obj.plArtist =
              obj.plArtist ?? await obj.getArtist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Album]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Album?
  @override
  Future<Album> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Album();
  }

  /// This method returns int. [Album]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? albumCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final albumsFuture = await _mnAlbum!.toList(qparams);
    final int count = albumsFuture[0]['CNT'] as int;
    if (albumCount != null) {
      albumCount(count);
    }
    return count;
  }

  /// This method returns List<Album> [Album]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Album>
  @override
  Future<List<Album>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Album> albumsData = await Album.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return albumsData;
  }

  /// This method returns Json String [Album]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Album]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Album]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnAlbum!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Album>>
  Future<List<DropdownMenuItem<Album>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Album>> o)?
          dropDownMenu]) async {
    buildParameters();
    final albumsFuture = _mnAlbum!.toList(qparams);

    final data = await albumsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Album>> items = []..add(DropdownMenuItem(
        value: Album(),
        child: Text('Select Album'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Album.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['AlbumId', displayTextColumn];
    final albumsFuture = _mnAlbum!.toList(qparams);

    final data = await albumsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Album'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['AlbumId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Album]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `AlbumId` FROM Album WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> AlbumIdData = <int>[];
    qparams.selectColumns = ['AlbumId'];
    final AlbumIdFuture = await _mnAlbum!.toList(qparams);

    final int count = AlbumIdFuture.length;
    for (int i = 0; i < count; i++) {
      AlbumIdData.add(AlbumIdFuture[i]['AlbumId'] as int);
    }
    return AlbumIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Album]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnAlbum!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Album.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnAlbum!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AlbumFilterBuilder

// region AlbumFields
class AlbumFields {
  static TableField? _fAlbumId;
  static TableField get AlbumId {
    return _fAlbumId =
        _fAlbumId ?? SqlSyntax.setField(_fAlbumId, 'albumid', DbType.integer);
  }

  static TableField? _fTitle;
  static TableField get Title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'Title', DbType.text);
  }

  static TableField? _fArtistId;
  static TableField get ArtistId {
    return _fArtistId = _fArtistId ??
        SqlSyntax.setField(_fArtistId, 'ArtistId', DbType.integer);
  }
}
// endregion AlbumFields

//region AlbumManager
class AlbumManager extends SqfEntityProvider {
  AlbumManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Album';
  static const List<String> _primaryKeyList = ['AlbumId'];
  static const String _whereStr = 'AlbumId=?';
}

//endregion AlbumManager
// region Artist
class Artist extends TableBase {
  Artist({this.ArtistId, this.Name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Artist.withFields(this.Name) {
    _setDefaultValues();
  }
  Artist.withId(this.ArtistId, this.Name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Artist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArtistId = int.tryParse(o['ArtistId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
  }
  // FIELDS (Artist)
  int? ArtistId;
  String? Name;

  // end FIELDS (Artist)

// COLLECTIONS & VIRTUALS (Artist)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAlbums', 'plField2'..]) or so on..
  List<Album>? plAlbums;

  /// get Album(s) filtered by ArtistId=ArtistId
  AlbumFilterBuilder? getAlbums(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (ArtistId == null) {
      return null;
    }
    return Album()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ArtistId
        .equals(ArtistId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Artist)

  static const bool _softDeleteActivated = false;
  ArtistManager? __mnArtist;

  ArtistManager get _mnArtist {
    return __mnArtist = __mnArtist ?? ArtistManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArtistId'] = ArtistId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArtistId'] = ArtistId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

// COLLECTIONS (Artist)
    if (!forQuery) {
      map['Albums'] = await getAlbums()!.toMapList();
    }
// END COLLECTIONS (Artist)

    return map;
  }

  /// This method returns Json String [Artist]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Artist]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [ArtistId, Name];
  }

  static Future<List<Artist>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Artist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Artist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Artist>[];
    try {
      objList = list
          .map((artist) => Artist.fromMap(artist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Artist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Artist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Artist> objList = <Artist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Artist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedfields!.add('Artist.plAlbums'); */ obj.plAlbums =
              obj.plAlbums ??
                  await obj.getAlbums()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Artist by ID if exist, otherwise returns null
  /// Primary Keys: int? ArtistId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Artist] if exist, otherwise returns null
  Future<Artist?> getById(int? ArtistId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArtistId == null) {
      return null;
    }
    Artist? obj;
    final data = await _mnArtist.getById([ArtistId]);
    if (data.length != 0) {
      obj = Artist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedfields!.add('Artist.plAlbums'); */ obj.plAlbums =
              obj.plAlbums ??
                  await obj.getAlbums()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Artist) object. If the ArtistId field is null, saves as a new record and returns new ArtistId, if ArtistId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns ArtistId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (ArtistId == null || ArtistId == 0) {
      ArtistId = await _mnArtist.insert(this, ignoreBatch);
    } else {
      await _mnArtist.update(this);
    }

    return ArtistId;
  }

  /// Saves the (Artist) object. If the ArtistId field is null, saves as a new record and returns new ArtistId, if ArtistId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns ArtistId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (ArtistId == null || ArtistId == 0) {
      ArtistId = await _mnArtist.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // ArtistId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnArtist.updateOrThrow(this);
    }

    return ArtistId;
  }

  /// saveAs Artist. Returns a new Primary Key value of Artist

  /// <returns>Returns a new Primary Key value of Artist
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    ArtistId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Artist> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Artist> artists) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in artists) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < artists.length; i++) {
        if (artists[i].ArtistId == null) {
          artists[i].ArtistId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns ArtistId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArtist.rawInsert(
          'INSERT OR REPLACE INTO Artist (ArtistId, Name)  VALUES (?,?)',
          [ArtistId, Name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Artist ArtistId=$ArtistId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Artist ArtistId=$ArtistId did not update');
      }
      return ArtistId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Artist Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Artist>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Artist> artists) async {
    final results = await _mnArtist.rawInsertAll(
        'INSERT OR REPLACE INTO Artist (ArtistId, Name)  VALUES (?,?)',
        artists);
    return results;
  }

  /// Deletes Artist

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Artist invoked (ArtistId=$ArtistId)');
    if (await Album().select().ArtistId.equals(ArtistId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Album.ArtistId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnArtist.delete(
          QueryParams(whereString: 'ArtistId=?', whereArguments: [ArtistId]));
    } else {
      return _mnArtist.updateBatch(
          QueryParams(whereString: 'ArtistId=?', whereArguments: [ArtistId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Artist] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ArtistFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArtistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArtistFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArtistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArtistId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion artist

// region ArtistField
class ArtistField extends FilterBase {
  ArtistField(ArtistFilterBuilder artistFB) : super(artistFB);

  @override
  ArtistFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder isNull() {
    return super.isNull() as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArtistFilterBuilder;
  }

  @override
  ArtistField get not {
    return super.not as ArtistField;
  }
}
// endregion ArtistField

// region ArtistFilterBuilder
class ArtistFilterBuilder extends ConjunctionBase {
  ArtistFilterBuilder(Artist obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArtist = obj._mnArtist;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArtistManager? _mnArtist;

  /// put the sql keyword 'AND'
  @override
  ArtistFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArtistFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArtistFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArtistFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArtistFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArtistFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArtistFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArtistFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArtistFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArtistFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArtistFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArtistField _setField(ArtistField? field, String colName, DbType dbtype) {
    return ArtistField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArtistField? _ArtistId;
  ArtistField get ArtistId {
    return _ArtistId = _setField(_ArtistId, 'ArtistId', DbType.integer);
  }

  ArtistField? _Name;
  ArtistField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  /// Deletes List<Artist> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Album) according to DeleteRule.NO_ACTION

    final idListAlbumBYArtistId = toListPrimaryKeySQL(false);
    final resAlbumBYArtistId = await Album()
        .select()
        .where('ArtistId IN (${idListAlbumBYArtistId['sql']})',
            parameterValue: idListAlbumBYArtistId['args'])
        .toCount();
    if (resAlbumBYArtistId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Album.ArtistId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArtist!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArtist!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArtistId IN (SELECT ArtistId from Artist ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArtist!.updateBatch(qparams, values);
  }

  /// This method always returns [Artist] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Artist?
  @override
  Future<Artist?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArtist!.toList(qparams);
    final data = await objFuture;
    Artist? obj;
    if (data.isNotEmpty) {
      obj = Artist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedfields!.add('Artist.plAlbums'); */ obj.plAlbums =
              obj.plAlbums ??
                  await obj.getAlbums()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Artist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Artist?
  @override
  Future<Artist> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Artist();
  }

  /// This method returns int. [Artist]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? artistCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final artistsFuture = await _mnArtist!.toList(qparams);
    final int count = artistsFuture[0]['CNT'] as int;
    if (artistCount != null) {
      artistCount(count);
    }
    return count;
  }

  /// This method returns List<Artist> [Artist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Artist>
  @override
  Future<List<Artist>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Artist> artistsData = await Artist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return artistsData;
  }

  /// This method returns Json String [Artist]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Artist]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Artist]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArtist!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Artist>>
  Future<List<DropdownMenuItem<Artist>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Artist>> o)?
          dropDownMenu]) async {
    buildParameters();
    final artistsFuture = _mnArtist!.toList(qparams);

    final data = await artistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Artist>> items = []..add(DropdownMenuItem(
        value: Artist(),
        child: Text('Select Artist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Artist.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['ArtistId', displayTextColumn];
    final artistsFuture = _mnArtist!.toList(qparams);

    final data = await artistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Artist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['ArtistId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Artist]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArtistId` FROM Artist WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> ArtistIdData = <int>[];
    qparams.selectColumns = ['ArtistId'];
    final ArtistIdFuture = await _mnArtist!.toList(qparams);

    final int count = ArtistIdFuture.length;
    for (int i = 0; i < count; i++) {
      ArtistIdData.add(ArtistIdFuture[i]['ArtistId'] as int);
    }
    return ArtistIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Artist]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArtist!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Artist.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArtist!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArtistFilterBuilder

// region ArtistFields
class ArtistFields {
  static TableField? _fArtistId;
  static TableField get ArtistId {
    return _fArtistId = _fArtistId ??
        SqlSyntax.setField(_fArtistId, 'artistid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion ArtistFields

//region ArtistManager
class ArtistManager extends SqfEntityProvider {
  ArtistManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Artist';
  static const List<String> _primaryKeyList = ['ArtistId'];
  static const String _whereStr = 'ArtistId=?';
}

//endregion ArtistManager
// region Customer
class Customer extends TableBase {
  Customer(
      {this.CustomerId,
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Customer.withFields(
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId) {
    _setDefaultValues();
  }
  Customer.withId(
      this.CustomerId,
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Customer.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CustomerId = int.tryParse(o['CustomerId'].toString());
    if (o['FirstName'] != null) {
      FirstName = o['FirstName'].toString();
    }
    if (o['LastName'] != null) {
      LastName = o['LastName'].toString();
    }
    if (o['Company'] != null) {
      Company = o['Company'].toString();
    }
    if (o['Address'] != null) {
      Address = o['Address'].toString();
    }
    if (o['City'] != null) {
      City = o['City'].toString();
    }
    if (o['State'] != null) {
      State = o['State'].toString();
    }
    if (o['Country'] != null) {
      Country = o['Country'].toString();
    }
    if (o['PostalCode'] != null) {
      PostalCode = o['PostalCode'].toString();
    }
    if (o['Phone'] != null) {
      Phone = o['Phone'].toString();
    }
    if (o['Fax'] != null) {
      Fax = o['Fax'].toString();
    }
    if (o['Email'] != null) {
      Email = o['Email'].toString();
    }
    SupportRepId = int.tryParse(o['SupportRepId'].toString());

    // RELATIONSHIPS FromMAP
    plEmployee = o['employee'] != null
        ? Employee.fromMap(o['employee'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Customer)
  int? CustomerId;
  String? FirstName;
  String? LastName;
  String? Company;
  String? Address;
  String? City;
  String? State;
  String? Country;
  String? PostalCode;
  String? Phone;
  String? Fax;
  String? Email;
  int? SupportRepId;

  // end FIELDS (Customer)

// RELATIONSHIPS (Customer)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plEmployee', 'plField2'..]) or so on..
  Employee? plEmployee;

  /// get Employee By SupportRepId
  Future<Employee?> getEmployee(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Employee().getById(SupportRepId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Customer)

// COLLECTIONS & VIRTUALS (Customer)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plInvoices', 'plField2'..]) or so on..
  List<Invoice>? plInvoices;

  /// get Invoice(s) filtered by CustomerId=CustomerId
  InvoiceFilterBuilder? getInvoices(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (CustomerId == null) {
      return null;
    }
    return Invoice()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .CustomerId
        .equals(CustomerId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Customer)

  static const bool _softDeleteActivated = false;
  CustomerManager? __mnCustomer;

  CustomerManager get _mnCustomer {
    return __mnCustomer = __mnCustomer ?? CustomerManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['CustomerId'] = CustomerId;
    if (FirstName != null || !forView) {
      map['FirstName'] = FirstName;
    }
    if (LastName != null || !forView) {
      map['LastName'] = LastName;
    }
    if (Company != null || !forView) {
      map['Company'] = Company;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }
    if (PostalCode != null || !forView) {
      map['PostalCode'] = PostalCode;
    }
    if (Phone != null || !forView) {
      map['Phone'] = Phone;
    }
    if (Fax != null || !forView) {
      map['Fax'] = Fax;
    }
    if (Email != null || !forView) {
      map['Email'] = Email;
    }
    if (SupportRepId != null) {
      map['SupportRepId'] = forView
          ? plEmployee == null
              ? SupportRepId
              : plEmployee!.LastName
          : SupportRepId;
    } else if (SupportRepId != null || !forView) {
      map['SupportRepId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['CustomerId'] = CustomerId;
    if (FirstName != null || !forView) {
      map['FirstName'] = FirstName;
    }
    if (LastName != null || !forView) {
      map['LastName'] = LastName;
    }
    if (Company != null || !forView) {
      map['Company'] = Company;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }
    if (PostalCode != null || !forView) {
      map['PostalCode'] = PostalCode;
    }
    if (Phone != null || !forView) {
      map['Phone'] = Phone;
    }
    if (Fax != null || !forView) {
      map['Fax'] = Fax;
    }
    if (Email != null || !forView) {
      map['Email'] = Email;
    }
    if (SupportRepId != null) {
      map['SupportRepId'] = forView
          ? plEmployee == null
              ? SupportRepId
              : plEmployee!.LastName
          : SupportRepId;
    } else if (SupportRepId != null || !forView) {
      map['SupportRepId'] = null;
    }

// COLLECTIONS (Customer)
    if (!forQuery) {
      map['Invoices'] = await getInvoices()!.toMapList();
    }
// END COLLECTIONS (Customer)

    return map;
  }

  /// This method returns Json String [Customer]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Customer]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FirstName,
      LastName,
      Company,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      SupportRepId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      CustomerId,
      FirstName,
      LastName,
      Company,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      SupportRepId
    ];
  }

  static Future<List<Customer>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Customer.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Customer>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Customer>[];
    try {
      objList = list
          .map((customer) => Customer.fromMap(customer as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Customer.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Customer>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Customer> objList = <Customer>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Customer.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('Customer.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Customer by ID if exist, otherwise returns null
  /// Primary Keys: int? CustomerId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Customer] if exist, otherwise returns null
  Future<Customer?> getById(int? CustomerId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (CustomerId == null) {
      return null;
    }
    Customer? obj;
    final data = await _mnCustomer.getById([CustomerId]);
    if (data.length != 0) {
      obj = Customer.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('Customer.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Customer) object. If the CustomerId field is null, saves as a new record and returns new CustomerId, if CustomerId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns CustomerId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (CustomerId == null || CustomerId == 0) {
      CustomerId = await _mnCustomer.insert(this, ignoreBatch);
    } else {
      await _mnCustomer.update(this);
    }

    return CustomerId;
  }

  /// Saves the (Customer) object. If the CustomerId field is null, saves as a new record and returns new CustomerId, if CustomerId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns CustomerId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (CustomerId == null || CustomerId == 0) {
      CustomerId = await _mnCustomer.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // CustomerId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCustomer.updateOrThrow(this);
    }

    return CustomerId;
  }

  /// saveAs Customer. Returns a new Primary Key value of Customer

  /// <returns>Returns a new Primary Key value of Customer
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    CustomerId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Customer> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Customer> customers) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in customers) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < customers.length; i++) {
        if (customers[i].CustomerId == null) {
          customers[i].CustomerId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns CustomerId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCustomer.rawInsert(
          'INSERT OR REPLACE INTO Customer (CustomerId, FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            CustomerId,
            FirstName,
            LastName,
            Company,
            Address,
            City,
            State,
            Country,
            PostalCode,
            Phone,
            Fax,
            Email,
            SupportRepId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Customer CustomerId=$CustomerId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Customer CustomerId=$CustomerId did not update');
      }
      return CustomerId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Customer Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Customer>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Customer> customers) async {
    final results = await _mnCustomer.rawInsertAll(
        'INSERT OR REPLACE INTO Customer (CustomerId, FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        customers);
    return results;
  }

  /// Deletes Customer

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Customer invoked (CustomerId=$CustomerId)');
    if (await Invoice().select().CustomerId.equals(CustomerId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Invoice.CustomerId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnCustomer.delete(QueryParams(
          whereString: 'CustomerId=?', whereArguments: [CustomerId]));
    } else {
      return _mnCustomer.updateBatch(
          QueryParams(
              whereString: 'CustomerId=?', whereArguments: [CustomerId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Customer] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CustomerFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CustomerFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CustomerFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CustomerFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      CustomerId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion customer

// region CustomerField
class CustomerField extends FilterBase {
  CustomerField(CustomerFilterBuilder customerFB) : super(customerFB);

  @override
  CustomerFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder isNull() {
    return super.isNull() as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CustomerFilterBuilder;
  }

  @override
  CustomerField get not {
    return super.not as CustomerField;
  }
}
// endregion CustomerField

// region CustomerFilterBuilder
class CustomerFilterBuilder extends ConjunctionBase {
  CustomerFilterBuilder(Customer obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCustomer = obj._mnCustomer;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CustomerManager? _mnCustomer;

  /// put the sql keyword 'AND'
  @override
  CustomerFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CustomerFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CustomerFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CustomerFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CustomerFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CustomerFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CustomerFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CustomerFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CustomerFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CustomerFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CustomerFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CustomerField _setField(CustomerField? field, String colName, DbType dbtype) {
    return CustomerField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CustomerField? _CustomerId;
  CustomerField get CustomerId {
    return _CustomerId = _setField(_CustomerId, 'CustomerId', DbType.integer);
  }

  CustomerField? _FirstName;
  CustomerField get FirstName {
    return _FirstName = _setField(_FirstName, 'FirstName', DbType.text);
  }

  CustomerField? _LastName;
  CustomerField get LastName {
    return _LastName = _setField(_LastName, 'LastName', DbType.text);
  }

  CustomerField? _Company;
  CustomerField get Company {
    return _Company = _setField(_Company, 'Company', DbType.text);
  }

  CustomerField? _Address;
  CustomerField get Address {
    return _Address = _setField(_Address, 'Address', DbType.text);
  }

  CustomerField? _City;
  CustomerField get City {
    return _City = _setField(_City, 'City', DbType.text);
  }

  CustomerField? _State;
  CustomerField get State {
    return _State = _setField(_State, 'State', DbType.text);
  }

  CustomerField? _Country;
  CustomerField get Country {
    return _Country = _setField(_Country, 'Country', DbType.text);
  }

  CustomerField? _PostalCode;
  CustomerField get PostalCode {
    return _PostalCode = _setField(_PostalCode, 'PostalCode', DbType.text);
  }

  CustomerField? _Phone;
  CustomerField get Phone {
    return _Phone = _setField(_Phone, 'Phone', DbType.text);
  }

  CustomerField? _Fax;
  CustomerField get Fax {
    return _Fax = _setField(_Fax, 'Fax', DbType.text);
  }

  CustomerField? _Email;
  CustomerField get Email {
    return _Email = _setField(_Email, 'Email', DbType.text);
  }

  CustomerField? _SupportRepId;
  CustomerField get SupportRepId {
    return _SupportRepId =
        _setField(_SupportRepId, 'SupportRepId', DbType.integer);
  }

  /// Deletes List<Customer> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Invoice) according to DeleteRule.NO_ACTION

    final idListInvoiceBYCustomerId = toListPrimaryKeySQL(false);
    final resInvoiceBYCustomerId = await Invoice()
        .select()
        .where('CustomerId IN (${idListInvoiceBYCustomerId['sql']})',
            parameterValue: idListInvoiceBYCustomerId['args'])
        .toCount();
    if (resInvoiceBYCustomerId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Invoice.CustomerId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCustomer!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCustomer!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'CustomerId IN (SELECT CustomerId from Customer ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCustomer!.updateBatch(qparams, values);
  }

  /// This method always returns [Customer] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Customer?
  @override
  Future<Customer?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCustomer!.toList(qparams);
    final data = await objFuture;
    Customer? obj;
    if (data.isNotEmpty) {
      obj = Customer.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedfields!.add('Customer.plInvoices'); */ obj.plInvoices =
              obj.plInvoices ??
                  await obj.getInvoices()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Customer]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Customer?
  @override
  Future<Customer> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Customer();
  }

  /// This method returns int. [Customer]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? customerCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final customersFuture = await _mnCustomer!.toList(qparams);
    final int count = customersFuture[0]['CNT'] as int;
    if (customerCount != null) {
      customerCount(count);
    }
    return count;
  }

  /// This method returns List<Customer> [Customer]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Customer>
  @override
  Future<List<Customer>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Customer> customersData = await Customer.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return customersData;
  }

  /// This method returns Json String [Customer]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Customer]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Customer]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCustomer!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Customer>>
  Future<List<DropdownMenuItem<Customer>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Customer>> o)?
          dropDownMenu]) async {
    buildParameters();
    final customersFuture = _mnCustomer!.toList(qparams);

    final data = await customersFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Customer>> items = []..add(DropdownMenuItem(
        value: Customer(),
        child: Text('Select Customer'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Customer.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['CustomerId', displayTextColumn];
    final customersFuture = _mnCustomer!.toList(qparams);

    final data = await customersFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Customer'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['CustomerId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Customer]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CustomerId` FROM Customer WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> CustomerIdData = <int>[];
    qparams.selectColumns = ['CustomerId'];
    final CustomerIdFuture = await _mnCustomer!.toList(qparams);

    final int count = CustomerIdFuture.length;
    for (int i = 0; i < count; i++) {
      CustomerIdData.add(CustomerIdFuture[i]['CustomerId'] as int);
    }
    return CustomerIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Customer]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCustomer!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Customer.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCustomer!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CustomerFilterBuilder

// region CustomerFields
class CustomerFields {
  static TableField? _fCustomerId;
  static TableField get CustomerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'customerid', DbType.integer);
  }

  static TableField? _fFirstName;
  static TableField get FirstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'FirstName', DbType.text);
  }

  static TableField? _fLastName;
  static TableField get LastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'LastName', DbType.text);
  }

  static TableField? _fCompany;
  static TableField get Company {
    return _fCompany =
        _fCompany ?? SqlSyntax.setField(_fCompany, 'Company', DbType.text);
  }

  static TableField? _fAddress;
  static TableField get Address {
    return _fAddress =
        _fAddress ?? SqlSyntax.setField(_fAddress, 'Address', DbType.text);
  }

  static TableField? _fCity;
  static TableField get City {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'City', DbType.text);
  }

  static TableField? _fState;
  static TableField get State {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'State', DbType.text);
  }

  static TableField? _fCountry;
  static TableField get Country {
    return _fCountry =
        _fCountry ?? SqlSyntax.setField(_fCountry, 'Country', DbType.text);
  }

  static TableField? _fPostalCode;
  static TableField get PostalCode {
    return _fPostalCode = _fPostalCode ??
        SqlSyntax.setField(_fPostalCode, 'PostalCode', DbType.text);
  }

  static TableField? _fPhone;
  static TableField get Phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'Phone', DbType.text);
  }

  static TableField? _fFax;
  static TableField get Fax {
    return _fFax = _fFax ?? SqlSyntax.setField(_fFax, 'Fax', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get Email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'Email', DbType.text);
  }

  static TableField? _fSupportRepId;
  static TableField get SupportRepId {
    return _fSupportRepId = _fSupportRepId ??
        SqlSyntax.setField(_fSupportRepId, 'SupportRepId', DbType.integer);
  }
}
// endregion CustomerFields

//region CustomerManager
class CustomerManager extends SqfEntityProvider {
  CustomerManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Customer';
  static const List<String> _primaryKeyList = ['CustomerId'];
  static const String _whereStr = 'CustomerId=?';
}

//endregion CustomerManager
// region Employee
class Employee extends TableBase {
  Employee(
      {this.EmployeeId,
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Employee.withFields(
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo) {
    _setDefaultValues();
  }
  Employee.withId(
      this.EmployeeId,
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Employee.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EmployeeId = int.tryParse(o['EmployeeId'].toString());
    if (o['LastName'] != null) {
      LastName = o['LastName'].toString();
    }
    if (o['FirstName'] != null) {
      FirstName = o['FirstName'].toString();
    }
    if (o['Title'] != null) {
      Title = o['Title'].toString();
    }
    if (o['BirthDate'] != null) {
      BirthDate = int.tryParse(o['BirthDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['BirthDate'].toString())!)
          : DateTime.tryParse(o['BirthDate'].toString());
    }
    if (o['HireDate'] != null) {
      HireDate = int.tryParse(o['HireDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['HireDate'].toString())!)
          : DateTime.tryParse(o['HireDate'].toString());
    }
    if (o['Address'] != null) {
      Address = o['Address'].toString();
    }
    if (o['City'] != null) {
      City = o['City'].toString();
    }
    if (o['State'] != null) {
      State = o['State'].toString();
    }
    if (o['Country'] != null) {
      Country = o['Country'].toString();
    }
    if (o['PostalCode'] != null) {
      PostalCode = o['PostalCode'].toString();
    }
    if (o['Phone'] != null) {
      Phone = o['Phone'].toString();
    }
    if (o['Fax'] != null) {
      Fax = o['Fax'].toString();
    }
    if (o['Email'] != null) {
      Email = o['Email'].toString();
    }
    ReportsTo = int.tryParse(o['ReportsTo'].toString());

    // RELATIONSHIPS FromMAP
    plEmployee = o['employee'] != null
        ? Employee.fromMap(o['employee'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Employee)
  int? EmployeeId;
  String? LastName;
  String? FirstName;
  String? Title;
  DateTime? BirthDate;
  DateTime? HireDate;
  String? Address;
  String? City;
  String? State;
  String? Country;
  String? PostalCode;
  String? Phone;
  String? Fax;
  String? Email;
  int? ReportsTo;

  // end FIELDS (Employee)

// RELATIONSHIPS (Employee)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plEmployee', 'plField2'..]) or so on..
  Employee? plEmployee;

  /// get Employee By ReportsTo
  Future<Employee?> getEmployee(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Employee().getById(ReportsTo,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Employee)

// COLLECTIONS & VIRTUALS (Employee)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCustomers', 'plField2'..]) or so on..
  List<Customer>? plCustomers;

  /// get Customer(s) filtered by EmployeeId=SupportRepId
  CustomerFilterBuilder? getCustomers(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (EmployeeId == null) {
      return null;
    }
    return Customer()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .SupportRepId
        .equals(EmployeeId)
        .and;
  }

  /// (Relationship to itself) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plReportsTos', 'plField2'..]) or so on..
  List<Employee>? plReportsTos;

  /// get Employee(s) filtered by EmployeeId=ReportsTo
  EmployeeFilterBuilder? getReportsTos(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (EmployeeId == null) {
      return null;
    }
    return Employee()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ReportsTo
        .equals(EmployeeId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Employee)

  static const bool _softDeleteActivated = false;
  EmployeeManager? __mnEmployee;

  EmployeeManager get _mnEmployee {
    return __mnEmployee = __mnEmployee ?? EmployeeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EmployeeId'] = EmployeeId;
    if (LastName != null || !forView) {
      map['LastName'] = LastName;
    }
    if (FirstName != null || !forView) {
      map['FirstName'] = FirstName;
    }
    if (Title != null || !forView) {
      map['Title'] = Title;
    }
    if (BirthDate != null) {
      map['BirthDate'] = forJson
          ? BirthDate!.toString()
          : forQuery
              ? BirthDate!.millisecondsSinceEpoch
              : BirthDate;
    } else if (BirthDate != null || !forView) {
      map['BirthDate'] = null;
    }
    if (HireDate != null) {
      map['HireDate'] = forJson
          ? HireDate!.toString()
          : forQuery
              ? HireDate!.millisecondsSinceEpoch
              : HireDate;
    } else if (HireDate != null || !forView) {
      map['HireDate'] = null;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }
    if (PostalCode != null || !forView) {
      map['PostalCode'] = PostalCode;
    }
    if (Phone != null || !forView) {
      map['Phone'] = Phone;
    }
    if (Fax != null || !forView) {
      map['Fax'] = Fax;
    }
    if (Email != null || !forView) {
      map['Email'] = Email;
    }
    if (ReportsTo != null) {
      map['ReportsTo'] = forView
          ? plEmployee == null
              ? ReportsTo
              : plEmployee!.LastName
          : ReportsTo;
    } else if (ReportsTo != null || !forView) {
      map['ReportsTo'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EmployeeId'] = EmployeeId;
    if (LastName != null || !forView) {
      map['LastName'] = LastName;
    }
    if (FirstName != null || !forView) {
      map['FirstName'] = FirstName;
    }
    if (Title != null || !forView) {
      map['Title'] = Title;
    }
    if (BirthDate != null) {
      map['BirthDate'] = forJson
          ? BirthDate!.toString()
          : forQuery
              ? BirthDate!.millisecondsSinceEpoch
              : BirthDate;
    } else if (BirthDate != null || !forView) {
      map['BirthDate'] = null;
    }
    if (HireDate != null) {
      map['HireDate'] = forJson
          ? HireDate!.toString()
          : forQuery
              ? HireDate!.millisecondsSinceEpoch
              : HireDate;
    } else if (HireDate != null || !forView) {
      map['HireDate'] = null;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }
    if (PostalCode != null || !forView) {
      map['PostalCode'] = PostalCode;
    }
    if (Phone != null || !forView) {
      map['Phone'] = Phone;
    }
    if (Fax != null || !forView) {
      map['Fax'] = Fax;
    }
    if (Email != null || !forView) {
      map['Email'] = Email;
    }
    if (ReportsTo != null) {
      map['ReportsTo'] = forView
          ? plEmployee == null
              ? ReportsTo
              : plEmployee!.LastName
          : ReportsTo;
    } else if (ReportsTo != null || !forView) {
      map['ReportsTo'] = null;
    }

// COLLECTIONS (Employee)
    if (!forQuery) {
      map['Customers'] = await getCustomers()!.toMapList();
    }
    if (!forQuery) {
      map['ReportsTos'] = await getReportsTos()!.toMapList();
    }
// END COLLECTIONS (Employee)

    return map;
  }

  /// This method returns Json String [Employee]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Employee]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      LastName,
      FirstName,
      Title,
      BirthDate != null ? BirthDate!.millisecondsSinceEpoch : null,
      HireDate != null ? HireDate!.millisecondsSinceEpoch : null,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      ReportsTo
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EmployeeId,
      LastName,
      FirstName,
      Title,
      BirthDate != null ? BirthDate!.millisecondsSinceEpoch : null,
      HireDate != null ? HireDate!.millisecondsSinceEpoch : null,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      ReportsTo
    ];
  }

  static Future<List<Employee>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Employee.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Employee>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Employee>[];
    try {
      objList = list
          .map((employee) => Employee.fromMap(employee as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Employee.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Employee>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Employee> objList = <Employee>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Employee.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedfields!.add('Employee.plCustomers'); */ obj.plCustomers =
              obj.plCustomers ??
                  await obj.getCustomers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedfields!.add('Employee.plReportsTos'); */ obj.plReportsTos =
              obj.plReportsTos ??
                  await obj.getReportsTos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Employee by ID if exist, otherwise returns null
  /// Primary Keys: int? EmployeeId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Employee] if exist, otherwise returns null
  Future<Employee?> getById(int? EmployeeId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EmployeeId == null) {
      return null;
    }
    Employee? obj;
    final data = await _mnEmployee.getById([EmployeeId]);
    if (data.length != 0) {
      obj = Employee.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedfields!.add('Employee.plCustomers'); */ obj.plCustomers =
              obj.plCustomers ??
                  await obj.getCustomers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedfields!.add('Employee.plReportsTos'); */ obj.plReportsTos =
              obj.plReportsTos ??
                  await obj.getReportsTos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Employee) object. If the EmployeeId field is null, saves as a new record and returns new EmployeeId, if EmployeeId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns EmployeeId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (EmployeeId == null || EmployeeId == 0) {
      EmployeeId = await _mnEmployee.insert(this, ignoreBatch);
    } else {
      await _mnEmployee.update(this);
    }

    return EmployeeId;
  }

  /// Saves the (Employee) object. If the EmployeeId field is null, saves as a new record and returns new EmployeeId, if EmployeeId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns EmployeeId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (EmployeeId == null || EmployeeId == 0) {
      EmployeeId = await _mnEmployee.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // EmployeeId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnEmployee.updateOrThrow(this);
    }

    return EmployeeId;
  }

  /// saveAs Employee. Returns a new Primary Key value of Employee

  /// <returns>Returns a new Primary Key value of Employee
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    EmployeeId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Employee> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Employee> employees) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in employees) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < employees.length; i++) {
        if (employees[i].EmployeeId == null) {
          employees[i].EmployeeId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns EmployeeId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEmployee.rawInsert(
          'INSERT OR REPLACE INTO Employee (EmployeeId, LastName, FirstName, Title, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email, ReportsTo)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EmployeeId,
            LastName,
            FirstName,
            Title,
            BirthDate != null ? BirthDate!.millisecondsSinceEpoch : null,
            HireDate != null ? HireDate!.millisecondsSinceEpoch : null,
            Address,
            City,
            State,
            Country,
            PostalCode,
            Phone,
            Fax,
            Email,
            ReportsTo
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Employee EmployeeId=$EmployeeId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Employee EmployeeId=$EmployeeId did not update');
      }
      return EmployeeId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Employee Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Employee>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Employee> employees) async {
    final results = await _mnEmployee.rawInsertAll(
        'INSERT OR REPLACE INTO Employee (EmployeeId, LastName, FirstName, Title, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email, ReportsTo)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        employees);
    return results;
  }

  /// Deletes Employee

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Employee invoked (EmployeeId=$EmployeeId)');
    if (await Customer()
            .select()
            .SupportRepId
            .equals(EmployeeId)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Customer.SupportRepId)');
    }
    if (await Employee().select().ReportsTo.equals(EmployeeId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Employee.ReportsTo)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnEmployee.delete(QueryParams(
          whereString: 'EmployeeId=?', whereArguments: [EmployeeId]));
    } else {
      return _mnEmployee.updateBatch(
          QueryParams(
              whereString: 'EmployeeId=?', whereArguments: [EmployeeId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Employee] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  EmployeeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmployeeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  EmployeeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmployeeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EmployeeId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion employee

// region EmployeeField
class EmployeeField extends FilterBase {
  EmployeeField(EmployeeFilterBuilder employeeFB) : super(employeeFB);

  @override
  EmployeeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder isNull() {
    return super.isNull() as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as EmployeeFilterBuilder;
  }

  @override
  EmployeeField get not {
    return super.not as EmployeeField;
  }
}
// endregion EmployeeField

// region EmployeeFilterBuilder
class EmployeeFilterBuilder extends ConjunctionBase {
  EmployeeFilterBuilder(Employee obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnEmployee = obj._mnEmployee;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  EmployeeManager? _mnEmployee;

  /// put the sql keyword 'AND'
  @override
  EmployeeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  EmployeeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  EmployeeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  EmployeeFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  EmployeeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  EmployeeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  EmployeeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmployeeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmployeeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmployeeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmployeeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  EmployeeField _setField(EmployeeField? field, String colName, DbType dbtype) {
    return EmployeeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  EmployeeField? _EmployeeId;
  EmployeeField get EmployeeId {
    return _EmployeeId = _setField(_EmployeeId, 'EmployeeId', DbType.integer);
  }

  EmployeeField? _LastName;
  EmployeeField get LastName {
    return _LastName = _setField(_LastName, 'LastName', DbType.text);
  }

  EmployeeField? _FirstName;
  EmployeeField get FirstName {
    return _FirstName = _setField(_FirstName, 'FirstName', DbType.text);
  }

  EmployeeField? _Title;
  EmployeeField get Title {
    return _Title = _setField(_Title, 'Title', DbType.text);
  }

  EmployeeField? _BirthDate;
  EmployeeField get BirthDate {
    return _BirthDate = _setField(_BirthDate, 'BirthDate', DbType.datetime);
  }

  EmployeeField? _HireDate;
  EmployeeField get HireDate {
    return _HireDate = _setField(_HireDate, 'HireDate', DbType.datetime);
  }

  EmployeeField? _Address;
  EmployeeField get Address {
    return _Address = _setField(_Address, 'Address', DbType.text);
  }

  EmployeeField? _City;
  EmployeeField get City {
    return _City = _setField(_City, 'City', DbType.text);
  }

  EmployeeField? _State;
  EmployeeField get State {
    return _State = _setField(_State, 'State', DbType.text);
  }

  EmployeeField? _Country;
  EmployeeField get Country {
    return _Country = _setField(_Country, 'Country', DbType.text);
  }

  EmployeeField? _PostalCode;
  EmployeeField get PostalCode {
    return _PostalCode = _setField(_PostalCode, 'PostalCode', DbType.text);
  }

  EmployeeField? _Phone;
  EmployeeField get Phone {
    return _Phone = _setField(_Phone, 'Phone', DbType.text);
  }

  EmployeeField? _Fax;
  EmployeeField get Fax {
    return _Fax = _setField(_Fax, 'Fax', DbType.text);
  }

  EmployeeField? _Email;
  EmployeeField get Email {
    return _Email = _setField(_Email, 'Email', DbType.text);
  }

  EmployeeField? _ReportsTo;
  EmployeeField get ReportsTo {
    return _ReportsTo = _setField(_ReportsTo, 'ReportsTo', DbType.integer);
  }

  /// Deletes List<Employee> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Customer) according to DeleteRule.NO_ACTION

    final idListCustomerBYSupportRepId = toListPrimaryKeySQL(false);
    final resCustomerBYSupportRepId = await Customer()
        .select()
        .where('SupportRepId IN (${idListCustomerBYSupportRepId['sql']})',
            parameterValue: idListCustomerBYSupportRepId['args'])
        .toCount();
    if (resCustomerBYSupportRepId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Customer.SupportRepId)');
    }
// Check sub records where in (Employee) according to DeleteRule.NO_ACTION

    final idListEmployeeBYReportsTo = toListPrimaryKeySQL(false);
    final resEmployeeBYReportsTo = await Employee()
        .select()
        .where('ReportsTo IN (${idListEmployeeBYReportsTo['sql']})',
            parameterValue: idListEmployeeBYReportsTo['args'])
        .toCount();
    if (resEmployeeBYReportsTo > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Employee.ReportsTo)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnEmployee!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnEmployee!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EmployeeId IN (SELECT EmployeeId from Employee ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnEmployee!.updateBatch(qparams, values);
  }

  /// This method always returns [Employee] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Employee?
  @override
  Future<Employee?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnEmployee!.toList(qparams);
    final data = await objFuture;
    Employee? obj;
    if (data.isNotEmpty) {
      obj = Employee.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedfields!.add('Employee.plCustomers'); */ obj.plCustomers =
              obj.plCustomers ??
                  await obj.getCustomers()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedfields!.add('Employee.plReportsTos'); */ obj.plReportsTos =
              obj.plReportsTos ??
                  await obj.getReportsTos()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          obj.plEmployee =
              obj.plEmployee ?? await obj.getEmployee(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Employee]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Employee?
  @override
  Future<Employee> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Employee();
  }

  /// This method returns int. [Employee]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? employeeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final employeesFuture = await _mnEmployee!.toList(qparams);
    final int count = employeesFuture[0]['CNT'] as int;
    if (employeeCount != null) {
      employeeCount(count);
    }
    return count;
  }

  /// This method returns List<Employee> [Employee]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Employee>
  @override
  Future<List<Employee>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Employee> employeesData = await Employee.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return employeesData;
  }

  /// This method returns Json String [Employee]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Employee]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Employee]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnEmployee!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Employee>>
  Future<List<DropdownMenuItem<Employee>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Employee>> o)?
          dropDownMenu]) async {
    buildParameters();
    final employeesFuture = _mnEmployee!.toList(qparams);

    final data = await employeesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Employee>> items = []..add(DropdownMenuItem(
        value: Employee(),
        child: Text('Select Employee'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Employee.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['EmployeeId', displayTextColumn];
    final employeesFuture = _mnEmployee!.toList(qparams);

    final data = await employeesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Employee'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['EmployeeId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Employee]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EmployeeId` FROM Employee WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> EmployeeIdData = <int>[];
    qparams.selectColumns = ['EmployeeId'];
    final EmployeeIdFuture = await _mnEmployee!.toList(qparams);

    final int count = EmployeeIdFuture.length;
    for (int i = 0; i < count; i++) {
      EmployeeIdData.add(EmployeeIdFuture[i]['EmployeeId'] as int);
    }
    return EmployeeIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Employee]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnEmployee!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Employee.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnEmployee!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EmployeeFilterBuilder

// region EmployeeFields
class EmployeeFields {
  static TableField? _fEmployeeId;
  static TableField get EmployeeId {
    return _fEmployeeId = _fEmployeeId ??
        SqlSyntax.setField(_fEmployeeId, 'employeeid', DbType.integer);
  }

  static TableField? _fLastName;
  static TableField get LastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'LastName', DbType.text);
  }

  static TableField? _fFirstName;
  static TableField get FirstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'FirstName', DbType.text);
  }

  static TableField? _fTitle;
  static TableField get Title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'Title', DbType.text);
  }

  static TableField? _fBirthDate;
  static TableField get BirthDate {
    return _fBirthDate = _fBirthDate ??
        SqlSyntax.setField(_fBirthDate, 'BirthDate', DbType.datetime);
  }

  static TableField? _fHireDate;
  static TableField get HireDate {
    return _fHireDate = _fHireDate ??
        SqlSyntax.setField(_fHireDate, 'HireDate', DbType.datetime);
  }

  static TableField? _fAddress;
  static TableField get Address {
    return _fAddress =
        _fAddress ?? SqlSyntax.setField(_fAddress, 'Address', DbType.text);
  }

  static TableField? _fCity;
  static TableField get City {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'City', DbType.text);
  }

  static TableField? _fState;
  static TableField get State {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'State', DbType.text);
  }

  static TableField? _fCountry;
  static TableField get Country {
    return _fCountry =
        _fCountry ?? SqlSyntax.setField(_fCountry, 'Country', DbType.text);
  }

  static TableField? _fPostalCode;
  static TableField get PostalCode {
    return _fPostalCode = _fPostalCode ??
        SqlSyntax.setField(_fPostalCode, 'PostalCode', DbType.text);
  }

  static TableField? _fPhone;
  static TableField get Phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'Phone', DbType.text);
  }

  static TableField? _fFax;
  static TableField get Fax {
    return _fFax = _fFax ?? SqlSyntax.setField(_fFax, 'Fax', DbType.text);
  }

  static TableField? _fEmail;
  static TableField get Email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'Email', DbType.text);
  }

  static TableField? _fReportsTo;
  static TableField get ReportsTo {
    return _fReportsTo = _fReportsTo ??
        SqlSyntax.setField(_fReportsTo, 'ReportsTo', DbType.integer);
  }
}
// endregion EmployeeFields

//region EmployeeManager
class EmployeeManager extends SqfEntityProvider {
  EmployeeManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Employee';
  static const List<String> _primaryKeyList = ['EmployeeId'];
  static const String _whereStr = 'EmployeeId=?';
}

//endregion EmployeeManager
// region Genre
class Genre extends TableBase {
  Genre({this.GenreId, this.Name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Genre.withFields(this.Name) {
    _setDefaultValues();
  }
  Genre.withId(this.GenreId, this.Name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Genre.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    GenreId = int.tryParse(o['GenreId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
  }
  // FIELDS (Genre)
  int? GenreId;
  String? Name;

  // end FIELDS (Genre)

// COLLECTIONS & VIRTUALS (Genre)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track>? plTracks;

  /// get Track(s) filtered by GenreId=GenreId
  TrackFilterBuilder? getTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (GenreId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .GenreId
        .equals(GenreId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Genre)

  static const bool _softDeleteActivated = false;
  GenreManager? __mnGenre;

  GenreManager get _mnGenre {
    return __mnGenre = __mnGenre ?? GenreManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['GenreId'] = GenreId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['GenreId'] = GenreId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

// COLLECTIONS (Genre)
    if (!forQuery) {
      map['Tracks'] = await getTracks()!.toMapList();
    }
// END COLLECTIONS (Genre)

    return map;
  }

  /// This method returns Json String [Genre]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Genre]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [GenreId, Name];
  }

  static Future<List<Genre>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Genre.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Genre>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Genre>[];
    try {
      objList = list
          .map((genre) => Genre.fromMap(genre as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Genre.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Genre>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Genre> objList = <Genre>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Genre.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Genre.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Genre by ID if exist, otherwise returns null
  /// Primary Keys: int? GenreId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Genre] if exist, otherwise returns null
  Future<Genre?> getById(int? GenreId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (GenreId == null) {
      return null;
    }
    Genre? obj;
    final data = await _mnGenre.getById([GenreId]);
    if (data.length != 0) {
      obj = Genre.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Genre.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Genre) object. If the GenreId field is null, saves as a new record and returns new GenreId, if GenreId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns GenreId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (GenreId == null || GenreId == 0) {
      GenreId = await _mnGenre.insert(this, ignoreBatch);
    } else {
      await _mnGenre.update(this);
    }

    return GenreId;
  }

  /// Saves the (Genre) object. If the GenreId field is null, saves as a new record and returns new GenreId, if GenreId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns GenreId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (GenreId == null || GenreId == 0) {
      GenreId = await _mnGenre.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // GenreId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnGenre.updateOrThrow(this);
    }

    return GenreId;
  }

  /// saveAs Genre. Returns a new Primary Key value of Genre

  /// <returns>Returns a new Primary Key value of Genre
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    GenreId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Genre> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Genre> genres) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in genres) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < genres.length; i++) {
        if (genres[i].GenreId == null) {
          genres[i].GenreId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns GenreId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnGenre.rawInsert(
          'INSERT OR REPLACE INTO Genre (GenreId, Name)  VALUES (?,?)',
          [GenreId, Name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Genre GenreId=$GenreId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Genre GenreId=$GenreId did not update');
      }
      return GenreId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Genre Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Genre>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Genre> genres) async {
    final results = await _mnGenre.rawInsertAll(
        'INSERT OR REPLACE INTO Genre (GenreId, Name)  VALUES (?,?)', genres);
    return results;
  }

  /// Deletes Genre

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Genre invoked (GenreId=$GenreId)');
    if (await Track().select().GenreId.equals(GenreId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.GenreId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnGenre.delete(
          QueryParams(whereString: 'GenreId=?', whereArguments: [GenreId]));
    } else {
      return _mnGenre.updateBatch(
          QueryParams(whereString: 'GenreId=?', whereArguments: [GenreId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Genre] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  GenreFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return GenreFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  GenreFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return GenreFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      GenreId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion genre

// region GenreField
class GenreField extends FilterBase {
  GenreField(GenreFilterBuilder genreFB) : super(genreFB);

  @override
  GenreFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder isNull() {
    return super.isNull() as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as GenreFilterBuilder;
  }

  @override
  GenreFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as GenreFilterBuilder;
  }

  @override
  GenreField get not {
    return super.not as GenreField;
  }
}
// endregion GenreField

// region GenreFilterBuilder
class GenreFilterBuilder extends ConjunctionBase {
  GenreFilterBuilder(Genre obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnGenre = obj._mnGenre;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  GenreManager? _mnGenre;

  /// put the sql keyword 'AND'
  @override
  GenreFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  GenreFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  GenreFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  GenreFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  GenreFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  GenreFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  GenreFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  GenreFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  GenreFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  GenreFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  GenreFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  GenreField _setField(GenreField? field, String colName, DbType dbtype) {
    return GenreField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  GenreField? _GenreId;
  GenreField get GenreId {
    return _GenreId = _setField(_GenreId, 'GenreId', DbType.integer);
  }

  GenreField? _Name;
  GenreField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  /// Deletes List<Genre> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYGenreId = toListPrimaryKeySQL(false);
    final resTrackBYGenreId = await Track()
        .select()
        .where('GenreId IN (${idListTrackBYGenreId['sql']})',
            parameterValue: idListTrackBYGenreId['args'])
        .toCount();
    if (resTrackBYGenreId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.GenreId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnGenre!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnGenre!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'GenreId IN (SELECT GenreId from Genre ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnGenre!.updateBatch(qparams, values);
  }

  /// This method always returns [Genre] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Genre?
  @override
  Future<Genre?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnGenre!.toList(qparams);
    final data = await objFuture;
    Genre? obj;
    if (data.isNotEmpty) {
      obj = Genre.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Genre.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Genre]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Genre?
  @override
  Future<Genre> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Genre();
  }

  /// This method returns int. [Genre]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? genreCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final genresFuture = await _mnGenre!.toList(qparams);
    final int count = genresFuture[0]['CNT'] as int;
    if (genreCount != null) {
      genreCount(count);
    }
    return count;
  }

  /// This method returns List<Genre> [Genre]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Genre>
  @override
  Future<List<Genre>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Genre> genresData = await Genre.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return genresData;
  }

  /// This method returns Json String [Genre]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Genre]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Genre]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnGenre!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Genre>>
  Future<List<DropdownMenuItem<Genre>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Genre>> o)?
          dropDownMenu]) async {
    buildParameters();
    final genresFuture = _mnGenre!.toList(qparams);

    final data = await genresFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Genre>> items = []..add(DropdownMenuItem(
        value: Genre(),
        child: Text('Select Genre'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Genre.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['GenreId', displayTextColumn];
    final genresFuture = _mnGenre!.toList(qparams);

    final data = await genresFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Genre'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['GenreId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Genre]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `GenreId` FROM Genre WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> GenreIdData = <int>[];
    qparams.selectColumns = ['GenreId'];
    final GenreIdFuture = await _mnGenre!.toList(qparams);

    final int count = GenreIdFuture.length;
    for (int i = 0; i < count; i++) {
      GenreIdData.add(GenreIdFuture[i]['GenreId'] as int);
    }
    return GenreIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Genre]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnGenre!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Genre.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnGenre!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion GenreFilterBuilder

// region GenreFields
class GenreFields {
  static TableField? _fGenreId;
  static TableField get GenreId {
    return _fGenreId =
        _fGenreId ?? SqlSyntax.setField(_fGenreId, 'genreid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion GenreFields

//region GenreManager
class GenreManager extends SqfEntityProvider {
  GenreManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Genre';
  static const List<String> _primaryKeyList = ['GenreId'];
  static const String _whereStr = 'GenreId=?';
}

//endregion GenreManager
// region Invoice
class Invoice extends TableBase {
  Invoice(
      {this.InvoiceId,
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Invoice.withFields(
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId) {
    _setDefaultValues();
  }
  Invoice.withId(
      this.InvoiceId,
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Invoice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InvoiceId = int.tryParse(o['InvoiceId'].toString());
    if (o['InvoiceDate'] != null) {
      InvoiceDate = int.tryParse(o['InvoiceDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['InvoiceDate'].toString())!)
          : DateTime.tryParse(o['InvoiceDate'].toString());
    }
    if (o['BillingAddress'] != null) {
      BillingAddress = o['BillingAddress'].toString();
    }
    if (o['BillingCity'] != null) {
      BillingCity = o['BillingCity'].toString();
    }
    if (o['BillingState'] != null) {
      BillingState = o['BillingState'].toString();
    }
    if (o['BillingCountry'] != null) {
      BillingCountry = o['BillingCountry'].toString();
    }
    if (o['BillingPostalCode'] != null) {
      BillingPostalCode = o['BillingPostalCode'].toString();
    }
    if (o['Total'] != null) {
      Total = double.tryParse(o['Total'].toString());
    }
    CustomerId = int.tryParse(o['CustomerId'].toString());

    // RELATIONSHIPS FromMAP
    plCustomer = o['customer'] != null
        ? Customer.fromMap(o['customer'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Invoice)
  int? InvoiceId;
  DateTime? InvoiceDate;
  String? BillingAddress;
  String? BillingCity;
  String? BillingState;
  String? BillingCountry;
  String? BillingPostalCode;
  double? Total;
  int? CustomerId;

  // end FIELDS (Invoice)

// RELATIONSHIPS (Invoice)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plCustomer', 'plField2'..]) or so on..
  Customer? plCustomer;

  /// get Customer By CustomerId
  Future<Customer?> getCustomer(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Customer().getById(CustomerId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Invoice)

// COLLECTIONS & VIRTUALS (Invoice)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plInvoiceLines', 'plField2'..]) or so on..
  List<InvoiceLine>? plInvoiceLines;

  /// get InvoiceLine(s) filtered by InvoiceId=InvoiceId
  InvoiceLineFilterBuilder? getInvoiceLines(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (InvoiceId == null) {
      return null;
    }
    return InvoiceLine()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .InvoiceId
        .equals(InvoiceId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Invoice)

  static const bool _softDeleteActivated = false;
  InvoiceManager? __mnInvoice;

  InvoiceManager get _mnInvoice {
    return __mnInvoice = __mnInvoice ?? InvoiceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InvoiceId'] = InvoiceId;
    if (InvoiceDate != null) {
      map['InvoiceDate'] = forJson
          ? InvoiceDate!.toString()
          : forQuery
              ? InvoiceDate!.millisecondsSinceEpoch
              : InvoiceDate;
    } else if (InvoiceDate != null || !forView) {
      map['InvoiceDate'] = null;
    }
    if (BillingAddress != null || !forView) {
      map['BillingAddress'] = BillingAddress;
    }
    if (BillingCity != null || !forView) {
      map['BillingCity'] = BillingCity;
    }
    if (BillingState != null || !forView) {
      map['BillingState'] = BillingState;
    }
    if (BillingCountry != null || !forView) {
      map['BillingCountry'] = BillingCountry;
    }
    if (BillingPostalCode != null || !forView) {
      map['BillingPostalCode'] = BillingPostalCode;
    }
    if (Total != null || !forView) {
      map['Total'] = Total;
    }
    if (CustomerId != null) {
      map['CustomerId'] = forView
          ? plCustomer == null
              ? CustomerId
              : plCustomer!.FirstName
          : CustomerId;
    } else if (CustomerId != null || !forView) {
      map['CustomerId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InvoiceId'] = InvoiceId;
    if (InvoiceDate != null) {
      map['InvoiceDate'] = forJson
          ? InvoiceDate!.toString()
          : forQuery
              ? InvoiceDate!.millisecondsSinceEpoch
              : InvoiceDate;
    } else if (InvoiceDate != null || !forView) {
      map['InvoiceDate'] = null;
    }
    if (BillingAddress != null || !forView) {
      map['BillingAddress'] = BillingAddress;
    }
    if (BillingCity != null || !forView) {
      map['BillingCity'] = BillingCity;
    }
    if (BillingState != null || !forView) {
      map['BillingState'] = BillingState;
    }
    if (BillingCountry != null || !forView) {
      map['BillingCountry'] = BillingCountry;
    }
    if (BillingPostalCode != null || !forView) {
      map['BillingPostalCode'] = BillingPostalCode;
    }
    if (Total != null || !forView) {
      map['Total'] = Total;
    }
    if (CustomerId != null) {
      map['CustomerId'] = forView
          ? plCustomer == null
              ? CustomerId
              : plCustomer!.FirstName
          : CustomerId;
    } else if (CustomerId != null || !forView) {
      map['CustomerId'] = null;
    }

// COLLECTIONS (Invoice)
    if (!forQuery) {
      map['InvoiceLines'] = await getInvoiceLines()!.toMapList();
    }
// END COLLECTIONS (Invoice)

    return map;
  }

  /// This method returns Json String [Invoice]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Invoice]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      InvoiceDate != null ? InvoiceDate!.millisecondsSinceEpoch : null,
      BillingAddress,
      BillingCity,
      BillingState,
      BillingCountry,
      BillingPostalCode,
      Total,
      CustomerId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      InvoiceId,
      InvoiceDate != null ? InvoiceDate!.millisecondsSinceEpoch : null,
      BillingAddress,
      BillingCity,
      BillingState,
      BillingCountry,
      BillingPostalCode,
      Total,
      CustomerId
    ];
  }

  static Future<List<Invoice>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Invoice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Invoice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Invoice>[];
    try {
      objList = list
          .map((invoice) => Invoice.fromMap(invoice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Invoice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Invoice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Invoice> objList = <Invoice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Invoice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Invoice.plInvoiceLines'); */ obj
                  .plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          obj.plCustomer =
              obj.plCustomer ?? await obj.getCustomer(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Invoice by ID if exist, otherwise returns null
  /// Primary Keys: int? InvoiceId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Invoice] if exist, otherwise returns null
  Future<Invoice?> getById(int? InvoiceId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InvoiceId == null) {
      return null;
    }
    Invoice? obj;
    final data = await _mnInvoice.getById([InvoiceId]);
    if (data.length != 0) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Invoice.plInvoiceLines'); */ obj
                  .plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          obj.plCustomer =
              obj.plCustomer ?? await obj.getCustomer(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Invoice) object. If the InvoiceId field is null, saves as a new record and returns new InvoiceId, if InvoiceId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns InvoiceId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (InvoiceId == null || InvoiceId == 0) {
      InvoiceId = await _mnInvoice.insert(this, ignoreBatch);
    } else {
      await _mnInvoice.update(this);
    }

    return InvoiceId;
  }

  /// Saves the (Invoice) object. If the InvoiceId field is null, saves as a new record and returns new InvoiceId, if InvoiceId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns InvoiceId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (InvoiceId == null || InvoiceId == 0) {
      InvoiceId = await _mnInvoice.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // InvoiceId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoice.updateOrThrow(this);
    }

    return InvoiceId;
  }

  /// saveAs Invoice. Returns a new Primary Key value of Invoice

  /// <returns>Returns a new Primary Key value of Invoice
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    InvoiceId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Invoice> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Invoice> invoices) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in invoices) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < invoices.length; i++) {
        if (invoices[i].InvoiceId == null) {
          invoices[i].InvoiceId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns InvoiceId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInvoice.rawInsert(
          'INSERT OR REPLACE INTO Invoice (InvoiceId, InvoiceDate, BillingAddress, BillingCity, BillingState, BillingCountry, BillingPostalCode, Total, CustomerId)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            InvoiceId,
            InvoiceDate != null ? InvoiceDate!.millisecondsSinceEpoch : null,
            BillingAddress,
            BillingCity,
            BillingState,
            BillingCountry,
            BillingPostalCode,
            Total,
            CustomerId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Invoice InvoiceId=$InvoiceId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Invoice InvoiceId=$InvoiceId did not update');
      }
      return InvoiceId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Invoice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Invoice>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Invoice> invoices) async {
    final results = await _mnInvoice.rawInsertAll(
        'INSERT OR REPLACE INTO Invoice (InvoiceId, InvoiceDate, BillingAddress, BillingCity, BillingState, BillingCountry, BillingPostalCode, Total, CustomerId)  VALUES (?,?,?,?,?,?,?,?,?)',
        invoices);
    return results;
  }

  /// Deletes Invoice

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Invoice invoked (InvoiceId=$InvoiceId)');
    if (await InvoiceLine().select().InvoiceId.equals(InvoiceId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.InvoiceId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnInvoice.delete(
          QueryParams(whereString: 'InvoiceId=?', whereArguments: [InvoiceId]));
    } else {
      return _mnInvoice.updateBatch(
          QueryParams(whereString: 'InvoiceId=?', whereArguments: [InvoiceId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Invoice] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InvoiceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InvoiceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InvoiceId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion invoice

// region InvoiceField
class InvoiceField extends FilterBase {
  InvoiceField(InvoiceFilterBuilder invoiceFB) : super(invoiceFB);

  @override
  InvoiceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder isNull() {
    return super.isNull() as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InvoiceFilterBuilder;
  }

  @override
  InvoiceField get not {
    return super.not as InvoiceField;
  }
}
// endregion InvoiceField

// region InvoiceFilterBuilder
class InvoiceFilterBuilder extends ConjunctionBase {
  InvoiceFilterBuilder(Invoice obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInvoice = obj._mnInvoice;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InvoiceManager? _mnInvoice;

  /// put the sql keyword 'AND'
  @override
  InvoiceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InvoiceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InvoiceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InvoiceFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InvoiceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InvoiceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InvoiceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InvoiceField _setField(InvoiceField? field, String colName, DbType dbtype) {
    return InvoiceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InvoiceField? _InvoiceId;
  InvoiceField get InvoiceId {
    return _InvoiceId = _setField(_InvoiceId, 'InvoiceId', DbType.integer);
  }

  InvoiceField? _InvoiceDate;
  InvoiceField get InvoiceDate {
    return _InvoiceDate =
        _setField(_InvoiceDate, 'InvoiceDate', DbType.datetime);
  }

  InvoiceField? _BillingAddress;
  InvoiceField get BillingAddress {
    return _BillingAddress =
        _setField(_BillingAddress, 'BillingAddress', DbType.text);
  }

  InvoiceField? _BillingCity;
  InvoiceField get BillingCity {
    return _BillingCity = _setField(_BillingCity, 'BillingCity', DbType.text);
  }

  InvoiceField? _BillingState;
  InvoiceField get BillingState {
    return _BillingState =
        _setField(_BillingState, 'BillingState', DbType.text);
  }

  InvoiceField? _BillingCountry;
  InvoiceField get BillingCountry {
    return _BillingCountry =
        _setField(_BillingCountry, 'BillingCountry', DbType.text);
  }

  InvoiceField? _BillingPostalCode;
  InvoiceField get BillingPostalCode {
    return _BillingPostalCode =
        _setField(_BillingPostalCode, 'BillingPostalCode', DbType.text);
  }

  InvoiceField? _Total;
  InvoiceField get Total {
    return _Total = _setField(_Total, 'Total', DbType.real);
  }

  InvoiceField? _CustomerId;
  InvoiceField get CustomerId {
    return _CustomerId = _setField(_CustomerId, 'CustomerId', DbType.integer);
  }

  /// Deletes List<Invoice> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (InvoiceLine) according to DeleteRule.NO_ACTION

    final idListInvoiceLineBYInvoiceId = toListPrimaryKeySQL(false);
    final resInvoiceLineBYInvoiceId = await InvoiceLine()
        .select()
        .where('InvoiceId IN (${idListInvoiceLineBYInvoiceId['sql']})',
            parameterValue: idListInvoiceLineBYInvoiceId['args'])
        .toCount();
    if (resInvoiceLineBYInvoiceId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.InvoiceId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInvoice!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInvoice!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InvoiceId IN (SELECT InvoiceId from Invoice ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInvoice!.updateBatch(qparams, values);
  }

  /// This method always returns [Invoice] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Invoice?
  @override
  Future<Invoice?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInvoice!.toList(qparams);
    final data = await objFuture;
    Invoice? obj;
    if (data.isNotEmpty) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Invoice.plInvoiceLines'); */ obj
                  .plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          obj.plCustomer =
              obj.plCustomer ?? await obj.getCustomer(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Invoice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Invoice?
  @override
  Future<Invoice> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Invoice();
  }

  /// This method returns int. [Invoice]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? invoiceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicesFuture = await _mnInvoice!.toList(qparams);
    final int count = invoicesFuture[0]['CNT'] as int;
    if (invoiceCount != null) {
      invoiceCount(count);
    }
    return count;
  }

  /// This method returns List<Invoice> [Invoice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Invoice>
  @override
  Future<List<Invoice>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Invoice> invoicesData = await Invoice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return invoicesData;
  }

  /// This method returns Json String [Invoice]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Invoice]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Invoice]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInvoice!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Invoice>>
  Future<List<DropdownMenuItem<Invoice>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Invoice>> o)?
          dropDownMenu]) async {
    buildParameters();
    final invoicesFuture = _mnInvoice!.toList(qparams);

    final data = await invoicesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Invoice>> items = []..add(DropdownMenuItem(
        value: Invoice(),
        child: Text('Select Invoice'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Invoice.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['InvoiceId', displayTextColumn];
    final invoicesFuture = _mnInvoice!.toList(qparams);

    final data = await invoicesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Invoice'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['InvoiceId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Invoice]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InvoiceId` FROM Invoice WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> InvoiceIdData = <int>[];
    qparams.selectColumns = ['InvoiceId'];
    final InvoiceIdFuture = await _mnInvoice!.toList(qparams);

    final int count = InvoiceIdFuture.length;
    for (int i = 0; i < count; i++) {
      InvoiceIdData.add(InvoiceIdFuture[i]['InvoiceId'] as int);
    }
    return InvoiceIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Invoice]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInvoice!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Invoice.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInvoice!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceFilterBuilder

// region InvoiceFields
class InvoiceFields {
  static TableField? _fInvoiceId;
  static TableField get InvoiceId {
    return _fInvoiceId = _fInvoiceId ??
        SqlSyntax.setField(_fInvoiceId, 'invoiceid', DbType.integer);
  }

  static TableField? _fInvoiceDate;
  static TableField get InvoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'InvoiceDate', DbType.datetime);
  }

  static TableField? _fBillingAddress;
  static TableField get BillingAddress {
    return _fBillingAddress = _fBillingAddress ??
        SqlSyntax.setField(_fBillingAddress, 'BillingAddress', DbType.text);
  }

  static TableField? _fBillingCity;
  static TableField get BillingCity {
    return _fBillingCity = _fBillingCity ??
        SqlSyntax.setField(_fBillingCity, 'BillingCity', DbType.text);
  }

  static TableField? _fBillingState;
  static TableField get BillingState {
    return _fBillingState = _fBillingState ??
        SqlSyntax.setField(_fBillingState, 'BillingState', DbType.text);
  }

  static TableField? _fBillingCountry;
  static TableField get BillingCountry {
    return _fBillingCountry = _fBillingCountry ??
        SqlSyntax.setField(_fBillingCountry, 'BillingCountry', DbType.text);
  }

  static TableField? _fBillingPostalCode;
  static TableField get BillingPostalCode {
    return _fBillingPostalCode = _fBillingPostalCode ??
        SqlSyntax.setField(
            _fBillingPostalCode, 'BillingPostalCode', DbType.text);
  }

  static TableField? _fTotal;
  static TableField get Total {
    return _fTotal =
        _fTotal ?? SqlSyntax.setField(_fTotal, 'Total', DbType.real);
  }

  static TableField? _fCustomerId;
  static TableField get CustomerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'CustomerId', DbType.integer);
  }
}
// endregion InvoiceFields

//region InvoiceManager
class InvoiceManager extends SqfEntityProvider {
  InvoiceManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Invoice';
  static const List<String> _primaryKeyList = ['InvoiceId'];
  static const String _whereStr = 'InvoiceId=?';
}

//endregion InvoiceManager
// region InvoiceLine
class InvoiceLine extends TableBase {
  InvoiceLine(
      {this.InvoiceLineId,
      this.UnitPrice,
      this.Quantity,
      this.TrackId,
      this.InvoiceId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  InvoiceLine.withFields(
      this.UnitPrice, this.Quantity, this.TrackId, this.InvoiceId) {
    _setDefaultValues();
  }
  InvoiceLine.withId(this.InvoiceLineId, this.UnitPrice, this.Quantity,
      this.TrackId, this.InvoiceId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InvoiceLine.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InvoiceLineId = int.tryParse(o['InvoiceLineId'].toString());
    if (o['UnitPrice'] != null) {
      UnitPrice = double.tryParse(o['UnitPrice'].toString());
    }
    if (o['Quantity'] != null) {
      Quantity = int.tryParse(o['Quantity'].toString());
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    InvoiceId = int.tryParse(o['InvoiceId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    plInvoice = o['invoice'] != null
        ? Invoice.fromMap(o['invoice'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (InvoiceLine)
  int? InvoiceLineId;
  double? UnitPrice;
  int? Quantity;
  int? TrackId;
  int? InvoiceId;

  // end FIELDS (InvoiceLine)

// RELATIONSHIPS (InvoiceLine)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track? plTrack;

  /// get Track By TrackId
  Future<Track?> getTrack(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plInvoice', 'plField2'..]) or so on..
  Invoice? plInvoice;

  /// get Invoice By InvoiceId
  Future<Invoice?> getInvoice(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Invoice().getById(InvoiceId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (InvoiceLine)

  static const bool _softDeleteActivated = false;
  InvoiceLineManager? __mnInvoiceLine;

  InvoiceLineManager get _mnInvoiceLine {
    return __mnInvoiceLine = __mnInvoiceLine ?? InvoiceLineManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InvoiceLineId'] = InvoiceLineId;
    if (UnitPrice != null || !forView) {
      map['UnitPrice'] = UnitPrice;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }
    if (InvoiceId != null) {
      map['InvoiceId'] = forView
          ? plInvoice == null
              ? InvoiceId
              : plInvoice!.BillingAddress
          : InvoiceId;
    } else if (InvoiceId != null || !forView) {
      map['InvoiceId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InvoiceLineId'] = InvoiceLineId;
    if (UnitPrice != null || !forView) {
      map['UnitPrice'] = UnitPrice;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }
    if (InvoiceId != null) {
      map['InvoiceId'] = forView
          ? plInvoice == null
              ? InvoiceId
              : plInvoice!.BillingAddress
          : InvoiceId;
    } else if (InvoiceId != null || !forView) {
      map['InvoiceId'] = null;
    }

    return map;
  }

  /// This method returns Json String [InvoiceLine]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InvoiceLine]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [UnitPrice, Quantity, TrackId, InvoiceId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId];
  }

  static Future<List<InvoiceLine>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InvoiceLine.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InvoiceLine>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InvoiceLine>[];
    try {
      objList = list
          .map((invoiceline) =>
              InvoiceLine.fromMap(invoiceline as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InvoiceLine.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InvoiceLine>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InvoiceLine> objList = <InvoiceLine>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InvoiceLine.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          obj.plInvoice =
              obj.plInvoice ?? await obj.getInvoice(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns InvoiceLine by ID if exist, otherwise returns null
  /// Primary Keys: int? InvoiceLineId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [InvoiceLine] if exist, otherwise returns null
  Future<InvoiceLine?> getById(int? InvoiceLineId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InvoiceLineId == null) {
      return null;
    }
    InvoiceLine? obj;
    final data = await _mnInvoiceLine.getById([InvoiceLineId]);
    if (data.length != 0) {
      obj = InvoiceLine.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          obj.plInvoice =
              obj.plInvoice ?? await obj.getInvoice(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InvoiceLine) object. If the InvoiceLineId field is null, saves as a new record and returns new InvoiceLineId, if InvoiceLineId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns InvoiceLineId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (InvoiceLineId == null || InvoiceLineId == 0) {
      InvoiceLineId = await _mnInvoiceLine.insert(this, ignoreBatch);
    } else {
      await _mnInvoiceLine.update(this);
    }

    return InvoiceLineId;
  }

  /// Saves the (InvoiceLine) object. If the InvoiceLineId field is null, saves as a new record and returns new InvoiceLineId, if InvoiceLineId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns InvoiceLineId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (InvoiceLineId == null || InvoiceLineId == 0) {
      InvoiceLineId = await _mnInvoiceLine.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // InvoiceLineId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoiceLine.updateOrThrow(this);
    }

    return InvoiceLineId;
  }

  /// saveAs InvoiceLine. Returns a new Primary Key value of InvoiceLine

  /// <returns>Returns a new Primary Key value of InvoiceLine
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    InvoiceLineId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<InvoiceLine> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<InvoiceLine> invoicelines) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in invoicelines) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < invoicelines.length; i++) {
        if (invoicelines[i].InvoiceLineId == null) {
          invoicelines[i].InvoiceLineId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns InvoiceLineId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInvoiceLine.rawInsert(
          'INSERT OR REPLACE INTO InvoiceLine (InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId)  VALUES (?,?,?,?,?)',
          [InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InvoiceLine InvoiceLineId=$InvoiceLineId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InvoiceLine InvoiceLineId=$InvoiceLineId did not update');
      }
      return InvoiceLineId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'InvoiceLine Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<InvoiceLine>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<InvoiceLine> invoicelines) async {
    final results = await _mnInvoiceLine.rawInsertAll(
        'INSERT OR REPLACE INTO InvoiceLine (InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId)  VALUES (?,?,?,?,?)',
        invoicelines);
    return results;
  }

  /// Deletes InvoiceLine

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete InvoiceLine invoked (InvoiceLineId=$InvoiceLineId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInvoiceLine.delete(QueryParams(
          whereString: 'InvoiceLineId=?', whereArguments: [InvoiceLineId]));
    } else {
      return _mnInvoiceLine.updateBatch(
          QueryParams(
              whereString: 'InvoiceLineId=?', whereArguments: [InvoiceLineId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [InvoiceLine] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InvoiceLineFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceLineFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InvoiceLineFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InvoiceLineFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InvoiceLineId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion invoiceline

// region InvoiceLineField
class InvoiceLineField extends FilterBase {
  InvoiceLineField(InvoiceLineFilterBuilder invoicelineFB)
      : super(invoicelineFB);

  @override
  InvoiceLineFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder isNull() {
    return super.isNull() as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InvoiceLineFilterBuilder;
  }

  @override
  InvoiceLineField get not {
    return super.not as InvoiceLineField;
  }
}
// endregion InvoiceLineField

// region InvoiceLineFilterBuilder
class InvoiceLineFilterBuilder extends ConjunctionBase {
  InvoiceLineFilterBuilder(InvoiceLine obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInvoiceLine = obj._mnInvoiceLine;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InvoiceLineManager? _mnInvoiceLine;

  /// put the sql keyword 'AND'
  @override
  InvoiceLineFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InvoiceLineFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InvoiceLineFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InvoiceLineFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InvoiceLineFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InvoiceLineFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InvoiceLineFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceLineFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceLineFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InvoiceLineFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InvoiceLineFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InvoiceLineField _setField(
      InvoiceLineField? field, String colName, DbType dbtype) {
    return InvoiceLineField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InvoiceLineField? _InvoiceLineId;
  InvoiceLineField get InvoiceLineId {
    return _InvoiceLineId =
        _setField(_InvoiceLineId, 'InvoiceLineId', DbType.integer);
  }

  InvoiceLineField? _UnitPrice;
  InvoiceLineField get UnitPrice {
    return _UnitPrice = _setField(_UnitPrice, 'UnitPrice', DbType.real);
  }

  InvoiceLineField? _Quantity;
  InvoiceLineField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.integer);
  }

  InvoiceLineField? _TrackId;
  InvoiceLineField get TrackId {
    return _TrackId = _setField(_TrackId, 'TrackId', DbType.integer);
  }

  InvoiceLineField? _InvoiceId;
  InvoiceLineField get InvoiceId {
    return _InvoiceId = _setField(_InvoiceId, 'InvoiceId', DbType.integer);
  }

  /// Deletes List<InvoiceLine> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInvoiceLine!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInvoiceLine!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InvoiceLineId IN (SELECT InvoiceLineId from InvoiceLine ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInvoiceLine!.updateBatch(qparams, values);
  }

  /// This method always returns [InvoiceLine] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InvoiceLine?
  @override
  Future<InvoiceLine?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInvoiceLine!.toList(qparams);
    final data = await objFuture;
    InvoiceLine? obj;
    if (data.isNotEmpty) {
      obj = InvoiceLine.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          obj.plInvoice =
              obj.plInvoice ?? await obj.getInvoice(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [InvoiceLine]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InvoiceLine?
  @override
  Future<InvoiceLine> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        InvoiceLine();
  }

  /// This method returns int. [InvoiceLine]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? invoicelineCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicelinesFuture = await _mnInvoiceLine!.toList(qparams);
    final int count = invoicelinesFuture[0]['CNT'] as int;
    if (invoicelineCount != null) {
      invoicelineCount(count);
    }
    return count;
  }

  /// This method returns List<InvoiceLine> [InvoiceLine]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<InvoiceLine>
  @override
  Future<List<InvoiceLine>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InvoiceLine> invoicelinesData = await InvoiceLine.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return invoicelinesData;
  }

  /// This method returns Json String [InvoiceLine]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InvoiceLine]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InvoiceLine]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInvoiceLine!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<InvoiceLine>>
  Future<List<DropdownMenuItem<InvoiceLine>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<InvoiceLine>> o)?
          dropDownMenu]) async {
    buildParameters();
    final invoicelinesFuture = _mnInvoiceLine!.toList(qparams);

    final data = await invoicelinesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<InvoiceLine>> items = []..add(DropdownMenuItem(
        value: InvoiceLine(),
        child: Text('Select InvoiceLine'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: InvoiceLine.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['InvoiceLineId', displayTextColumn];
    final invoicelinesFuture = _mnInvoiceLine!.toList(qparams);

    final data = await invoicelinesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select InvoiceLine'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['InvoiceLineId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InvoiceLine]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InvoiceLineId` FROM InvoiceLine WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> InvoiceLineIdData = <int>[];
    qparams.selectColumns = ['InvoiceLineId'];
    final InvoiceLineIdFuture = await _mnInvoiceLine!.toList(qparams);

    final int count = InvoiceLineIdFuture.length;
    for (int i = 0; i < count; i++) {
      InvoiceLineIdData.add(InvoiceLineIdFuture[i]['InvoiceLineId'] as int);
    }
    return InvoiceLineIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InvoiceLine]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInvoiceLine!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await InvoiceLine.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInvoiceLine!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceLineFilterBuilder

// region InvoiceLineFields
class InvoiceLineFields {
  static TableField? _fInvoiceLineId;
  static TableField get InvoiceLineId {
    return _fInvoiceLineId = _fInvoiceLineId ??
        SqlSyntax.setField(_fInvoiceLineId, 'invoicelineid', DbType.integer);
  }

  static TableField? _fUnitPrice;
  static TableField get UnitPrice {
    return _fUnitPrice = _fUnitPrice ??
        SqlSyntax.setField(_fUnitPrice, 'UnitPrice', DbType.real);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'Quantity', DbType.integer);
  }

  static TableField? _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }

  static TableField? _fInvoiceId;
  static TableField get InvoiceId {
    return _fInvoiceId = _fInvoiceId ??
        SqlSyntax.setField(_fInvoiceId, 'InvoiceId', DbType.integer);
  }
}
// endregion InvoiceLineFields

//region InvoiceLineManager
class InvoiceLineManager extends SqfEntityProvider {
  InvoiceLineManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'InvoiceLine';
  static const List<String> _primaryKeyList = ['InvoiceLineId'];
  static const String _whereStr = 'InvoiceLineId=?';
}

//endregion InvoiceLineManager
// region MediaType
class MediaType extends TableBase {
  MediaType({this.MediaTypeId, this.Name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  MediaType.withFields(this.Name) {
    _setDefaultValues();
  }
  MediaType.withId(this.MediaTypeId, this.Name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  MediaType.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    MediaTypeId = int.tryParse(o['MediaTypeId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
  }
  // FIELDS (MediaType)
  int? MediaTypeId;
  String? Name;

  // end FIELDS (MediaType)

// COLLECTIONS & VIRTUALS (MediaType)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track>? plTracks;

  /// get Track(s) filtered by MediaTypeId=MediaTypeId
  TrackFilterBuilder? getTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (MediaTypeId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .MediaTypeId
        .equals(MediaTypeId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (MediaType)

  static const bool _softDeleteActivated = false;
  MediaTypeManager? __mnMediaType;

  MediaTypeManager get _mnMediaType {
    return __mnMediaType = __mnMediaType ?? MediaTypeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['MediaTypeId'] = MediaTypeId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['MediaTypeId'] = MediaTypeId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

// COLLECTIONS (MediaType)
    if (!forQuery) {
      map['Tracks'] = await getTracks()!.toMapList();
    }
// END COLLECTIONS (MediaType)

    return map;
  }

  /// This method returns Json String [MediaType]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [MediaType]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [MediaTypeId, Name];
  }

  static Future<List<MediaType>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR MediaType.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<MediaType>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <MediaType>[];
    try {
      objList = list
          .map((mediatype) =>
              MediaType.fromMap(mediatype as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR MediaType.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<MediaType>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<MediaType> objList = <MediaType>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = MediaType.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('MediaType.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns MediaType by ID if exist, otherwise returns null
  /// Primary Keys: int? MediaTypeId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [MediaType] if exist, otherwise returns null
  Future<MediaType?> getById(int? MediaTypeId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (MediaTypeId == null) {
      return null;
    }
    MediaType? obj;
    final data = await _mnMediaType.getById([MediaTypeId]);
    if (data.length != 0) {
      obj = MediaType.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('MediaType.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (MediaType) object. If the MediaTypeId field is null, saves as a new record and returns new MediaTypeId, if MediaTypeId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns MediaTypeId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (MediaTypeId == null || MediaTypeId == 0) {
      MediaTypeId = await _mnMediaType.insert(this, ignoreBatch);
    } else {
      await _mnMediaType.update(this);
    }

    return MediaTypeId;
  }

  /// Saves the (MediaType) object. If the MediaTypeId field is null, saves as a new record and returns new MediaTypeId, if MediaTypeId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns MediaTypeId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (MediaTypeId == null || MediaTypeId == 0) {
      MediaTypeId = await _mnMediaType.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // MediaTypeId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnMediaType.updateOrThrow(this);
    }

    return MediaTypeId;
  }

  /// saveAs MediaType. Returns a new Primary Key value of MediaType

  /// <returns>Returns a new Primary Key value of MediaType
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    MediaTypeId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<MediaType> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<MediaType> mediatypes) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in mediatypes) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < mediatypes.length; i++) {
        if (mediatypes[i].MediaTypeId == null) {
          mediatypes[i].MediaTypeId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns MediaTypeId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnMediaType.rawInsert(
          'INSERT OR REPLACE INTO MediaType (MediaTypeId, Name)  VALUES (?,?)',
          [MediaTypeId, Name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'MediaType MediaTypeId=$MediaTypeId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'MediaType MediaTypeId=$MediaTypeId did not update');
      }
      return MediaTypeId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'MediaType Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<MediaType>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<MediaType> mediatypes) async {
    final results = await _mnMediaType.rawInsertAll(
        'INSERT OR REPLACE INTO MediaType (MediaTypeId, Name)  VALUES (?,?)',
        mediatypes);
    return results;
  }

  /// Deletes MediaType

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete MediaType invoked (MediaTypeId=$MediaTypeId)');
    if (await Track().select().MediaTypeId.equals(MediaTypeId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.MediaTypeId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnMediaType.delete(QueryParams(
          whereString: 'MediaTypeId=?', whereArguments: [MediaTypeId]));
    } else {
      return _mnMediaType.updateBatch(
          QueryParams(
              whereString: 'MediaTypeId=?', whereArguments: [MediaTypeId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [MediaType] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  MediaTypeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return MediaTypeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  MediaTypeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return MediaTypeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      MediaTypeId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion mediatype

// region MediaTypeField
class MediaTypeField extends FilterBase {
  MediaTypeField(MediaTypeFilterBuilder mediatypeFB) : super(mediatypeFB);

  @override
  MediaTypeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder isNull() {
    return super.isNull() as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as MediaTypeFilterBuilder;
  }

  @override
  MediaTypeField get not {
    return super.not as MediaTypeField;
  }
}
// endregion MediaTypeField

// region MediaTypeFilterBuilder
class MediaTypeFilterBuilder extends ConjunctionBase {
  MediaTypeFilterBuilder(MediaType obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnMediaType = obj._mnMediaType;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  MediaTypeManager? _mnMediaType;

  /// put the sql keyword 'AND'
  @override
  MediaTypeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  MediaTypeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  MediaTypeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  MediaTypeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  MediaTypeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  MediaTypeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  MediaTypeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  MediaTypeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  MediaTypeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  MediaTypeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  MediaTypeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  MediaTypeField _setField(
      MediaTypeField? field, String colName, DbType dbtype) {
    return MediaTypeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  MediaTypeField? _MediaTypeId;
  MediaTypeField get MediaTypeId {
    return _MediaTypeId =
        _setField(_MediaTypeId, 'MediaTypeId', DbType.integer);
  }

  MediaTypeField? _Name;
  MediaTypeField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  /// Deletes List<MediaType> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYMediaTypeId = toListPrimaryKeySQL(false);
    final resTrackBYMediaTypeId = await Track()
        .select()
        .where('MediaTypeId IN (${idListTrackBYMediaTypeId['sql']})',
            parameterValue: idListTrackBYMediaTypeId['args'])
        .toCount();
    if (resTrackBYMediaTypeId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.MediaTypeId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnMediaType!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnMediaType!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'MediaTypeId IN (SELECT MediaTypeId from MediaType ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnMediaType!.updateBatch(qparams, values);
  }

  /// This method always returns [MediaType] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> MediaType?
  @override
  Future<MediaType?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnMediaType!.toList(qparams);
    final data = await objFuture;
    MediaType? obj;
    if (data.isNotEmpty) {
      obj = MediaType.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('MediaType.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [MediaType]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> MediaType?
  @override
  Future<MediaType> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        MediaType();
  }

  /// This method returns int. [MediaType]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? mediatypeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final mediatypesFuture = await _mnMediaType!.toList(qparams);
    final int count = mediatypesFuture[0]['CNT'] as int;
    if (mediatypeCount != null) {
      mediatypeCount(count);
    }
    return count;
  }

  /// This method returns List<MediaType> [MediaType]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<MediaType>
  @override
  Future<List<MediaType>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<MediaType> mediatypesData = await MediaType.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return mediatypesData;
  }

  /// This method returns Json String [MediaType]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [MediaType]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [MediaType]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnMediaType!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<MediaType>>
  Future<List<DropdownMenuItem<MediaType>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<MediaType>> o)?
          dropDownMenu]) async {
    buildParameters();
    final mediatypesFuture = _mnMediaType!.toList(qparams);

    final data = await mediatypesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<MediaType>> items = []..add(DropdownMenuItem(
        value: MediaType(),
        child: Text('Select MediaType'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: MediaType.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['MediaTypeId', displayTextColumn];
    final mediatypesFuture = _mnMediaType!.toList(qparams);

    final data = await mediatypesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select MediaType'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['MediaTypeId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [MediaType]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `MediaTypeId` FROM MediaType WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> MediaTypeIdData = <int>[];
    qparams.selectColumns = ['MediaTypeId'];
    final MediaTypeIdFuture = await _mnMediaType!.toList(qparams);

    final int count = MediaTypeIdFuture.length;
    for (int i = 0; i < count; i++) {
      MediaTypeIdData.add(MediaTypeIdFuture[i]['MediaTypeId'] as int);
    }
    return MediaTypeIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [MediaType]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnMediaType!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await MediaType.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnMediaType!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion MediaTypeFilterBuilder

// region MediaTypeFields
class MediaTypeFields {
  static TableField? _fMediaTypeId;
  static TableField get MediaTypeId {
    return _fMediaTypeId = _fMediaTypeId ??
        SqlSyntax.setField(_fMediaTypeId, 'mediatypeid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion MediaTypeFields

//region MediaTypeManager
class MediaTypeManager extends SqfEntityProvider {
  MediaTypeManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'MediaType';
  static const List<String> _primaryKeyList = ['MediaTypeId'];
  static const String _whereStr = 'MediaTypeId=?';
}

//endregion MediaTypeManager
// region Playlist
class Playlist extends TableBase {
  Playlist({this.PlaylistId, this.Name}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Playlist.withFields(this.Name) {
    _setDefaultValues();
  }
  Playlist.withId(this.PlaylistId, this.Name) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Playlist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    PlaylistId = int.tryParse(o['PlaylistId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
  }
  // FIELDS (Playlist)
  int? PlaylistId;
  String? Name;

  // end FIELDS (Playlist)

// COLLECTIONS & VIRTUALS (Playlist)
  ///(RelationType.MANY_TO_MANY) (PlaylistTrack) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track>? plTracks;

  /// get Track(s) filtered by TrackId IN PlaylistTrack
  TrackFilterBuilder? getTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'PlaylistId IN (SELECT TrackId FROM PlaylistTrack WHERE PlaylistId=?)',
            parameterValue: PlaylistId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Playlist)

  static const bool _softDeleteActivated = false;
  PlaylistManager? __mnPlaylist;

  PlaylistManager get _mnPlaylist {
    return __mnPlaylist = __mnPlaylist ?? PlaylistManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['PlaylistId'] = PlaylistId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['PlaylistId'] = PlaylistId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }

// COLLECTIONS (Playlist)
    if (!forQuery) {
      map['Tracks'] = await getTracks()!.toMapList();
    }
// END COLLECTIONS (Playlist)

    return map;
  }

  /// This method returns Json String [Playlist]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Playlist]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Name];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [PlaylistId, Name];
  }

  static Future<List<Playlist>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Playlist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Playlist>[];
    try {
      objList = list
          .map((playlist) => Playlist.fromMap(playlist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Playlist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Playlist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Playlist> objList = <Playlist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Playlist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Playlist.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Playlist by ID if exist, otherwise returns null
  /// Primary Keys: int? PlaylistId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Playlist] if exist, otherwise returns null
  Future<Playlist?> getById(int? PlaylistId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (PlaylistId == null) {
      return null;
    }
    Playlist? obj;
    final data = await _mnPlaylist.getById([PlaylistId]);
    if (data.length != 0) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Playlist.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Playlist) object. If the PlaylistId field is null, saves as a new record and returns new PlaylistId, if PlaylistId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns PlaylistId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (PlaylistId == null || PlaylistId == 0) {
      PlaylistId = await _mnPlaylist.insert(this, ignoreBatch);
    } else {
      await _mnPlaylist.update(this);
    }

    return PlaylistId;
  }

  /// Saves the (Playlist) object. If the PlaylistId field is null, saves as a new record and returns new PlaylistId, if PlaylistId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns PlaylistId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (PlaylistId == null || PlaylistId == 0) {
      PlaylistId = await _mnPlaylist.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // PlaylistId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylist.updateOrThrow(this);
    }

    return PlaylistId;
  }

  /// saveAs Playlist. Returns a new Primary Key value of Playlist

  /// <returns>Returns a new Primary Key value of Playlist
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    PlaylistId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Playlist> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Playlist> playlists) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in playlists) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < playlists.length; i++) {
        if (playlists[i].PlaylistId == null) {
          playlists[i].PlaylistId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns PlaylistId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPlaylist.rawInsert(
          'INSERT OR REPLACE INTO Playlist (PlaylistId, Name)  VALUES (?,?)',
          [PlaylistId, Name],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Playlist PlaylistId=$PlaylistId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Playlist PlaylistId=$PlaylistId did not update');
      }
      return PlaylistId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Playlist Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Playlist>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Playlist> playlists) async {
    final results = await _mnPlaylist.rawInsertAll(
        'INSERT OR REPLACE INTO Playlist (PlaylistId, Name)  VALUES (?,?)',
        playlists);
    return results;
  }

  /// Deletes Playlist

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Playlist invoked (PlaylistId=$PlaylistId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylist.delete(QueryParams(
          whereString: 'PlaylistId=?', whereArguments: [PlaylistId]));
    } else {
      return _mnPlaylist.updateBatch(
          QueryParams(
              whereString: 'PlaylistId=?', whereArguments: [PlaylistId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Playlist] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PlaylistFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PlaylistFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      PlaylistId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlist

// region PlaylistField
class PlaylistField extends FilterBase {
  PlaylistField(PlaylistFilterBuilder playlistFB) : super(playlistFB);

  @override
  PlaylistFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder isNull() {
    return super.isNull() as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PlaylistFilterBuilder;
  }

  @override
  PlaylistField get not {
    return super.not as PlaylistField;
  }
}
// endregion PlaylistField

// region PlaylistFilterBuilder
class PlaylistFilterBuilder extends ConjunctionBase {
  PlaylistFilterBuilder(Playlist obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPlaylist = obj._mnPlaylist;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PlaylistManager? _mnPlaylist;

  /// put the sql keyword 'AND'
  @override
  PlaylistFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PlaylistFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PlaylistFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PlaylistFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PlaylistFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PlaylistFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PlaylistFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PlaylistField _setField(PlaylistField? field, String colName, DbType dbtype) {
    return PlaylistField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PlaylistField? _PlaylistId;
  PlaylistField get PlaylistId {
    return _PlaylistId = _setField(_PlaylistId, 'PlaylistId', DbType.integer);
  }

  PlaylistField? _Name;
  PlaylistField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  /// Deletes List<Playlist> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPlaylist!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPlaylist!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'PlaylistId IN (SELECT PlaylistId from Playlist ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPlaylist!.updateBatch(qparams, values);
  }

  /// This method always returns [Playlist] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Playlist?
  @override
  Future<Playlist?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPlaylist!.toList(qparams);
    final data = await objFuture;
    Playlist? obj;
    if (data.isNotEmpty) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedfields!.add('Playlist.plTracks'); */ obj.plTracks =
              obj.plTracks ??
                  await obj.getTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Playlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Playlist?
  @override
  Future<Playlist> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Playlist();
  }

  /// This method returns int. [Playlist]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? playlistCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistsFuture = await _mnPlaylist!.toList(qparams);
    final int count = playlistsFuture[0]['CNT'] as int;
    if (playlistCount != null) {
      playlistCount(count);
    }
    return count;
  }

  /// This method returns List<Playlist> [Playlist]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Playlist>
  @override
  Future<List<Playlist>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Playlist> playlistsData = await Playlist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return playlistsData;
  }

  /// This method returns Json String [Playlist]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Playlist]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Playlist]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPlaylist!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Playlist>>
  Future<List<DropdownMenuItem<Playlist>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Playlist>> o)?
          dropDownMenu]) async {
    buildParameters();
    final playlistsFuture = _mnPlaylist!.toList(qparams);

    final data = await playlistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Playlist>> items = []..add(DropdownMenuItem(
        value: Playlist(),
        child: Text('Select Playlist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Playlist.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['PlaylistId', displayTextColumn];
    final playlistsFuture = _mnPlaylist!.toList(qparams);

    final data = await playlistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Playlist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['PlaylistId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Playlist]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `PlaylistId` FROM Playlist WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> PlaylistIdData = <int>[];
    qparams.selectColumns = ['PlaylistId'];
    final PlaylistIdFuture = await _mnPlaylist!.toList(qparams);

    final int count = PlaylistIdFuture.length;
    for (int i = 0; i < count; i++) {
      PlaylistIdData.add(PlaylistIdFuture[i]['PlaylistId'] as int);
    }
    return PlaylistIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Playlist]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPlaylist!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Playlist.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPlaylist!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistFilterBuilder

// region PlaylistFields
class PlaylistFields {
  static TableField? _fPlaylistId;
  static TableField get PlaylistId {
    return _fPlaylistId = _fPlaylistId ??
        SqlSyntax.setField(_fPlaylistId, 'playlistid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion PlaylistFields

//region PlaylistManager
class PlaylistManager extends SqfEntityProvider {
  PlaylistManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Playlist';
  static const List<String> _primaryKeyList = ['PlaylistId'];
  static const String _whereStr = 'PlaylistId=?';
}

//endregion PlaylistManager
// region Track
class Track extends TableBase {
  Track(
      {this.TrackId,
      this.Name,
      this.Composer,
      this.Milliseconds,
      this.Bytes,
      this.UnitPrice,
      this.MediaTypeId,
      this.GenreId,
      this.AlbumId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Track.withFields(this.Name, this.Composer, this.Milliseconds, this.Bytes,
      this.UnitPrice, this.MediaTypeId, this.GenreId, this.AlbumId) {
    _setDefaultValues();
  }
  Track.withId(
      this.TrackId,
      this.Name,
      this.Composer,
      this.Milliseconds,
      this.Bytes,
      this.UnitPrice,
      this.MediaTypeId,
      this.GenreId,
      this.AlbumId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Track.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TrackId = int.tryParse(o['TrackId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
    if (o['Composer'] != null) {
      Composer = o['Composer'].toString();
    }
    if (o['Milliseconds'] != null) {
      Milliseconds = int.tryParse(o['Milliseconds'].toString());
    }
    if (o['Bytes'] != null) {
      Bytes = int.tryParse(o['Bytes'].toString());
    }
    if (o['UnitPrice'] != null) {
      UnitPrice = double.tryParse(o['UnitPrice'].toString());
    }
    MediaTypeId = int.tryParse(o['MediaTypeId'].toString());

    GenreId = int.tryParse(o['GenreId'].toString());

    AlbumId = int.tryParse(o['AlbumId'].toString());

    // RELATIONSHIPS FromMAP
    plMediaType = o['mediaType'] != null
        ? MediaType.fromMap(o['mediaType'] as Map<String, dynamic>)
        : null;
    plGenre = o['genre'] != null
        ? Genre.fromMap(o['genre'] as Map<String, dynamic>)
        : null;
    plAlbum = o['album'] != null
        ? Album.fromMap(o['album'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (Track)
  int? TrackId;
  String? Name;
  String? Composer;
  int? Milliseconds;
  int? Bytes;
  double? UnitPrice;
  int? MediaTypeId;
  int? GenreId;
  int? AlbumId;

  // end FIELDS (Track)

// RELATIONSHIPS (Track)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plMediaType', 'plField2'..]) or so on..
  MediaType? plMediaType;

  /// get MediaType By MediaTypeId
  Future<MediaType?> getMediaType(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await MediaType().getById(MediaTypeId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plGenre', 'plField2'..]) or so on..
  Genre? plGenre;

  /// get Genre By GenreId
  Future<Genre?> getGenre(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Genre()
        .getById(GenreId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plAlbum', 'plField2'..]) or so on..
  Album? plAlbum;

  /// get Album By AlbumId
  Future<Album?> getAlbum(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Album()
        .getById(AlbumId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Track)

// COLLECTIONS & VIRTUALS (Track)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plInvoiceLines', 'plField2'..]) or so on..
  List<InvoiceLine>? plInvoiceLines;

  /// get InvoiceLine(s) filtered by TrackId=TrackId
  InvoiceLineFilterBuilder? getInvoiceLines(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (TrackId == null) {
      return null;
    }
    return InvoiceLine()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .TrackId
        .equals(TrackId)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (PlaylistTrack) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylists', 'plField2'..]) or so on..
  List<Playlist>? plPlaylists;

  /// get Playlist(s) filtered by PlaylistId IN PlaylistTrack
  PlaylistFilterBuilder? getPlaylists(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Playlist()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'TrackId IN (SELECT PlaylistId FROM PlaylistTrack WHERE TrackId=?)',
            parameterValue: TrackId)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plVTracks', 'plField2'..]) or so on..
  List<VTrack>? plVTracks;

  /// get VTrack(s) filtered by TrackId=TrackId
  VTrackFilterBuilder? getVTracks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (TrackId == null) {
      return null;
    }
    return VTrack()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .TrackId
        .equals(TrackId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Track)

  static const bool _softDeleteActivated = false;
  TrackManager? __mnTrack;

  TrackManager get _mnTrack {
    return __mnTrack = __mnTrack ?? TrackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['TrackId'] = TrackId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (Composer != null || !forView) {
      map['Composer'] = Composer;
    }
    if (Milliseconds != null || !forView) {
      map['Milliseconds'] = Milliseconds;
    }
    if (Bytes != null || !forView) {
      map['Bytes'] = Bytes;
    }
    if (UnitPrice != null || !forView) {
      map['UnitPrice'] = UnitPrice;
    }
    if (MediaTypeId != null) {
      map['MediaTypeId'] = forView
          ? plMediaType == null
              ? MediaTypeId
              : plMediaType!.Name
          : MediaTypeId;
    } else if (MediaTypeId != null || !forView) {
      map['MediaTypeId'] = null;
    }
    if (GenreId != null) {
      map['GenreId'] = forView
          ? plGenre == null
              ? GenreId
              : plGenre!.Name
          : GenreId;
    } else if (GenreId != null || !forView) {
      map['GenreId'] = null;
    }
    if (AlbumId != null) {
      map['AlbumId'] = forView
          ? plAlbum == null
              ? AlbumId
              : plAlbum!.Title
          : AlbumId;
    } else if (AlbumId != null || !forView) {
      map['AlbumId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['TrackId'] = TrackId;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (Composer != null || !forView) {
      map['Composer'] = Composer;
    }
    if (Milliseconds != null || !forView) {
      map['Milliseconds'] = Milliseconds;
    }
    if (Bytes != null || !forView) {
      map['Bytes'] = Bytes;
    }
    if (UnitPrice != null || !forView) {
      map['UnitPrice'] = UnitPrice;
    }
    if (MediaTypeId != null) {
      map['MediaTypeId'] = forView
          ? plMediaType == null
              ? MediaTypeId
              : plMediaType!.Name
          : MediaTypeId;
    } else if (MediaTypeId != null || !forView) {
      map['MediaTypeId'] = null;
    }
    if (GenreId != null) {
      map['GenreId'] = forView
          ? plGenre == null
              ? GenreId
              : plGenre!.Name
          : GenreId;
    } else if (GenreId != null || !forView) {
      map['GenreId'] = null;
    }
    if (AlbumId != null) {
      map['AlbumId'] = forView
          ? plAlbum == null
              ? AlbumId
              : plAlbum!.Title
          : AlbumId;
    } else if (AlbumId != null || !forView) {
      map['AlbumId'] = null;
    }

// COLLECTIONS (Track)
    if (!forQuery) {
      map['InvoiceLines'] = await getInvoiceLines()!.toMapList();
    }
    if (!forQuery) {
      map['Playlists'] = await getPlaylists()!.toMapList();
    }
    if (!forQuery) {
      map['VTracks'] = await getVTracks()!.toMapList();
    }
// END COLLECTIONS (Track)

    return map;
  }

  /// This method returns Json String [Track]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Track]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Name,
      Composer,
      Milliseconds,
      Bytes,
      UnitPrice,
      MediaTypeId,
      GenreId,
      AlbumId
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      TrackId,
      Name,
      Composer,
      Milliseconds,
      Bytes,
      UnitPrice,
      MediaTypeId,
      GenreId,
      AlbumId
    ];
  }

  static Future<List<Track>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Track.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Track>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Track>[];
    try {
      objList = list
          .map((track) => Track.fromMap(track as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Track.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Track>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Track> objList = <Track>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Track.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Track.plInvoiceLines'); */ obj.plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedfields!.add('Track.plPlaylists'); */ obj.plPlaylists =
              obj.plPlaylists ??
                  await obj.getPlaylists()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedfields!.add('Track.plVTracks'); */ obj.plVTracks =
              obj.plVTracks ??
                  await obj.getVTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          obj.plGenre =
              obj.plGenre ?? await obj.getGenre(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          obj.plAlbum =
              obj.plAlbum ?? await obj.getAlbum(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Track by ID if exist, otherwise returns null
  /// Primary Keys: int? TrackId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Track] if exist, otherwise returns null
  Future<Track?> getById(int? TrackId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (TrackId == null) {
      return null;
    }
    Track? obj;
    final data = await _mnTrack.getById([TrackId]);
    if (data.length != 0) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Track.plInvoiceLines'); */ obj.plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedfields!.add('Track.plPlaylists'); */ obj.plPlaylists =
              obj.plPlaylists ??
                  await obj.getPlaylists()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedfields!.add('Track.plVTracks'); */ obj.plVTracks =
              obj.plVTracks ??
                  await obj.getVTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          obj.plGenre =
              obj.plGenre ?? await obj.getGenre(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          obj.plAlbum =
              obj.plAlbum ?? await obj.getAlbum(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Track) object. If the TrackId field is null, saves as a new record and returns new TrackId, if TrackId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns TrackId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (TrackId == null || TrackId == 0) {
      TrackId = await _mnTrack.insert(this, ignoreBatch);
    } else {
      await _mnTrack.update(this);
    }

    return TrackId;
  }

  /// Saves the (Track) object. If the TrackId field is null, saves as a new record and returns new TrackId, if TrackId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns TrackId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (TrackId == null || TrackId == 0) {
      TrackId = await _mnTrack.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // TrackId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTrack.updateOrThrow(this);
    }

    return TrackId;
  }

  /// saveAs Track. Returns a new Primary Key value of Track

  /// <returns>Returns a new Primary Key value of Track
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    TrackId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Track> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Track> tracks) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in tracks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
      for (int i = 0; i < tracks.length; i++) {
        if (tracks[i].TrackId == null) {
          tracks[i].TrackId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns TrackId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTrack.rawInsert(
          'INSERT OR REPLACE INTO Track (TrackId, Name, Composer, Milliseconds, Bytes, UnitPrice, MediaTypeId, GenreId, AlbumId)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            TrackId,
            Name,
            Composer,
            Milliseconds,
            Bytes,
            UnitPrice,
            MediaTypeId,
            GenreId,
            AlbumId
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Track TrackId=$TrackId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Track TrackId=$TrackId did not update');
      }
      return TrackId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Track Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Track>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Track> tracks) async {
    final results = await _mnTrack.rawInsertAll(
        'INSERT OR REPLACE INTO Track (TrackId, Name, Composer, Milliseconds, Bytes, UnitPrice, MediaTypeId, GenreId, AlbumId)  VALUES (?,?,?,?,?,?,?,?,?)',
        tracks);
    return results;
  }

  /// Deletes Track

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Track invoked (TrackId=$TrackId)');
    if (await InvoiceLine().select().TrackId.equals(TrackId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.TrackId)');
    }
    if (await VTrack().select().TrackId.equals(TrackId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VTrack.TrackId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnTrack.delete(
          QueryParams(whereString: 'TrackId=?', whereArguments: [TrackId]));
    } else {
      return _mnTrack.updateBatch(
          QueryParams(whereString: 'TrackId=?', whereArguments: [TrackId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Track] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TrackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TrackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      TrackId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion track

// region TrackField
class TrackField extends FilterBase {
  TrackField(TrackFilterBuilder trackFB) : super(trackFB);

  @override
  TrackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder isNull() {
    return super.isNull() as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TrackFilterBuilder;
  }

  @override
  TrackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TrackFilterBuilder;
  }

  @override
  TrackField get not {
    return super.not as TrackField;
  }
}
// endregion TrackField

// region TrackFilterBuilder
class TrackFilterBuilder extends ConjunctionBase {
  TrackFilterBuilder(Track obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnTrack = obj._mnTrack;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TrackManager? _mnTrack;

  /// put the sql keyword 'AND'
  @override
  TrackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TrackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TrackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TrackFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TrackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TrackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TrackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TrackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TrackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TrackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TrackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TrackField _setField(TrackField? field, String colName, DbType dbtype) {
    return TrackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TrackField? _TrackId;
  TrackField get TrackId {
    return _TrackId = _setField(_TrackId, 'TrackId', DbType.integer);
  }

  TrackField? _Name;
  TrackField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  TrackField? _Composer;
  TrackField get Composer {
    return _Composer = _setField(_Composer, 'Composer', DbType.text);
  }

  TrackField? _Milliseconds;
  TrackField get Milliseconds {
    return _Milliseconds =
        _setField(_Milliseconds, 'Milliseconds', DbType.integer);
  }

  TrackField? _Bytes;
  TrackField get Bytes {
    return _Bytes = _setField(_Bytes, 'Bytes', DbType.integer);
  }

  TrackField? _UnitPrice;
  TrackField get UnitPrice {
    return _UnitPrice = _setField(_UnitPrice, 'UnitPrice', DbType.real);
  }

  TrackField? _MediaTypeId;
  TrackField get MediaTypeId {
    return _MediaTypeId =
        _setField(_MediaTypeId, 'MediaTypeId', DbType.integer);
  }

  TrackField? _GenreId;
  TrackField get GenreId {
    return _GenreId = _setField(_GenreId, 'GenreId', DbType.integer);
  }

  TrackField? _AlbumId;
  TrackField get AlbumId {
    return _AlbumId = _setField(_AlbumId, 'AlbumId', DbType.integer);
  }

  /// Deletes List<Track> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Check sub records where in (InvoiceLine) according to DeleteRule.NO_ACTION

    final idListInvoiceLineBYTrackId = toListPrimaryKeySQL(false);
    final resInvoiceLineBYTrackId = await InvoiceLine()
        .select()
        .where('TrackId IN (${idListInvoiceLineBYTrackId['sql']})',
            parameterValue: idListInvoiceLineBYTrackId['args'])
        .toCount();
    if (resInvoiceLineBYTrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.TrackId)');
    }
// Check sub records where in (VTrack) according to DeleteRule.NO_ACTION

    final idListVTrackBYTrackId = toListPrimaryKeySQL(false);
    final resVTrackBYTrackId = await VTrack()
        .select()
        .where('TrackId IN (${idListVTrackBYTrackId['sql']})',
            parameterValue: idListVTrackBYTrackId['args'])
        .toCount();
    if (resVTrackBYTrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VTrack.TrackId)');
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTrack!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTrack!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'TrackId IN (SELECT TrackId from Track ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTrack!.updateBatch(qparams, values);
  }

  /// This method always returns [Track] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Track?
  @override
  Future<Track?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTrack!.toList(qparams);
    final data = await objFuture;
    Track? obj;
    if (data.isNotEmpty) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedfields!.add('Track.plInvoiceLines'); */ obj.plInvoiceLines =
              obj.plInvoiceLines ??
                  await obj.getInvoiceLines()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedfields!.add('Track.plPlaylists'); */ obj.plPlaylists =
              obj.plPlaylists ??
                  await obj.getPlaylists()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedfields!.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedfields!.add('Track.plVTracks'); */ obj.plVTracks =
              obj.plVTracks ??
                  await obj.getVTracks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          obj.plGenre =
              obj.plGenre ?? await obj.getGenre(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          obj.plAlbum =
              obj.plAlbum ?? await obj.getAlbum(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Track]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Track?
  @override
  Future<Track> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Track();
  }

  /// This method returns int. [Track]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? trackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tracksFuture = await _mnTrack!.toList(qparams);
    final int count = tracksFuture[0]['CNT'] as int;
    if (trackCount != null) {
      trackCount(count);
    }
    return count;
  }

  /// This method returns List<Track> [Track]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Track>
  @override
  Future<List<Track>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Track> tracksData = await Track.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tracksData;
  }

  /// This method returns Json String [Track]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Track]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Track]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTrack!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Track>>
  Future<List<DropdownMenuItem<Track>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Track>> o)?
          dropDownMenu]) async {
    buildParameters();
    final tracksFuture = _mnTrack!.toList(qparams);

    final data = await tracksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Track>> items = []..add(DropdownMenuItem(
        value: Track(),
        child: Text('Select Track'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Track.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['TrackId', displayTextColumn];
    final tracksFuture = _mnTrack!.toList(qparams);

    final data = await tracksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Track'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['TrackId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Track]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `TrackId` FROM Track WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> TrackIdData = <int>[];
    qparams.selectColumns = ['TrackId'];
    final TrackIdFuture = await _mnTrack!.toList(qparams);

    final int count = TrackIdFuture.length;
    for (int i = 0; i < count; i++) {
      TrackIdData.add(TrackIdFuture[i]['TrackId'] as int);
    }
    return TrackIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Track]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTrack!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Track.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTrack!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TrackFilterBuilder

// region TrackFields
class TrackFields {
  static TableField? _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'trackid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField? _fComposer;
  static TableField get Composer {
    return _fComposer =
        _fComposer ?? SqlSyntax.setField(_fComposer, 'Composer', DbType.text);
  }

  static TableField? _fMilliseconds;
  static TableField get Milliseconds {
    return _fMilliseconds = _fMilliseconds ??
        SqlSyntax.setField(_fMilliseconds, 'Milliseconds', DbType.integer);
  }

  static TableField? _fBytes;
  static TableField get Bytes {
    return _fBytes =
        _fBytes ?? SqlSyntax.setField(_fBytes, 'Bytes', DbType.integer);
  }

  static TableField? _fUnitPrice;
  static TableField get UnitPrice {
    return _fUnitPrice = _fUnitPrice ??
        SqlSyntax.setField(_fUnitPrice, 'UnitPrice', DbType.real);
  }

  static TableField? _fMediaTypeId;
  static TableField get MediaTypeId {
    return _fMediaTypeId = _fMediaTypeId ??
        SqlSyntax.setField(_fMediaTypeId, 'MediaTypeId', DbType.integer);
  }

  static TableField? _fGenreId;
  static TableField get GenreId {
    return _fGenreId =
        _fGenreId ?? SqlSyntax.setField(_fGenreId, 'GenreId', DbType.integer);
  }

  static TableField? _fAlbumId;
  static TableField get AlbumId {
    return _fAlbumId =
        _fAlbumId ?? SqlSyntax.setField(_fAlbumId, 'AlbumId', DbType.integer);
  }
}
// endregion TrackFields

//region TrackManager
class TrackManager extends SqfEntityProvider {
  TrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Track';
  static const List<String> _primaryKeyList = ['TrackId'];
  static const String _whereStr = 'TrackId=?';
}

//endregion TrackManager
// region VTrack
class VTrack extends TableBase {
  VTrack({this.Name, this.album, this.media, this.genres, this.TrackId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  VTrack.withFields(
      this.Name, this.album, this.media, this.genres, this.TrackId) {
    _setDefaultValues();
  }
  VTrack.withId(this.Name, this.album, this.media, this.genres, this.TrackId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  VTrack.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
    if (o['album'] != null) {
      album = o['album'].toString();
    }
    if (o['media'] != null) {
      media = o['media'].toString();
    }
    if (o['genres'] != null) {
      genres = o['genres'].toString();
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (VTrack)
  String? Name;
  String? album;
  String? media;
  String? genres;
  int? TrackId;
  bool? isSaved;
  // end FIELDS (VTrack)

// RELATIONSHIPS (VTrack)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track? plTrack;

  /// get Track By TrackId
  Future<Track?> getTrack(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (VTrack)

  VTrackManager? __mnVTrack;

  VTrackManager get _mnVTrack {
    return __mnVTrack = __mnVTrack ?? VTrackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (album != null || !forView) {
      map['album'] = album;
    }
    if (media != null || !forView) {
      map['media'] = media;
    }
    if (genres != null || !forView) {
      map['genres'] = genres;
    }
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (album != null || !forView) {
      map['album'] = album;
    }
    if (media != null || !forView) {
      map['media'] = media;
    }
    if (genres != null || !forView) {
      map['genres'] = genres;
    }
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }

    return map;
  }

  /// This method returns Json String [VTrack]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VTrack]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Name, album, media, genres, TrackId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Name, album, media, genres, TrackId];
  }

  static Future<List<VTrack>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VTrack.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<VTrack>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VTrack>[];
    try {
      objList = list
          .map((vtrack) => VTrack.fromMap(vtrack as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VTrack.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VTrack>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<VTrack> objList = <VTrack>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VTrack.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  @override
  VTrackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VTrackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {}

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vtrack

// region VTrackField
class VTrackField extends FilterBase {
  VTrackField(VTrackFilterBuilder vtrackFB) : super(vtrackFB);

  @override
  VTrackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder isNull() {
    return super.isNull() as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VTrackFilterBuilder;
  }

  @override
  VTrackField get not {
    return super.not as VTrackField;
  }
}
// endregion VTrackField

// region VTrackFilterBuilder
class VTrackFilterBuilder extends ConjunctionBase {
  VTrackFilterBuilder(VTrack obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnVTrack = obj._mnVTrack;
  }

  VTrackManager? _mnVTrack;

  /// put the sql keyword 'AND'
  @override
  VTrackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VTrackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VTrackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VTrackFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VTrackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VTrackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VTrackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VTrackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VTrackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VTrackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VTrackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VTrackField _setField(VTrackField? field, String colName, DbType dbtype) {
    return VTrackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VTrackField? _Name;
  VTrackField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  VTrackField? _album;
  VTrackField get album {
    return _album = _setField(_album, 'album', DbType.text);
  }

  VTrackField? _media;
  VTrackField get media {
    return _media = _setField(_media, 'media', DbType.text);
  }

  VTrackField? _genres;
  VTrackField get genres {
    return _genres = _setField(_genres, 'genres', DbType.text);
  }

  VTrackField? _TrackId;
  VTrackField get TrackId {
    return _TrackId = _setField(_TrackId, 'TrackId', DbType.integer);
  }

  /// This method always returns [VTrack] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VTrack?
  @override
  Future<VTrack?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVTrack!.toList(qparams);
    final data = await objFuture;
    VTrack? obj;
    if (data.isNotEmpty) {
      obj = VTrack.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [VTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VTrack?
  @override
  Future<VTrack> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        VTrack();
  }

  /// This method returns int. [VTrack]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? vtrackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vtracksFuture = await _mnVTrack!.toList(qparams);
    final int count = vtracksFuture[0]['CNT'] as int;
    if (vtrackCount != null) {
      vtrackCount(count);
    }
    return count;
  }

  /// This method returns List<VTrack> [VTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<VTrack>
  @override
  Future<List<VTrack>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<VTrack> vtracksData = await VTrack.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vtracksData;
  }

  /// This method returns Json String [VTrack]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VTrack]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VTrack]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVTrack!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VTrack]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `` FROM VTracks WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VTrack]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVTrack!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await VTrack.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVTrack!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VTrackFilterBuilder

// region VTrackFields
class VTrackFields {
  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField? _fAlbum;
  static TableField get album {
    return _fAlbum =
        _fAlbum ?? SqlSyntax.setField(_fAlbum, 'album', DbType.text);
  }

  static TableField? _fMedia;
  static TableField get media {
    return _fMedia =
        _fMedia ?? SqlSyntax.setField(_fMedia, 'media', DbType.text);
  }

  static TableField? _fGenres;
  static TableField get genres {
    return _fGenres =
        _fGenres ?? SqlSyntax.setField(_fGenres, 'genres', DbType.text);
  }

  static TableField? _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }
}
// endregion VTrackFields

//region VTrackManager
class VTrackManager extends SqfEntityProvider {
  VTrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'VTracks';
  static const List<String> _primaryKeyList = [''];
  static const String _whereStr = '';
}

//endregion VTrackManager
// region PlaylistTrack
class PlaylistTrack extends TableBase {
  PlaylistTrack({this.TrackId, this.PlaylistId}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  PlaylistTrack.withFields(this.TrackId, this.PlaylistId) {
    _setDefaultValues();
  }
  PlaylistTrack.withId(this.TrackId, this.PlaylistId) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PlaylistTrack.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    PlaylistId = int.tryParse(o['PlaylistId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    plPlaylist = o['playlist'] != null
        ? Playlist.fromMap(o['playlist'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (PlaylistTrack)
  int? TrackId;
  int? PlaylistId;
  bool? isSaved;
  // end FIELDS (PlaylistTrack)

// RELATIONSHIPS (PlaylistTrack)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track? plTrack;

  /// get Track By TrackId
  Future<Track?> getTrack(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plPlaylist', 'plField2'..]) or so on..
  Playlist? plPlaylist;

  /// get Playlist By PlaylistId
  Future<Playlist?> getPlaylist(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await Playlist().getById(PlaylistId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PlaylistTrack)

  static const bool _softDeleteActivated = false;
  PlaylistTrackManager? __mnPlaylistTrack;

  PlaylistTrackManager get _mnPlaylistTrack {
    return __mnPlaylistTrack = __mnPlaylistTrack ?? PlaylistTrackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }
    if (PlaylistId != null) {
      map['PlaylistId'] = forView
          ? plPlaylist == null
              ? PlaylistId
              : plPlaylist!.Name
          : PlaylistId;
    } else if (PlaylistId != null || !forView) {
      map['PlaylistId'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = forView
          ? plTrack == null
              ? TrackId
              : plTrack!.Name
          : TrackId;
    } else if (TrackId != null || !forView) {
      map['TrackId'] = null;
    }
    if (PlaylistId != null) {
      map['PlaylistId'] = forView
          ? plPlaylist == null
              ? PlaylistId
              : plPlaylist!.Name
          : PlaylistId;
    } else if (PlaylistId != null || !forView) {
      map['PlaylistId'] = null;
    }

    return map;
  }

  /// This method returns Json String [PlaylistTrack]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PlaylistTrack]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [TrackId, PlaylistId];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [TrackId, PlaylistId];
  }

  static Future<List<PlaylistTrack>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistTrack.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PlaylistTrack>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PlaylistTrack>[];
    try {
      objList = list
          .map((playlisttrack) =>
              PlaylistTrack.fromMap(playlisttrack as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PlaylistTrack.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PlaylistTrack>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PlaylistTrack> objList = <PlaylistTrack>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PlaylistTrack.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PlaylistTrack by ID if exist, otherwise returns null
  /// Primary Keys: int? TrackId, int? PlaylistId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PlaylistTrack] if exist, otherwise returns null
  Future<PlaylistTrack?> getById(int? TrackId, int? PlaylistId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (TrackId == null) {
      return null;
    }
    PlaylistTrack? obj;
    final data = await _mnPlaylistTrack.getById([TrackId, PlaylistId]);
    if (data.length != 0) {
      obj = PlaylistTrack.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PlaylistTrack) object. If the Primary Key (TrackId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same TrackId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPlaylistTrack.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO PlaylistTrack ( TrackId, PlaylistId)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<PlaylistTrack> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PlaylistTrack> playlisttracks) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Chinookdb().batchStart();
    for (final obj in playlisttracks) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Chinookdb().batchCommit();
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPlaylistTrack.rawInsert(
          'INSERT OR REPLACE INTO PlaylistTrack ( TrackId, PlaylistId)  VALUES (?,?)',
          [TrackId, PlaylistId],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PlaylistTrack TrackId=$TrackId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PlaylistTrack TrackId=$TrackId did not update');
      }
      return TrackId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PlaylistTrack Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PlaylistTrack>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<PlaylistTrack> playlisttracks) async {
    final results = await _mnPlaylistTrack.rawInsertAll(
        'INSERT OR REPLACE INTO PlaylistTrack ( TrackId, PlaylistId)  VALUES (?,?)',
        playlisttracks);
    return results;
  }

  /// Deletes PlaylistTrack

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PlaylistTrack invoked (TrackId=$TrackId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylistTrack.delete(QueryParams(
          whereString: 'TrackId=? AND PlaylistId=?',
          whereArguments: [TrackId, PlaylistId]));
    } else {
      return _mnPlaylistTrack.updateBatch(
          QueryParams(
              whereString: 'TrackId=? AND PlaylistId=?',
              whereArguments: [TrackId, PlaylistId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [PlaylistTrack] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PlaylistTrackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PlaylistTrackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PlaylistTrackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      TrackId = null;
      PlaylistId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion playlisttrack

// region PlaylistTrackField
class PlaylistTrackField extends FilterBase {
  PlaylistTrackField(PlaylistTrackFilterBuilder playlisttrackFB)
      : super(playlisttrackFB);

  @override
  PlaylistTrackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder isNull() {
    return super.isNull() as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PlaylistTrackFilterBuilder;
  }

  @override
  PlaylistTrackField get not {
    return super.not as PlaylistTrackField;
  }
}
// endregion PlaylistTrackField

// region PlaylistTrackFilterBuilder
class PlaylistTrackFilterBuilder extends ConjunctionBase {
  PlaylistTrackFilterBuilder(PlaylistTrack obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPlaylistTrack = obj._mnPlaylistTrack;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PlaylistTrackManager? _mnPlaylistTrack;

  /// put the sql keyword 'AND'
  @override
  PlaylistTrackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PlaylistTrackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PlaylistTrackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PlaylistTrackFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PlaylistTrackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PlaylistTrackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PlaylistTrackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistTrackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistTrackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PlaylistTrackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PlaylistTrackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PlaylistTrackField _setField(
      PlaylistTrackField? field, String colName, DbType dbtype) {
    return PlaylistTrackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PlaylistTrackField? _TrackId;
  PlaylistTrackField get TrackId {
    return _TrackId = _setField(_TrackId, 'TrackId', DbType.integer);
  }

  PlaylistTrackField? _PlaylistId;
  PlaylistTrackField get PlaylistId {
    return _PlaylistId = _setField(_PlaylistId, 'PlaylistId', DbType.integer);
  }

  /// Deletes List<PlaylistTrack> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPlaylistTrack!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPlaylistTrack!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'TrackId IN (SELECT TrackId from PlaylistTrack ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPlaylistTrack!.updateBatch(qparams, values);
  }

  /// This method always returns [PlaylistTrack] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PlaylistTrack?
  @override
  Future<PlaylistTrack?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPlaylistTrack!.toList(qparams);
    final data = await objFuture;
    PlaylistTrack? obj;
    if (data.isNotEmpty) {
      obj = PlaylistTrack.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          obj.plTrack =
              obj.plTrack ?? await obj.getTrack(loadParents: loadParents);
        }
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          obj.plPlaylist =
              obj.plPlaylist ?? await obj.getPlaylist(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PlaylistTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PlaylistTrack?
  @override
  Future<PlaylistTrack> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PlaylistTrack();
  }

  /// This method returns int. [PlaylistTrack]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? playlisttrackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlisttracksFuture = await _mnPlaylistTrack!.toList(qparams);
    final int count = playlisttracksFuture[0]['CNT'] as int;
    if (playlisttrackCount != null) {
      playlisttrackCount(count);
    }
    return count;
  }

  /// This method returns List<PlaylistTrack> [PlaylistTrack]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PlaylistTrack>
  @override
  Future<List<PlaylistTrack>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PlaylistTrack> playlisttracksData =
        await PlaylistTrack.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return playlisttracksData;
  }

  /// This method returns Json String [PlaylistTrack]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PlaylistTrack]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PlaylistTrack]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPlaylistTrack!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PlaylistTrack]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `TrackId`PlaylistId` FROM PlaylistTrack WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<TrackId,PlaylistId> [PlaylistTrack]
  /// <returns>List<TrackId,PlaylistId>
  @override
  Future<List<PlaylistTrack>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['TrackId', 'PlaylistId'];
    final playlisttrackFuture = await _mnPlaylistTrack!.toList(qparams);
    return await PlaylistTrack.fromMapList(playlisttrackFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PlaylistTrack]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPlaylistTrack!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PlaylistTrack.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPlaylistTrack!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistTrackFilterBuilder

// region PlaylistTrackFields
class PlaylistTrackFields {
  static TableField? _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }

  static TableField? _fPlaylistId;
  static TableField get PlaylistId {
    return _fPlaylistId = _fPlaylistId ??
        SqlSyntax.setField(_fPlaylistId, 'PlaylistId', DbType.integer);
  }
}
// endregion PlaylistTrackFields

//region PlaylistTrackManager
class PlaylistTrackManager extends SqfEntityProvider {
  PlaylistTrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'PlaylistTrack';
  static const List<String> _primaryKeyList = ['TrackId', 'PlaylistId'];
  static const String _whereStr = 'TrackId=? AND PlaylistId=?';
}

//endregion PlaylistTrackManager
class ChinookdbSequenceManager extends SqfEntityProvider {
  ChinookdbSequenceManager() : super(Chinookdb());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (Album)
class AlbumToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'AlbumId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Title';
  //static String formListSubTitleField = 'ArtistId';
}

class AlbumController extends Album {
  String formListTitleField = 'Title';
  String formListSubTitleField = 'ArtistId';
  static SQFViewList getController = SQFViewList(
    AlbumController(),
    primaryKeyName: 'AlbumId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['AlbumToTrack'] = 'Album To Track(AlbumId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'AlbumToTrack':
        return SQFViewList(
          AlbumToTrackControllerSub(),
          primaryKeyName: AlbumToTrackControllerSub.primaryKeyName,
          useSoftDeleting: AlbumToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Title',
          //formListSubTitleField: 'ArtistId',
          filterExpression:
              '${AlbumToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return AlbumAdd(obj == null
        ? Album()
        : await Album().getById(obj['AlbumId'] as int) ?? Album());
  }
}
// END CONTROLLER (Album)

// BEGIN CONTROLLER (Artist)
class ArtistToAlbumControllerSub extends AlbumController {
  static String relationshipFieldName = 'ArtistId';
  static String primaryKeyName = 'AlbumId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class ArtistController extends Artist {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    ArtistController(),
    primaryKeyName: 'ArtistId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ArtistToAlbum'] = 'Artist To Album(ArtistId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ArtistToAlbum':
        return SQFViewList(
          ArtistToAlbumControllerSub(),
          primaryKeyName: ArtistToAlbumControllerSub.primaryKeyName,
          useSoftDeleting: ArtistToAlbumControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${ArtistToAlbumControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ArtistAdd(obj == null
        ? Artist()
        : await Artist().getById(obj['ArtistId'] as int) ?? Artist());
  }
}
// END CONTROLLER (Artist)

// BEGIN CONTROLLER (Customer)
class CustomerToInvoiceControllerSub extends InvoiceController {
  static String relationshipFieldName = 'CustomerId';
  static String primaryKeyName = 'InvoiceId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'FirstName';
  //static String formListSubTitleField = 'LastName';
}

class CustomerController extends Customer {
  String formListTitleField = 'FirstName';
  String formListSubTitleField = 'LastName';
  static SQFViewList getController = SQFViewList(
    CustomerController(),
    primaryKeyName: 'CustomerId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['CustomerToInvoice'] = 'Customer To Invoice(CustomerId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'CustomerToInvoice':
        return SQFViewList(
          CustomerToInvoiceControllerSub(),
          primaryKeyName: CustomerToInvoiceControllerSub.primaryKeyName,
          useSoftDeleting: CustomerToInvoiceControllerSub.useSoftDeleting,
          //formListTitleField: 'FirstName',
          //formListSubTitleField: 'LastName',
          filterExpression:
              '${CustomerToInvoiceControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return CustomerAdd(obj == null
        ? Customer()
        : await Customer().getById(obj['CustomerId'] as int) ?? Customer());
  }
}
// END CONTROLLER (Customer)

// BEGIN CONTROLLER (Employee)
class EmployeeToCustomerControllerSub extends CustomerController {
  static String relationshipFieldName = 'SupportRepId';
  static String primaryKeyName = 'CustomerId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'LastName';
  //static String formListSubTitleField = 'FirstName';
}

class EmployeeToEmployeeControllerSub extends EmployeeController {
  static String relationshipFieldName = 'ReportsTo';
  static String primaryKeyName = 'EmployeeId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'LastName';
  //static String formListSubTitleField = 'FirstName';
}

class EmployeeController extends Employee {
  String formListTitleField = 'LastName';
  String formListSubTitleField = 'FirstName';
  static SQFViewList getController = SQFViewList(
    EmployeeController(),
    primaryKeyName: 'EmployeeId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['EmployeeToCustomer'] = 'Employee To Customer(SupportRepId)';
    menu['EmployeeToEmployee'] = 'Employee To Employee(ReportsTo)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'EmployeeToCustomer':
        return SQFViewList(
          EmployeeToCustomerControllerSub(),
          primaryKeyName: EmployeeToCustomerControllerSub.primaryKeyName,
          useSoftDeleting: EmployeeToCustomerControllerSub.useSoftDeleting,
          //formListTitleField: 'LastName',
          //formListSubTitleField: 'FirstName',
          filterExpression:
              '${EmployeeToCustomerControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'EmployeeToEmployee':
        return SQFViewList(
          EmployeeToEmployeeControllerSub(),
          primaryKeyName: EmployeeToEmployeeControllerSub.primaryKeyName,
          useSoftDeleting: EmployeeToEmployeeControllerSub.useSoftDeleting,
          //formListTitleField: 'LastName',
          //formListSubTitleField: 'FirstName',
          filterExpression:
              '${EmployeeToEmployeeControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return EmployeeAdd(obj == null
        ? Employee()
        : await Employee().getById(obj['EmployeeId'] as int) ?? Employee());
  }
}
// END CONTROLLER (Employee)

// BEGIN CONTROLLER (Genre)
class GenreToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'GenreId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class GenreController extends Genre {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    GenreController(),
    primaryKeyName: 'GenreId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['GenreToTrack'] = 'Genre To Track(GenreId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'GenreToTrack':
        return SQFViewList(
          GenreToTrackControllerSub(),
          primaryKeyName: GenreToTrackControllerSub.primaryKeyName,
          useSoftDeleting: GenreToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${GenreToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return GenreAdd(obj == null
        ? Genre()
        : await Genre().getById(obj['GenreId'] as int) ?? Genre());
  }
}
// END CONTROLLER (Genre)

// BEGIN CONTROLLER (Invoice)
class InvoiceToInvoiceLineControllerSub extends InvoiceLineController {
  static String relationshipFieldName = 'InvoiceId';
  static String primaryKeyName = 'InvoiceLineId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'BillingAddress';
  //static String formListSubTitleField = 'BillingCity';
}

class InvoiceController extends Invoice {
  String formListTitleField = 'BillingAddress';
  String formListSubTitleField = 'BillingCity';
  static SQFViewList getController = SQFViewList(
    InvoiceController(),
    primaryKeyName: 'InvoiceId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['InvoiceToInvoiceLine'] = 'Invoice To InvoiceLine(InvoiceId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'InvoiceToInvoiceLine':
        return SQFViewList(
          InvoiceToInvoiceLineControllerSub(),
          primaryKeyName: InvoiceToInvoiceLineControllerSub.primaryKeyName,
          useSoftDeleting: InvoiceToInvoiceLineControllerSub.useSoftDeleting,
          //formListTitleField: 'BillingAddress',
          //formListSubTitleField: 'BillingCity',
          filterExpression:
              '${InvoiceToInvoiceLineControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return InvoiceAdd(obj == null
        ? Invoice()
        : await Invoice().getById(obj['InvoiceId'] as int) ?? Invoice());
  }
}
// END CONTROLLER (Invoice)

// BEGIN CONTROLLER (InvoiceLine)

class InvoiceLineController extends InvoiceLine {
  String formListTitleField = 'InvoiceLineId';
  String formListSubTitleField = 'UnitPrice';
  static SQFViewList getController = SQFViewList(
    InvoiceLineController(),
    primaryKeyName: 'InvoiceLineId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return InvoiceLineAdd(obj == null
        ? InvoiceLine()
        : await InvoiceLine().getById(obj['InvoiceLineId'] as int) ??
            InvoiceLine());
  }
}
// END CONTROLLER (InvoiceLine)

// BEGIN CONTROLLER (MediaType)
class MediaTypeToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'MediaTypeId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class MediaTypeController extends MediaType {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    MediaTypeController(),
    primaryKeyName: 'MediaTypeId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['MediaTypeToTrack'] = 'MediaType To Track(MediaTypeId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'MediaTypeToTrack':
        return SQFViewList(
          MediaTypeToTrackControllerSub(),
          primaryKeyName: MediaTypeToTrackControllerSub.primaryKeyName,
          useSoftDeleting: MediaTypeToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${MediaTypeToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return MediaTypeAdd(obj == null
        ? MediaType()
        : await MediaType().getById(obj['MediaTypeId'] as int) ?? MediaType());
  }
}
// END CONTROLLER (MediaType)

// BEGIN CONTROLLER (Playlist)
class PlaylistToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'mPlaylistTrack';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class PlaylistController extends Playlist {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    PlaylistController(),
    primaryKeyName: 'PlaylistId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['PlaylistToTrack'] = 'Playlist To Track(mPlaylistTrack)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'PlaylistToTrack':
        return SQFViewList(
          PlaylistToTrackControllerSub(),
          primaryKeyName: PlaylistToTrackControllerSub.primaryKeyName,
          useSoftDeleting: PlaylistToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              'TrackId IN (SELECT TrackId FROM PlaylistTrack WHERE PlaylistId=?)',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return PlaylistAdd(obj == null
        ? Playlist()
        : await Playlist().getById(obj['PlaylistId'] as int) ?? Playlist());
  }
}
// END CONTROLLER (Playlist)

// BEGIN CONTROLLER (Track)
class TrackToInvoiceLineControllerSub extends InvoiceLineController {
  static String relationshipFieldName = 'TrackId';
  static String primaryKeyName = 'InvoiceLineId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = 'Composer';
}

class TrackToPlaylistControllerSub extends PlaylistController {
  static String relationshipFieldName = 'TrackTrackId';
  static String primaryKeyName = 'PlaylistId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = 'Composer';
}

class TrackController extends Track {
  String formListTitleField = 'Name';
  String formListSubTitleField = 'Composer';
  static SQFViewList getController = SQFViewList(
    TrackController(),
    primaryKeyName: 'TrackId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['TrackToInvoiceLine'] = 'Track To InvoiceLine(TrackId)';
    menu['TrackToPlaylist'] = 'Track To Playlist(TrackTrackId)';

    return menu;
  }

  SQFViewList? subList(int id, String controllerName) {
    switch (controllerName) {
      case 'TrackToInvoiceLine':
        return SQFViewList(
          TrackToInvoiceLineControllerSub(),
          primaryKeyName: TrackToInvoiceLineControllerSub.primaryKeyName,
          useSoftDeleting: TrackToInvoiceLineControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: 'Composer',
          filterExpression:
              '${TrackToInvoiceLineControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'TrackToPlaylist':
        return SQFViewList(
          TrackToPlaylistControllerSub(),
          primaryKeyName: TrackToPlaylistControllerSub.primaryKeyName,
          useSoftDeleting: TrackToPlaylistControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: 'Composer',
          filterExpression:
              'PlaylistId IN (SELECT PlaylistId FROM PlaylistTrack WHERE TrackId=?)',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return TrackAdd(obj == null
        ? Track()
        : await Track().getById(obj['TrackId'] as int) ?? Track());
  }
}
// END CONTROLLER (Track)

// END OF CONTROLLERS
