// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'chinook.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Album.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// ignore_for_file:
// BEGIN TABLES
// Album TABLE
class TableAlbum extends SqfEntityTableBase {
  TableAlbum() {
    // declare properties of EntityTable
    tableName = 'Album';
    primaryKeyName = 'AlbumId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Title', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableArtist.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'ArtistId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAlbum();
  }
}

// Artist TABLE
class TableArtist extends SqfEntityTableBase {
  TableArtist() {
    // declare properties of EntityTable
    tableName = 'Artist';
    primaryKeyName = 'ArtistId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArtist();
  }
}

// Customer TABLE
class TableCustomer extends SqfEntityTableBase {
  TableCustomer() {
    // declare properties of EntityTable
    tableName = 'Customer';
    primaryKeyName = 'CustomerId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FirstName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('LastName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Company', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Address', DbType.text, isNotNull: false),
      SqfEntityFieldBase('City', DbType.text, isNotNull: false),
      SqfEntityFieldBase('State', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Country', DbType.text, isNotNull: false),
      SqfEntityFieldBase('PostalCode', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Phone', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Fax', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Email', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableEmployee.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'SupportRepId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCustomer();
  }
}

// Employee TABLE
class TableEmployee extends SqfEntityTableBase {
  TableEmployee() {
    // declare properties of EntityTable
    tableName = 'Employee';
    primaryKeyName = 'EmployeeId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('LastName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('FirstName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Title', DbType.text, isNotNull: false),
      SqfEntityFieldBase('BirthDate', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('HireDate', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('Address', DbType.text, isNotNull: false),
      SqfEntityFieldBase('City', DbType.text, isNotNull: false),
      SqfEntityFieldBase('State', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Country', DbType.text, isNotNull: false),
      SqfEntityFieldBase('PostalCode', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Phone', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Fax', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Email', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(null, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'ReportsTo',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEmployee();
  }
}

// Genre TABLE
class TableGenre extends SqfEntityTableBase {
  TableGenre() {
    // declare properties of EntityTable
    tableName = 'Genre';
    primaryKeyName = 'GenreId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableGenre();
  }
}

// Invoice TABLE
class TableInvoice extends SqfEntityTableBase {
  TableInvoice() {
    // declare properties of EntityTable
    tableName = 'Invoice';
    primaryKeyName = 'InvoiceId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('InvoiceDate', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('BillingAddress', DbType.text, isNotNull: false),
      SqfEntityFieldBase('BillingCity', DbType.text, isNotNull: false),
      SqfEntityFieldBase('BillingState', DbType.text, isNotNull: false),
      SqfEntityFieldBase('BillingCountry', DbType.text, isNotNull: false),
      SqfEntityFieldBase('BillingPostalCode', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Total', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableCustomer.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'CustomerId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoice();
  }
}

// InvoiceLine TABLE
class TableInvoiceLine extends SqfEntityTableBase {
  TableInvoiceLine() {
    // declare properties of EntityTable
    tableName = 'InvoiceLine';
    primaryKeyName = 'InvoiceLineId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('UnitPrice', DbType.real, isNotNull: false),
      SqfEntityFieldBase('Quantity', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'TrackId',
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableInvoice.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'InvoiceId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInvoiceLine();
  }
}

// MediaType TABLE
class TableMediaType extends SqfEntityTableBase {
  TableMediaType() {
    // declare properties of EntityTable
    tableName = 'MediaType';
    primaryKeyName = 'MediaTypeId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableMediaType();
  }
}

// Playlist TABLE
class TablePlaylist extends SqfEntityTableBase {
  TablePlaylist() {
    // declare properties of EntityTable
    tableName = 'Playlist';
    primaryKeyName = 'PlaylistId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylist();
  }
}

// Track TABLE
class TableTrack extends SqfEntityTableBase {
  TableTrack() {
    // declare properties of EntityTable
    tableName = 'Track';
    primaryKeyName = 'TrackId';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Composer', DbType.text, isNotNull: false),
      SqfEntityFieldBase('Milliseconds', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('Bytes', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('UnitPrice', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableMediaType.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'MediaTypeId',
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableGenre.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'GenreId',
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableAlbum.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'AlbumId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTrack();
  }
}

// VTrack TABLE
class TableVTrack extends SqfEntityTableBase {
  TableVTrack() {
    // declare properties of EntityTable
    tableName = 'VTracks';
    objectType = ObjectType.view;
    sqlStatement = chinookdb.databaseTables[10].sqlStatement;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('album', DbType.text, isNotNull: false),
      SqfEntityFieldBase('media', DbType.text, isNotNull: false),
      SqfEntityFieldBase('genres', DbType.text, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'TrackId',
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVTrack();
  }
}

// PlaylistTrack TABLE
class TablePlaylistTrack extends SqfEntityTableBase {
  TablePlaylistTrack() {
    // declare properties of EntityTable
    tableName = 'PlaylistTrack';
    relationType = RelationType.MANY_TO_MANY;
    primaryKeyName = '';
    primaryKeyType = null;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldRelationshipBase(
          TableTrack.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'TrackId',
          isPrimaryKeyField: true,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TablePlaylist.getInstance, DeleteRule.NO_ACTION,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'PlaylistId',
          isPrimaryKeyField: true,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePlaylistTrack();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class Chinookdb extends SqfEntityModelProvider {
  Chinookdb() {
    databaseName = chinookdb.databaseName;
    password = chinookdb.password;
    dbVersion = chinookdb.dbVersion;
    databaseTables = [
      TableAlbum.getInstance,
      TableArtist.getInstance,
      TableCustomer.getInstance,
      TableEmployee.getInstance,
      TableGenre.getInstance,
      TableInvoice.getInstance,
      TableInvoiceLine.getInstance,
      TableMediaType.getInstance,
      TablePlaylist.getInstance,
      TableTrack.getInstance,
      TableVTrack.getInstance,
    ];

    bundledDatabasePath = chinookdb
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['album'] = AlbumController.getController;
    controllers['artist'] = ArtistController.getController;
    controllers['customer'] = CustomerController.getController;
    controllers['employee'] = EmployeeController.getController;
    controllers['genre'] = GenreController.getController;
    controllers['invoice'] = InvoiceController.getController;
    controllers['invoiceline'] = InvoiceLineController.getController;
    controllers['mediatype'] = MediaTypeController.getController;
    controllers['playlist'] = PlaylistController.getController;
    controllers['track'] = TrackController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Album
class Album {
  Album({this.AlbumId, this.Title, this.ArtistId}) {
    _setDefaultValues();
  }
  Album.withFields(this.AlbumId, this.Title, this.ArtistId) {
    _setDefaultValues();
  }
  Album.withId(this.AlbumId, this.Title, this.ArtistId) {
    _setDefaultValues();
  }
  Album.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    AlbumId = int.tryParse(o['AlbumId'].toString());
    if (o['Title'] != null) {
      Title = o['Title'] as String;
    }
    ArtistId = int.tryParse(o['ArtistId'].toString());

    // RELATIONSHIPS FromMAP
    plArtist = o['artist'] != null
        ? Artist.fromMap(o['artist'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Album)
  int AlbumId;
  String Title;
  int ArtistId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Album)

// RELATIONSHIPS (Album)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plArtist', 'plField2'..]) or so on..
  Artist plArtist;

  /// get Artist By ArtistId
  Future<Artist> getArtist(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Artist().getById(ArtistId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Album)

// COLLECTIONS & VIRTUALS (Album)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track> plTracks;

  /// get Track(s) filtered by AlbumId=AlbumId
  TrackFilterBuilder getTracks(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (AlbumId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .AlbumId
        .equals(AlbumId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Album)

  static const bool _softDeleteActivated = false;
  AlbumManager __mnAlbum;

  AlbumManager get _mnAlbum {
    return __mnAlbum = __mnAlbum ?? AlbumManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (AlbumId != null) {
      map['AlbumId'] = AlbumId;
    }
    if (Title != null) {
      map['Title'] = Title;
    }

    if (ArtistId != null) {
      map['ArtistId'] = forView ? plArtist.Name : ArtistId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (AlbumId != null) {
      map['AlbumId'] = AlbumId;
    }
    if (Title != null) {
      map['Title'] = Title;
    }

    if (ArtistId != null) {
      map['ArtistId'] = forView ? plArtist.Name : ArtistId;
    }

// COLLECTIONS (Album)
    if (!forQuery) {
      map['Tracks'] = await getTracks().toMapList();
    }
// END COLLECTIONS (Album)

    return map;
  }

  /// This method returns Json String [Album]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Album]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [AlbumId, Title, ArtistId];
  }

  List<dynamic> toArgsWithIds() {
    return [AlbumId, Title, ArtistId];
  }

  static Future<List<Album>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Album.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Album>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Album>[];
    try {
      objList = list
          .map((album) => Album.fromMap(album as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Album.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Album>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Album> objList = <Album>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Album.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Album.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plArtist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          /*_loadedFields.add('Artist.plArtist');*/
          obj.plArtist = obj.plArtist ??
              await obj.getArtist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Album by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int AlbumId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Album if exist, otherwise returns null
  Future<Album> getById(int AlbumId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (AlbumId == null) {
      return null;
    }
    Album obj;
    final data = await _mnAlbum.getById([AlbumId]);
    if (data.length != 0) {
      obj = Album.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Album.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plArtist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          /*_loadedFields.add('Artist.plArtist');*/
          obj.plArtist = obj.plArtist ??
              await obj.getArtist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Album) object. If the AlbumId field is null, saves as a new record and returns new AlbumId, if AlbumId is not null then updates record

  /// <returns>Returns AlbumId
  Future<int> save() async {
    if (AlbumId == null || AlbumId == 0 || !isSaved) {
      await _mnAlbum.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // AlbumId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAlbum.update(this);
    }

    return AlbumId;
  }

  /// saveAll method saves the sent List<Album> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Album> albums) async {
    // final results = _mnAlbum.saveAll('INSERT OR REPLACE INTO Album (AlbumId,Title, ArtistId)  VALUES (?,?,?)',albums);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in albums) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns AlbumId
  Future<int> upsert() async {
    try {
      if (await _mnAlbum.rawInsert(
              'INSERT OR REPLACE INTO Album (AlbumId,Title, ArtistId)  VALUES (?,?,?)',
              [AlbumId, Title, ArtistId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Album AlbumId=$AlbumId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Album AlbumId=$AlbumId did not update');
      }
      return AlbumId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Album Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Album>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Album> albums) async {
    final results = await _mnAlbum.rawInsertAll(
        'INSERT OR REPLACE INTO Album (AlbumId,Title, ArtistId)  VALUES (?,?,?)',
        albums);
    return results;
  }

  /// Deletes Album

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Album invoked (AlbumId=$AlbumId)');
    if (await Track().select().AlbumId.equals(AlbumId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.AlbumId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnAlbum.delete(
          QueryParams(whereString: 'AlbumId=?', whereArguments: [AlbumId]));
    } else {
      return _mnAlbum.updateBatch(
          QueryParams(whereString: 'AlbumId=?', whereArguments: [AlbumId]),
          {'isDeleted': 1});
    }
  }

  AlbumFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return AlbumFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  AlbumFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return AlbumFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion album

// region AlbumField
class AlbumField extends SearchCriteria {
  AlbumField(this.albumFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  AlbumFilterBuilder albumFB;

  AlbumField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  AlbumFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param, SqlSyntax.EQuals,
            albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param, SqlSyntax.NotEQuals,
            albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param, SqlSyntax.EQualsOrNull,
            albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder isNull() {
    albumFB._addedBlocks = setCriteria(
        0,
        albumFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      albumFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          albumFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          albumFB._addedBlocks);
      _waitingNot = '';
      albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
          albumFB._addedBlocks.retVal;
    }
    return albumFB;
  }

  AlbumFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      albumFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          albumFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          albumFB._addedBlocks);
      _waitingNot = '';
      albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
          albumFB._addedBlocks.retVal;
      albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
          albumFB._addedBlocks.retVal;
    }
    return albumFB;
  }

  AlbumFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      albumFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          albumFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          albumFB._addedBlocks);
      _waitingNot = '';
      albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
          albumFB._addedBlocks.retVal;
    }
    return albumFB;
  }

  AlbumFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      albumFB._addedBlocks = setCriteria(
          pFirst,
          albumFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          albumFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        albumFB._addedBlocks = setCriteria(pFirst, albumFB.parameters, param,
            SqlSyntax.LessThan, albumFB._addedBlocks);
      } else {
        albumFB._addedBlocks = setCriteria(pFirst, albumFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, albumFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        albumFB._addedBlocks = setCriteria(pLast, albumFB.parameters, param,
            SqlSyntax.GreaterThan, albumFB._addedBlocks);
      } else {
        albumFB._addedBlocks = setCriteria(pLast, albumFB.parameters, param,
            SqlSyntax.LessThanOrEquals, albumFB._addedBlocks);
      }
    }
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param, SqlSyntax.GreaterThan,
            albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param,
            SqlSyntax.LessThanOrEquals, albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param, SqlSyntax.LessThan,
            albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param, SqlSyntax.LessThan,
            albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    albumFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, albumFB.parameters, param,
            SqlSyntax.LessThanOrEquals, albumFB._addedBlocks)
        : setCriteria(pValue, albumFB.parameters, param, SqlSyntax.GreaterThan,
            albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }

  AlbumFilterBuilder inValues(dynamic pValue) {
    albumFB._addedBlocks = setCriteria(
        pValue,
        albumFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        albumFB._addedBlocks);
    _waitingNot = '';
    albumFB._addedBlocks.needEndBlock[albumFB._blockIndex] =
        albumFB._addedBlocks.retVal;
    return albumFB;
  }
}
// endregion AlbumField

// region AlbumFilterBuilder
class AlbumFilterBuilder extends SearchCriteria {
  AlbumFilterBuilder(Album obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Album _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  AlbumFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  AlbumFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  AlbumFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  AlbumFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  AlbumFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  AlbumFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  AlbumFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AlbumFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AlbumFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  AlbumFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  AlbumFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  AlbumField setField(AlbumField field, String colName, DbType dbtype) {
    return AlbumField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  AlbumField _AlbumId;
  AlbumField get AlbumId {
    return _AlbumId = setField(_AlbumId, 'AlbumId', DbType.integer);
  }

  AlbumField _Title;
  AlbumField get Title {
    return _Title = setField(_Title, 'Title', DbType.text);
  }

  AlbumField _ArtistId;
  AlbumField get ArtistId {
    return _ArtistId = setField(_ArtistId, 'ArtistId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Album._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Album> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYAlbumId = toListPrimaryKeySQL(false);
    final resTrackBYAlbumId = await Track()
        .select()
        .where('AlbumId IN (${idListTrackBYAlbumId['sql']})',
            parameterValue: idListTrackBYAlbumId['args'])
        .toCount();
    if (resTrackBYAlbumId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.AlbumId)');
    }

    if (Album._softDeleteActivated && !hardDelete) {
      r = await _obj._mnAlbum.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnAlbum.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'AlbumId IN (SELECT AlbumId from Album ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnAlbum.updateBatch(qparams, values);
  }

  /// This method always returns Album Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Album>
  Future<Album> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnAlbum.toList(qparams);
    final data = await objFuture;
    Album obj;
    if (data.isNotEmpty) {
      obj = Album.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Album.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Album.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plArtist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plArtist'))) {
          /*_loadedFields.add('Artist.plArtist');*/
          obj.plArtist = obj.plArtist ??
              await obj.getArtist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Album]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) albumCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final albumsFuture = await _obj._mnAlbum.toList(qparams);
    final int count = albumsFuture[0]['CNT'] as int;
    if (albumCount != null) {
      albumCount(count);
    }
    return count;
  }

  /// This method returns List<Album> [Album]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Album>
  Future<List<Album>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Album> albumsData = await Album.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return albumsData;
  }

  /// This method returns Json String [Album]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Album]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Album]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnAlbum.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Album>>
  Future<List<DropdownMenuItem<Album>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Album>> o)
          dropDownMenu]) async {
    _buildParameters();
    final albumsFuture = _obj._mnAlbum.toList(qparams);

    final data = await albumsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Album>> items = []..add(DropdownMenuItem(
        value: Album(),
        child: Text('Select Album'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Album.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['AlbumId', displayTextColumn];
    final albumsFuture = _obj._mnAlbum.toList(qparams);

    final data = await albumsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Album'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['AlbumId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Album]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `AlbumId` FROM Album WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> AlbumIdData = <int>[];
    qparams.selectColumns = ['AlbumId'];
    final AlbumIdFuture = await _obj._mnAlbum.toList(qparams);

    final int count = AlbumIdFuture.length;
    for (int i = 0; i < count; i++) {
      AlbumIdData.add(AlbumIdFuture[i]['AlbumId'] as int);
    }
    return AlbumIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Album]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnAlbum.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Album.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnAlbum.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AlbumFilterBuilder

// region AlbumFields
class AlbumFields {
  static TableField _fAlbumId;
  static TableField get AlbumId {
    return _fAlbumId =
        _fAlbumId ?? SqlSyntax.setField(_fAlbumId, 'albumid', DbType.integer);
  }

  static TableField _fTitle;
  static TableField get Title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'Title', DbType.text);
  }

  static TableField _fArtistId;
  static TableField get ArtistId {
    return _fArtistId = _fArtistId ??
        SqlSyntax.setField(_fArtistId, 'ArtistId', DbType.integer);
  }
}
// endregion AlbumFields

//region AlbumManager
class AlbumManager extends SqfEntityProvider {
  AlbumManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Album';
  static final List<String> _primaryKeyList = ['AlbumId'];
  static final String _whereStr = 'AlbumId=?';
}

//endregion AlbumManager
// region Artist
class Artist {
  Artist({this.ArtistId, this.Name}) {
    _setDefaultValues();
  }
  Artist.withFields(this.ArtistId, this.Name) {
    _setDefaultValues();
  }
  Artist.withId(this.ArtistId, this.Name) {
    _setDefaultValues();
  }
  Artist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArtistId = int.tryParse(o['ArtistId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (Artist)
  int ArtistId;
  String Name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Artist)

// COLLECTIONS & VIRTUALS (Artist)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAlbums', 'plField2'..]) or so on..
  List<Album> plAlbums;

  /// get Album(s) filtered by ArtistId=ArtistId
  AlbumFilterBuilder getAlbums(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (ArtistId == null) {
      return null;
    }
    return Album()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ArtistId
        .equals(ArtistId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Artist)

  static const bool _softDeleteActivated = false;
  ArtistManager __mnArtist;

  ArtistManager get _mnArtist {
    return __mnArtist = __mnArtist ?? ArtistManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (ArtistId != null) {
      map['ArtistId'] = ArtistId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (ArtistId != null) {
      map['ArtistId'] = ArtistId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

// COLLECTIONS (Artist)
    if (!forQuery) {
      map['Albums'] = await getAlbums().toMapList();
    }
// END COLLECTIONS (Artist)

    return map;
  }

  /// This method returns Json String [Artist]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Artist]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [ArtistId, Name];
  }

  List<dynamic> toArgsWithIds() {
    return [ArtistId, Name];
  }

  static Future<List<Artist>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Artist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Artist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Artist>[];
    try {
      objList = list
          .map((artist) => Artist.fromMap(artist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Artist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Artist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Artist> objList = <Artist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Artist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedFields.add('Artist.plAlbums'); */
          obj.plAlbums = obj.plAlbums ??
              await obj.getAlbums().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Artist by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int ArtistId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Artist if exist, otherwise returns null
  Future<Artist> getById(int ArtistId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (ArtistId == null) {
      return null;
    }
    Artist obj;
    final data = await _mnArtist.getById([ArtistId]);
    if (data.length != 0) {
      obj = Artist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedFields.add('Artist.plAlbums'); */
          obj.plAlbums = obj.plAlbums ??
              await obj.getAlbums().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Artist) object. If the ArtistId field is null, saves as a new record and returns new ArtistId, if ArtistId is not null then updates record

  /// <returns>Returns ArtistId
  Future<int> save() async {
    if (ArtistId == null || ArtistId == 0 || !isSaved) {
      await _mnArtist.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // ArtistId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnArtist.update(this);
    }

    return ArtistId;
  }

  /// saveAll method saves the sent List<Artist> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Artist> artists) async {
    // final results = _mnArtist.saveAll('INSERT OR REPLACE INTO Artist (ArtistId,Name)  VALUES (?,?)',artists);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in artists) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns ArtistId
  Future<int> upsert() async {
    try {
      if (await _mnArtist.rawInsert(
              'INSERT OR REPLACE INTO Artist (ArtistId,Name)  VALUES (?,?)',
              [ArtistId, Name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Artist ArtistId=$ArtistId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Artist ArtistId=$ArtistId did not update');
      }
      return ArtistId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Artist Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Artist>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Artist> artists) async {
    final results = await _mnArtist.rawInsertAll(
        'INSERT OR REPLACE INTO Artist (ArtistId,Name)  VALUES (?,?)', artists);
    return results;
  }

  /// Deletes Artist

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Artist invoked (ArtistId=$ArtistId)');
    if (await Album().select().ArtistId.equals(ArtistId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Album.ArtistId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnArtist.delete(
          QueryParams(whereString: 'ArtistId=?', whereArguments: [ArtistId]));
    } else {
      return _mnArtist.updateBatch(
          QueryParams(whereString: 'ArtistId=?', whereArguments: [ArtistId]),
          {'isDeleted': 1});
    }
  }

  ArtistFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ArtistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  ArtistFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return ArtistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion artist

// region ArtistField
class ArtistField extends SearchCriteria {
  ArtistField(this.artistFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  ArtistFilterBuilder artistFB;

  ArtistField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  ArtistFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param, SqlSyntax.EQuals,
            artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param, SqlSyntax.NotEQuals,
            artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.EQualsOrNull, artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder isNull() {
    artistFB._addedBlocks = setCriteria(
        0,
        artistFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      artistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          artistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          artistFB._addedBlocks);
      _waitingNot = '';
      artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
          artistFB._addedBlocks.retVal;
    }
    return artistFB;
  }

  ArtistFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      artistFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          artistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          artistFB._addedBlocks);
      _waitingNot = '';
      artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
          artistFB._addedBlocks.retVal;
      artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
          artistFB._addedBlocks.retVal;
    }
    return artistFB;
  }

  ArtistFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      artistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          artistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          artistFB._addedBlocks);
      _waitingNot = '';
      artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
          artistFB._addedBlocks.retVal;
    }
    return artistFB;
  }

  ArtistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      artistFB._addedBlocks = setCriteria(
          pFirst,
          artistFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          artistFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        artistFB._addedBlocks = setCriteria(pFirst, artistFB.parameters, param,
            SqlSyntax.LessThan, artistFB._addedBlocks);
      } else {
        artistFB._addedBlocks = setCriteria(pFirst, artistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, artistFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        artistFB._addedBlocks = setCriteria(pLast, artistFB.parameters, param,
            SqlSyntax.GreaterThan, artistFB._addedBlocks);
      } else {
        artistFB._addedBlocks = setCriteria(pLast, artistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, artistFB._addedBlocks);
      }
    }
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param, SqlSyntax.GreaterThan,
            artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param, SqlSyntax.LessThan,
            artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param, SqlSyntax.LessThan,
            artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    artistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, artistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, artistFB._addedBlocks)
        : setCriteria(pValue, artistFB.parameters, param, SqlSyntax.GreaterThan,
            artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }

  ArtistFilterBuilder inValues(dynamic pValue) {
    artistFB._addedBlocks = setCriteria(
        pValue,
        artistFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        artistFB._addedBlocks);
    _waitingNot = '';
    artistFB._addedBlocks.needEndBlock[artistFB._blockIndex] =
        artistFB._addedBlocks.retVal;
    return artistFB;
  }
}
// endregion ArtistField

// region ArtistFilterBuilder
class ArtistFilterBuilder extends SearchCriteria {
  ArtistFilterBuilder(Artist obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Artist _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  ArtistFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  ArtistFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  ArtistFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  ArtistFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  ArtistFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  ArtistFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  ArtistFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ArtistFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ArtistFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  ArtistFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  ArtistFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  ArtistField setField(ArtistField field, String colName, DbType dbtype) {
    return ArtistField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  ArtistField _ArtistId;
  ArtistField get ArtistId {
    return _ArtistId = setField(_ArtistId, 'ArtistId', DbType.integer);
  }

  ArtistField _Name;
  ArtistField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Artist._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Artist> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Album) according to DeleteRule.NO_ACTION

    final idListAlbumBYArtistId = toListPrimaryKeySQL(false);
    final resAlbumBYArtistId = await Album()
        .select()
        .where('ArtistId IN (${idListAlbumBYArtistId['sql']})',
            parameterValue: idListAlbumBYArtistId['args'])
        .toCount();
    if (resAlbumBYArtistId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Album.ArtistId)');
    }

    if (Artist._softDeleteActivated && !hardDelete) {
      r = await _obj._mnArtist.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnArtist.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'ArtistId IN (SELECT ArtistId from Artist ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnArtist.updateBatch(qparams, values);
  }

  /// This method always returns Artist Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Artist>
  Future<Artist> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnArtist.toList(qparams);
    final data = await objFuture;
    Artist obj;
    if (data.isNotEmpty) {
      obj = Artist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Artist.plAlbums') && */ (preloadFields ==
                null ||
            preloadFields.contains('plAlbums'))) {
          /*_loadedFields.add('Artist.plAlbums'); */
          obj.plAlbums = obj.plAlbums ??
              await obj.getAlbums().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Artist]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) artistCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final artistsFuture = await _obj._mnArtist.toList(qparams);
    final int count = artistsFuture[0]['CNT'] as int;
    if (artistCount != null) {
      artistCount(count);
    }
    return count;
  }

  /// This method returns List<Artist> [Artist]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Artist>
  Future<List<Artist>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Artist> artistsData = await Artist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return artistsData;
  }

  /// This method returns Json String [Artist]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Artist]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Artist]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnArtist.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Artist>>
  Future<List<DropdownMenuItem<Artist>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Artist>> o)
          dropDownMenu]) async {
    _buildParameters();
    final artistsFuture = _obj._mnArtist.toList(qparams);

    final data = await artistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Artist>> items = []..add(DropdownMenuItem(
        value: Artist(),
        child: Text('Select Artist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Artist.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['ArtistId', displayTextColumn];
    final artistsFuture = _obj._mnArtist.toList(qparams);

    final data = await artistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Artist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['ArtistId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Artist]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArtistId` FROM Artist WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> ArtistIdData = <int>[];
    qparams.selectColumns = ['ArtistId'];
    final ArtistIdFuture = await _obj._mnArtist.toList(qparams);

    final int count = ArtistIdFuture.length;
    for (int i = 0; i < count; i++) {
      ArtistIdData.add(ArtistIdFuture[i]['ArtistId'] as int);
    }
    return ArtistIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Artist]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnArtist.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Artist.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnArtist.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArtistFilterBuilder

// region ArtistFields
class ArtistFields {
  static TableField _fArtistId;
  static TableField get ArtistId {
    return _fArtistId = _fArtistId ??
        SqlSyntax.setField(_fArtistId, 'artistid', DbType.integer);
  }

  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion ArtistFields

//region ArtistManager
class ArtistManager extends SqfEntityProvider {
  ArtistManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Artist';
  static final List<String> _primaryKeyList = ['ArtistId'];
  static final String _whereStr = 'ArtistId=?';
}

//endregion ArtistManager
// region Customer
class Customer {
  Customer(
      {this.CustomerId,
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId}) {
    _setDefaultValues();
  }
  Customer.withFields(
      this.CustomerId,
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId) {
    _setDefaultValues();
  }
  Customer.withId(
      this.CustomerId,
      this.FirstName,
      this.LastName,
      this.Company,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.SupportRepId) {
    _setDefaultValues();
  }
  Customer.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CustomerId = int.tryParse(o['CustomerId'].toString());
    if (o['FirstName'] != null) {
      FirstName = o['FirstName'] as String;
    }
    if (o['LastName'] != null) {
      LastName = o['LastName'] as String;
    }
    if (o['Company'] != null) {
      Company = o['Company'] as String;
    }
    if (o['Address'] != null) {
      Address = o['Address'] as String;
    }
    if (o['City'] != null) {
      City = o['City'] as String;
    }
    if (o['State'] != null) {
      State = o['State'] as String;
    }
    if (o['Country'] != null) {
      Country = o['Country'] as String;
    }
    if (o['PostalCode'] != null) {
      PostalCode = o['PostalCode'] as String;
    }
    if (o['Phone'] != null) {
      Phone = o['Phone'] as String;
    }
    if (o['Fax'] != null) {
      Fax = o['Fax'] as String;
    }
    if (o['Email'] != null) {
      Email = o['Email'] as String;
    }
    SupportRepId = int.tryParse(o['SupportRepId'].toString());

    // RELATIONSHIPS FromMAP
    plEmployee = o['employee'] != null
        ? Employee.fromMap(o['employee'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Customer)
  int CustomerId;
  String FirstName;
  String LastName;
  String Company;
  String Address;
  String City;
  String State;
  String Country;
  String PostalCode;
  String Phone;
  String Fax;
  String Email;
  int SupportRepId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Customer)

// RELATIONSHIPS (Customer)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plEmployee', 'plField2'..]) or so on..
  Employee plEmployee;

  /// get Employee By SupportRepId
  Future<Employee> getEmployee(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Employee().getById(SupportRepId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Customer)

// COLLECTIONS & VIRTUALS (Customer)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plInvoices', 'plField2'..]) or so on..
  List<Invoice> plInvoices;

  /// get Invoice(s) filtered by CustomerId=CustomerId
  InvoiceFilterBuilder getInvoices(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (CustomerId == null) {
      return null;
    }
    return Invoice()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .CustomerId
        .equals(CustomerId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Customer)

  static const bool _softDeleteActivated = false;
  CustomerManager __mnCustomer;

  CustomerManager get _mnCustomer {
    return __mnCustomer = __mnCustomer ?? CustomerManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (CustomerId != null) {
      map['CustomerId'] = CustomerId;
    }
    if (FirstName != null) {
      map['FirstName'] = FirstName;
    }

    if (LastName != null) {
      map['LastName'] = LastName;
    }

    if (Company != null) {
      map['Company'] = Company;
    }

    if (Address != null) {
      map['Address'] = Address;
    }

    if (City != null) {
      map['City'] = City;
    }

    if (State != null) {
      map['State'] = State;
    }

    if (Country != null) {
      map['Country'] = Country;
    }

    if (PostalCode != null) {
      map['PostalCode'] = PostalCode;
    }

    if (Phone != null) {
      map['Phone'] = Phone;
    }

    if (Fax != null) {
      map['Fax'] = Fax;
    }

    if (Email != null) {
      map['Email'] = Email;
    }

    if (SupportRepId != null) {
      map['SupportRepId'] = forView ? plEmployee.LastName : SupportRepId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (CustomerId != null) {
      map['CustomerId'] = CustomerId;
    }
    if (FirstName != null) {
      map['FirstName'] = FirstName;
    }

    if (LastName != null) {
      map['LastName'] = LastName;
    }

    if (Company != null) {
      map['Company'] = Company;
    }

    if (Address != null) {
      map['Address'] = Address;
    }

    if (City != null) {
      map['City'] = City;
    }

    if (State != null) {
      map['State'] = State;
    }

    if (Country != null) {
      map['Country'] = Country;
    }

    if (PostalCode != null) {
      map['PostalCode'] = PostalCode;
    }

    if (Phone != null) {
      map['Phone'] = Phone;
    }

    if (Fax != null) {
      map['Fax'] = Fax;
    }

    if (Email != null) {
      map['Email'] = Email;
    }

    if (SupportRepId != null) {
      map['SupportRepId'] = forView ? plEmployee.LastName : SupportRepId;
    }

// COLLECTIONS (Customer)
    if (!forQuery) {
      map['Invoices'] = await getInvoices().toMapList();
    }
// END COLLECTIONS (Customer)

    return map;
  }

  /// This method returns Json String [Customer]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Customer]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      CustomerId,
      FirstName,
      LastName,
      Company,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      SupportRepId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      CustomerId,
      FirstName,
      LastName,
      Company,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      SupportRepId
    ];
  }

  static Future<List<Customer>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Customer.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Customer>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Customer>[];
    try {
      objList = list
          .map((customer) => Customer.fromMap(customer as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Customer.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Customer>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Customer> objList = <Customer>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Customer.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedFields.add('Customer.plInvoices'); */
          obj.plInvoices = obj.plInvoices ??
              await obj.getInvoices().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Customer by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int CustomerId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Customer if exist, otherwise returns null
  Future<Customer> getById(int CustomerId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (CustomerId == null) {
      return null;
    }
    Customer obj;
    final data = await _mnCustomer.getById([CustomerId]);
    if (data.length != 0) {
      obj = Customer.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedFields.add('Customer.plInvoices'); */
          obj.plInvoices = obj.plInvoices ??
              await obj.getInvoices().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Customer) object. If the CustomerId field is null, saves as a new record and returns new CustomerId, if CustomerId is not null then updates record

  /// <returns>Returns CustomerId
  Future<int> save() async {
    if (CustomerId == null || CustomerId == 0 || !isSaved) {
      await _mnCustomer.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // CustomerId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCustomer.update(this);
    }

    return CustomerId;
  }

  /// saveAll method saves the sent List<Customer> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Customer> customers) async {
    // final results = _mnCustomer.saveAll('INSERT OR REPLACE INTO Customer (CustomerId,FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',customers);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in customers) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns CustomerId
  Future<int> upsert() async {
    try {
      if (await _mnCustomer.rawInsert(
              'INSERT OR REPLACE INTO Customer (CustomerId,FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                CustomerId,
                FirstName,
                LastName,
                Company,
                Address,
                City,
                State,
                Country,
                PostalCode,
                Phone,
                Fax,
                Email,
                SupportRepId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Customer CustomerId=$CustomerId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Customer CustomerId=$CustomerId did not update');
      }
      return CustomerId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Customer Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Customer>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Customer> customers) async {
    final results = await _mnCustomer.rawInsertAll(
        'INSERT OR REPLACE INTO Customer (CustomerId,FirstName, LastName, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email, SupportRepId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        customers);
    return results;
  }

  /// Deletes Customer

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Customer invoked (CustomerId=$CustomerId)');
    if (await Invoice().select().CustomerId.equals(CustomerId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Invoice.CustomerId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnCustomer.delete(QueryParams(
          whereString: 'CustomerId=?', whereArguments: [CustomerId]));
    } else {
      return _mnCustomer.updateBatch(
          QueryParams(
              whereString: 'CustomerId=?', whereArguments: [CustomerId]),
          {'isDeleted': 1});
    }
  }

  CustomerFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return CustomerFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  CustomerFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return CustomerFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion customer

// region CustomerField
class CustomerField extends SearchCriteria {
  CustomerField(this.customerFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  CustomerFilterBuilder customerFB;

  CustomerField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  CustomerFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param, SqlSyntax.EQuals,
            customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param, SqlSyntax.NotEQuals,
            customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.EQualsOrNull, customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder isNull() {
    customerFB._addedBlocks = setCriteria(
        0,
        customerFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      customerFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          customerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          customerFB._addedBlocks);
      _waitingNot = '';
      customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
          customerFB._addedBlocks.retVal;
    }
    return customerFB;
  }

  CustomerFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      customerFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          customerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          customerFB._addedBlocks);
      _waitingNot = '';
      customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
          customerFB._addedBlocks.retVal;
      customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
          customerFB._addedBlocks.retVal;
    }
    return customerFB;
  }

  CustomerFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      customerFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          customerFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          customerFB._addedBlocks);
      _waitingNot = '';
      customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
          customerFB._addedBlocks.retVal;
    }
    return customerFB;
  }

  CustomerFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      customerFB._addedBlocks = setCriteria(
          pFirst,
          customerFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          customerFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        customerFB._addedBlocks = setCriteria(pFirst, customerFB.parameters,
            param, SqlSyntax.LessThan, customerFB._addedBlocks);
      } else {
        customerFB._addedBlocks = setCriteria(pFirst, customerFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, customerFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        customerFB._addedBlocks = setCriteria(pLast, customerFB.parameters,
            param, SqlSyntax.GreaterThan, customerFB._addedBlocks);
      } else {
        customerFB._addedBlocks = setCriteria(pLast, customerFB.parameters,
            param, SqlSyntax.LessThanOrEquals, customerFB._addedBlocks);
      }
    }
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.GreaterThan, customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.LessThanOrEquals, customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param, SqlSyntax.LessThan,
            customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param, SqlSyntax.LessThan,
            customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    customerFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.LessThanOrEquals, customerFB._addedBlocks)
        : setCriteria(pValue, customerFB.parameters, param,
            SqlSyntax.GreaterThan, customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }

  CustomerFilterBuilder inValues(dynamic pValue) {
    customerFB._addedBlocks = setCriteria(
        pValue,
        customerFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        customerFB._addedBlocks);
    _waitingNot = '';
    customerFB._addedBlocks.needEndBlock[customerFB._blockIndex] =
        customerFB._addedBlocks.retVal;
    return customerFB;
  }
}
// endregion CustomerField

// region CustomerFilterBuilder
class CustomerFilterBuilder extends SearchCriteria {
  CustomerFilterBuilder(Customer obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Customer _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  CustomerFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  CustomerFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  CustomerFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  CustomerFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  CustomerFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  CustomerFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  CustomerFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CustomerFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CustomerFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  CustomerFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  CustomerFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  CustomerField setField(CustomerField field, String colName, DbType dbtype) {
    return CustomerField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  CustomerField _CustomerId;
  CustomerField get CustomerId {
    return _CustomerId = setField(_CustomerId, 'CustomerId', DbType.integer);
  }

  CustomerField _FirstName;
  CustomerField get FirstName {
    return _FirstName = setField(_FirstName, 'FirstName', DbType.text);
  }

  CustomerField _LastName;
  CustomerField get LastName {
    return _LastName = setField(_LastName, 'LastName', DbType.text);
  }

  CustomerField _Company;
  CustomerField get Company {
    return _Company = setField(_Company, 'Company', DbType.text);
  }

  CustomerField _Address;
  CustomerField get Address {
    return _Address = setField(_Address, 'Address', DbType.text);
  }

  CustomerField _City;
  CustomerField get City {
    return _City = setField(_City, 'City', DbType.text);
  }

  CustomerField _State;
  CustomerField get State {
    return _State = setField(_State, 'State', DbType.text);
  }

  CustomerField _Country;
  CustomerField get Country {
    return _Country = setField(_Country, 'Country', DbType.text);
  }

  CustomerField _PostalCode;
  CustomerField get PostalCode {
    return _PostalCode = setField(_PostalCode, 'PostalCode', DbType.text);
  }

  CustomerField _Phone;
  CustomerField get Phone {
    return _Phone = setField(_Phone, 'Phone', DbType.text);
  }

  CustomerField _Fax;
  CustomerField get Fax {
    return _Fax = setField(_Fax, 'Fax', DbType.text);
  }

  CustomerField _Email;
  CustomerField get Email {
    return _Email = setField(_Email, 'Email', DbType.text);
  }

  CustomerField _SupportRepId;
  CustomerField get SupportRepId {
    return _SupportRepId =
        setField(_SupportRepId, 'SupportRepId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Customer._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Customer> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Invoice) according to DeleteRule.NO_ACTION

    final idListInvoiceBYCustomerId = toListPrimaryKeySQL(false);
    final resInvoiceBYCustomerId = await Invoice()
        .select()
        .where('CustomerId IN (${idListInvoiceBYCustomerId['sql']})',
            parameterValue: idListInvoiceBYCustomerId['args'])
        .toCount();
    if (resInvoiceBYCustomerId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Invoice.CustomerId)');
    }

    if (Customer._softDeleteActivated && !hardDelete) {
      r = await _obj._mnCustomer.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnCustomer.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'CustomerId IN (SELECT CustomerId from Customer ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnCustomer.updateBatch(qparams, values);
  }

  /// This method always returns Customer Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Customer>
  Future<Customer> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnCustomer.toList(qparams);
    final data = await objFuture;
    Customer obj;
    if (data.isNotEmpty) {
      obj = Customer.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plInvoices') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoices'))) {
          /*_loadedFields.add('Customer.plInvoices'); */
          obj.plInvoices = obj.plInvoices ??
              await obj.getInvoices().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Customer]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) customerCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final customersFuture = await _obj._mnCustomer.toList(qparams);
    final int count = customersFuture[0]['CNT'] as int;
    if (customerCount != null) {
      customerCount(count);
    }
    return count;
  }

  /// This method returns List<Customer> [Customer]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Customer>
  Future<List<Customer>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Customer> customersData = await Customer.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return customersData;
  }

  /// This method returns Json String [Customer]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Customer]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Customer]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnCustomer.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Customer>>
  Future<List<DropdownMenuItem<Customer>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Customer>> o)
          dropDownMenu]) async {
    _buildParameters();
    final customersFuture = _obj._mnCustomer.toList(qparams);

    final data = await customersFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Customer>> items = []..add(DropdownMenuItem(
        value: Customer(),
        child: Text('Select Customer'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Customer.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['CustomerId', displayTextColumn];
    final customersFuture = _obj._mnCustomer.toList(qparams);

    final data = await customersFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Customer'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['CustomerId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Customer]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CustomerId` FROM Customer WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> CustomerIdData = <int>[];
    qparams.selectColumns = ['CustomerId'];
    final CustomerIdFuture = await _obj._mnCustomer.toList(qparams);

    final int count = CustomerIdFuture.length;
    for (int i = 0; i < count; i++) {
      CustomerIdData.add(CustomerIdFuture[i]['CustomerId'] as int);
    }
    return CustomerIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Customer]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnCustomer.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Customer.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnCustomer.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CustomerFilterBuilder

// region CustomerFields
class CustomerFields {
  static TableField _fCustomerId;
  static TableField get CustomerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'customerid', DbType.integer);
  }

  static TableField _fFirstName;
  static TableField get FirstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'FirstName', DbType.text);
  }

  static TableField _fLastName;
  static TableField get LastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'LastName', DbType.text);
  }

  static TableField _fCompany;
  static TableField get Company {
    return _fCompany =
        _fCompany ?? SqlSyntax.setField(_fCompany, 'Company', DbType.text);
  }

  static TableField _fAddress;
  static TableField get Address {
    return _fAddress =
        _fAddress ?? SqlSyntax.setField(_fAddress, 'Address', DbType.text);
  }

  static TableField _fCity;
  static TableField get City {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'City', DbType.text);
  }

  static TableField _fState;
  static TableField get State {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'State', DbType.text);
  }

  static TableField _fCountry;
  static TableField get Country {
    return _fCountry =
        _fCountry ?? SqlSyntax.setField(_fCountry, 'Country', DbType.text);
  }

  static TableField _fPostalCode;
  static TableField get PostalCode {
    return _fPostalCode = _fPostalCode ??
        SqlSyntax.setField(_fPostalCode, 'PostalCode', DbType.text);
  }

  static TableField _fPhone;
  static TableField get Phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'Phone', DbType.text);
  }

  static TableField _fFax;
  static TableField get Fax {
    return _fFax = _fFax ?? SqlSyntax.setField(_fFax, 'Fax', DbType.text);
  }

  static TableField _fEmail;
  static TableField get Email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'Email', DbType.text);
  }

  static TableField _fSupportRepId;
  static TableField get SupportRepId {
    return _fSupportRepId = _fSupportRepId ??
        SqlSyntax.setField(_fSupportRepId, 'SupportRepId', DbType.integer);
  }
}
// endregion CustomerFields

//region CustomerManager
class CustomerManager extends SqfEntityProvider {
  CustomerManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Customer';
  static final List<String> _primaryKeyList = ['CustomerId'];
  static final String _whereStr = 'CustomerId=?';
}

//endregion CustomerManager
// region Employee
class Employee {
  Employee(
      {this.EmployeeId,
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo}) {
    _setDefaultValues();
  }
  Employee.withFields(
      this.EmployeeId,
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo) {
    _setDefaultValues();
  }
  Employee.withId(
      this.EmployeeId,
      this.LastName,
      this.FirstName,
      this.Title,
      this.BirthDate,
      this.HireDate,
      this.Address,
      this.City,
      this.State,
      this.Country,
      this.PostalCode,
      this.Phone,
      this.Fax,
      this.Email,
      this.ReportsTo) {
    _setDefaultValues();
  }
  Employee.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EmployeeId = int.tryParse(o['EmployeeId'].toString());
    if (o['LastName'] != null) {
      LastName = o['LastName'] as String;
    }
    if (o['FirstName'] != null) {
      FirstName = o['FirstName'] as String;
    }
    if (o['Title'] != null) {
      Title = o['Title'] as String;
    }
    if (o['BirthDate'] != null) {
      BirthDate = int.tryParse(o['BirthDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['BirthDate'].toString()))
          : DateTime.tryParse(o['BirthDate'].toString());
    }
    if (o['HireDate'] != null) {
      HireDate = int.tryParse(o['HireDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['HireDate'].toString()))
          : DateTime.tryParse(o['HireDate'].toString());
    }
    if (o['Address'] != null) {
      Address = o['Address'] as String;
    }
    if (o['City'] != null) {
      City = o['City'] as String;
    }
    if (o['State'] != null) {
      State = o['State'] as String;
    }
    if (o['Country'] != null) {
      Country = o['Country'] as String;
    }
    if (o['PostalCode'] != null) {
      PostalCode = o['PostalCode'] as String;
    }
    if (o['Phone'] != null) {
      Phone = o['Phone'] as String;
    }
    if (o['Fax'] != null) {
      Fax = o['Fax'] as String;
    }
    if (o['Email'] != null) {
      Email = o['Email'] as String;
    }
    ReportsTo = int.tryParse(o['ReportsTo'].toString());

    // RELATIONSHIPS FromMAP
    plEmployee = o['employee'] != null
        ? Employee.fromMap(o['employee'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Employee)
  int EmployeeId;
  String LastName;
  String FirstName;
  String Title;
  DateTime BirthDate;
  DateTime HireDate;
  String Address;
  String City;
  String State;
  String Country;
  String PostalCode;
  String Phone;
  String Fax;
  String Email;
  int ReportsTo;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Employee)

// RELATIONSHIPS (Employee)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plEmployee', 'plField2'..]) or so on..
  Employee plEmployee;

  /// get Employee By ReportsTo
  Future<Employee> getEmployee(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Employee().getById(ReportsTo,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Employee)

// COLLECTIONS & VIRTUALS (Employee)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plCustomers', 'plField2'..]) or so on..
  List<Customer> plCustomers;

  /// get Customer(s) filtered by EmployeeId=SupportRepId
  CustomerFilterBuilder getCustomers(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (EmployeeId == null) {
      return null;
    }
    return Customer()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .SupportRepId
        .equals(EmployeeId)
        .and;
  }

  /// (Relationship to itself) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plReportsTos', 'plField2'..]) or so on..
  List<Employee> plReportsTos;

  /// get Employee(s) filtered by EmployeeId=ReportsTo
  EmployeeFilterBuilder getReportsTos(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (EmployeeId == null) {
      return null;
    }
    return Employee()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .ReportsTo
        .equals(EmployeeId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Employee)

  static const bool _softDeleteActivated = false;
  EmployeeManager __mnEmployee;

  EmployeeManager get _mnEmployee {
    return __mnEmployee = __mnEmployee ?? EmployeeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (EmployeeId != null) {
      map['EmployeeId'] = EmployeeId;
    }
    if (LastName != null) {
      map['LastName'] = LastName;
    }

    if (FirstName != null) {
      map['FirstName'] = FirstName;
    }

    if (Title != null) {
      map['Title'] = Title;
    }

    if (BirthDate != null) {
      map['BirthDate'] = forJson
          ? BirthDate.toString()
          : forQuery ? BirthDate.millisecondsSinceEpoch : BirthDate;
    }

    if (HireDate != null) {
      map['HireDate'] = forJson
          ? HireDate.toString()
          : forQuery ? HireDate.millisecondsSinceEpoch : HireDate;
    }

    if (Address != null) {
      map['Address'] = Address;
    }

    if (City != null) {
      map['City'] = City;
    }

    if (State != null) {
      map['State'] = State;
    }

    if (Country != null) {
      map['Country'] = Country;
    }

    if (PostalCode != null) {
      map['PostalCode'] = PostalCode;
    }

    if (Phone != null) {
      map['Phone'] = Phone;
    }

    if (Fax != null) {
      map['Fax'] = Fax;
    }

    if (Email != null) {
      map['Email'] = Email;
    }

    if (ReportsTo != null) {
      map['ReportsTo'] = forView ? plEmployee.LastName : ReportsTo;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (EmployeeId != null) {
      map['EmployeeId'] = EmployeeId;
    }
    if (LastName != null) {
      map['LastName'] = LastName;
    }

    if (FirstName != null) {
      map['FirstName'] = FirstName;
    }

    if (Title != null) {
      map['Title'] = Title;
    }

    if (BirthDate != null) {
      map['BirthDate'] = forJson
          ? BirthDate.toString()
          : forQuery ? BirthDate.millisecondsSinceEpoch : BirthDate;
    }

    if (HireDate != null) {
      map['HireDate'] = forJson
          ? HireDate.toString()
          : forQuery ? HireDate.millisecondsSinceEpoch : HireDate;
    }

    if (Address != null) {
      map['Address'] = Address;
    }

    if (City != null) {
      map['City'] = City;
    }

    if (State != null) {
      map['State'] = State;
    }

    if (Country != null) {
      map['Country'] = Country;
    }

    if (PostalCode != null) {
      map['PostalCode'] = PostalCode;
    }

    if (Phone != null) {
      map['Phone'] = Phone;
    }

    if (Fax != null) {
      map['Fax'] = Fax;
    }

    if (Email != null) {
      map['Email'] = Email;
    }

    if (ReportsTo != null) {
      map['ReportsTo'] = forView ? plEmployee.LastName : ReportsTo;
    }

// COLLECTIONS (Employee)
    if (!forQuery) {
      map['Customers'] = await getCustomers().toMapList();
    }
    if (!forQuery) {
      map['ReportsTos'] = await getReportsTos().toMapList();
    }
// END COLLECTIONS (Employee)

    return map;
  }

  /// This method returns Json String [Employee]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Employee]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      EmployeeId,
      LastName,
      FirstName,
      Title,
      BirthDate != null ? BirthDate.millisecondsSinceEpoch : null,
      HireDate != null ? HireDate.millisecondsSinceEpoch : null,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      ReportsTo
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      EmployeeId,
      LastName,
      FirstName,
      Title,
      BirthDate != null ? BirthDate.millisecondsSinceEpoch : null,
      HireDate != null ? HireDate.millisecondsSinceEpoch : null,
      Address,
      City,
      State,
      Country,
      PostalCode,
      Phone,
      Fax,
      Email,
      ReportsTo
    ];
  }

  static Future<List<Employee>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Employee.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Employee>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Employee>[];
    try {
      objList = list
          .map((employee) => Employee.fromMap(employee as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Employee.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Employee>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Employee> objList = <Employee>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Employee.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedFields.add('Employee.plCustomers'); */
          obj.plCustomers = obj.plCustomers ??
              await obj.getCustomers().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedFields.add('Employee.plReportsTos'); */
          obj.plReportsTos = obj.plReportsTos ??
              await obj.getReportsTos().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Employee by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int EmployeeId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Employee if exist, otherwise returns null
  Future<Employee> getById(int EmployeeId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (EmployeeId == null) {
      return null;
    }
    Employee obj;
    final data = await _mnEmployee.getById([EmployeeId]);
    if (data.length != 0) {
      obj = Employee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedFields.add('Employee.plCustomers'); */
          obj.plCustomers = obj.plCustomers ??
              await obj.getCustomers().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedFields.add('Employee.plReportsTos'); */
          obj.plReportsTos = obj.plReportsTos ??
              await obj.getReportsTos().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Employee) object. If the EmployeeId field is null, saves as a new record and returns new EmployeeId, if EmployeeId is not null then updates record

  /// <returns>Returns EmployeeId
  Future<int> save() async {
    if (EmployeeId == null || EmployeeId == 0 || !isSaved) {
      await _mnEmployee.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // EmployeeId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnEmployee.update(this);
    }

    return EmployeeId;
  }

  /// saveAll method saves the sent List<Employee> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Employee> employees) async {
    // final results = _mnEmployee.saveAll('INSERT OR REPLACE INTO Employee (EmployeeId,LastName, FirstName, Title, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email, ReportsTo)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',employees);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in employees) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns EmployeeId
  Future<int> upsert() async {
    try {
      if (await _mnEmployee.rawInsert(
              'INSERT OR REPLACE INTO Employee (EmployeeId,LastName, FirstName, Title, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email, ReportsTo)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                EmployeeId,
                LastName,
                FirstName,
                Title,
                BirthDate != null ? BirthDate.millisecondsSinceEpoch : null,
                HireDate != null ? HireDate.millisecondsSinceEpoch : null,
                Address,
                City,
                State,
                Country,
                PostalCode,
                Phone,
                Fax,
                Email,
                ReportsTo
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Employee EmployeeId=$EmployeeId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Employee EmployeeId=$EmployeeId did not update');
      }
      return EmployeeId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Employee Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Employee>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Employee> employees) async {
    final results = await _mnEmployee.rawInsertAll(
        'INSERT OR REPLACE INTO Employee (EmployeeId,LastName, FirstName, Title, BirthDate, HireDate, Address, City, State, Country, PostalCode, Phone, Fax, Email, ReportsTo)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        employees);
    return results;
  }

  /// Deletes Employee

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Employee invoked (EmployeeId=$EmployeeId)');
    if (await Customer()
            .select()
            .SupportRepId
            .equals(EmployeeId)
            .and
            .toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Customer.SupportRepId)');
    }
    if (await Employee().select().ReportsTo.equals(EmployeeId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Employee.ReportsTo)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnEmployee.delete(QueryParams(
          whereString: 'EmployeeId=?', whereArguments: [EmployeeId]));
    } else {
      return _mnEmployee.updateBatch(
          QueryParams(
              whereString: 'EmployeeId=?', whereArguments: [EmployeeId]),
          {'isDeleted': 1});
    }
  }

  EmployeeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return EmployeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  EmployeeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return EmployeeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion employee

// region EmployeeField
class EmployeeField extends SearchCriteria {
  EmployeeField(this.employeeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  EmployeeFilterBuilder employeeFB;

  EmployeeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  EmployeeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param, SqlSyntax.EQuals,
            employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param, SqlSyntax.NotEQuals,
            employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.EQualsOrNull, employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder isNull() {
    employeeFB._addedBlocks = setCriteria(
        0,
        employeeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      employeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          employeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          employeeFB._addedBlocks);
      _waitingNot = '';
      employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
          employeeFB._addedBlocks.retVal;
    }
    return employeeFB;
  }

  EmployeeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      employeeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          employeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          employeeFB._addedBlocks);
      _waitingNot = '';
      employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
          employeeFB._addedBlocks.retVal;
      employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
          employeeFB._addedBlocks.retVal;
    }
    return employeeFB;
  }

  EmployeeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      employeeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          employeeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          employeeFB._addedBlocks);
      _waitingNot = '';
      employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
          employeeFB._addedBlocks.retVal;
    }
    return employeeFB;
  }

  EmployeeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      employeeFB._addedBlocks = setCriteria(
          pFirst,
          employeeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          employeeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        employeeFB._addedBlocks = setCriteria(pFirst, employeeFB.parameters,
            param, SqlSyntax.LessThan, employeeFB._addedBlocks);
      } else {
        employeeFB._addedBlocks = setCriteria(pFirst, employeeFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, employeeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        employeeFB._addedBlocks = setCriteria(pLast, employeeFB.parameters,
            param, SqlSyntax.GreaterThan, employeeFB._addedBlocks);
      } else {
        employeeFB._addedBlocks = setCriteria(pLast, employeeFB.parameters,
            param, SqlSyntax.LessThanOrEquals, employeeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.GreaterThan, employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param, SqlSyntax.LessThan,
            employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param, SqlSyntax.LessThan,
            employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    employeeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, employeeFB._addedBlocks)
        : setCriteria(pValue, employeeFB.parameters, param,
            SqlSyntax.GreaterThan, employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }

  EmployeeFilterBuilder inValues(dynamic pValue) {
    employeeFB._addedBlocks = setCriteria(
        pValue,
        employeeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        employeeFB._addedBlocks);
    _waitingNot = '';
    employeeFB._addedBlocks.needEndBlock[employeeFB._blockIndex] =
        employeeFB._addedBlocks.retVal;
    return employeeFB;
  }
}
// endregion EmployeeField

// region EmployeeFilterBuilder
class EmployeeFilterBuilder extends SearchCriteria {
  EmployeeFilterBuilder(Employee obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Employee _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  EmployeeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  EmployeeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  EmployeeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  EmployeeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  EmployeeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  EmployeeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  EmployeeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  EmployeeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  EmployeeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  EmployeeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  EmployeeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  EmployeeField setField(EmployeeField field, String colName, DbType dbtype) {
    return EmployeeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  EmployeeField _EmployeeId;
  EmployeeField get EmployeeId {
    return _EmployeeId = setField(_EmployeeId, 'EmployeeId', DbType.integer);
  }

  EmployeeField _LastName;
  EmployeeField get LastName {
    return _LastName = setField(_LastName, 'LastName', DbType.text);
  }

  EmployeeField _FirstName;
  EmployeeField get FirstName {
    return _FirstName = setField(_FirstName, 'FirstName', DbType.text);
  }

  EmployeeField _Title;
  EmployeeField get Title {
    return _Title = setField(_Title, 'Title', DbType.text);
  }

  EmployeeField _BirthDate;
  EmployeeField get BirthDate {
    return _BirthDate = setField(_BirthDate, 'BirthDate', DbType.datetime);
  }

  EmployeeField _HireDate;
  EmployeeField get HireDate {
    return _HireDate = setField(_HireDate, 'HireDate', DbType.datetime);
  }

  EmployeeField _Address;
  EmployeeField get Address {
    return _Address = setField(_Address, 'Address', DbType.text);
  }

  EmployeeField _City;
  EmployeeField get City {
    return _City = setField(_City, 'City', DbType.text);
  }

  EmployeeField _State;
  EmployeeField get State {
    return _State = setField(_State, 'State', DbType.text);
  }

  EmployeeField _Country;
  EmployeeField get Country {
    return _Country = setField(_Country, 'Country', DbType.text);
  }

  EmployeeField _PostalCode;
  EmployeeField get PostalCode {
    return _PostalCode = setField(_PostalCode, 'PostalCode', DbType.text);
  }

  EmployeeField _Phone;
  EmployeeField get Phone {
    return _Phone = setField(_Phone, 'Phone', DbType.text);
  }

  EmployeeField _Fax;
  EmployeeField get Fax {
    return _Fax = setField(_Fax, 'Fax', DbType.text);
  }

  EmployeeField _Email;
  EmployeeField get Email {
    return _Email = setField(_Email, 'Email', DbType.text);
  }

  EmployeeField _ReportsTo;
  EmployeeField get ReportsTo {
    return _ReportsTo = setField(_ReportsTo, 'ReportsTo', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Employee._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Employee> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Customer) according to DeleteRule.NO_ACTION

    final idListCustomerBYSupportRepId = toListPrimaryKeySQL(false);
    final resCustomerBYSupportRepId = await Customer()
        .select()
        .where('SupportRepId IN (${idListCustomerBYSupportRepId['sql']})',
            parameterValue: idListCustomerBYSupportRepId['args'])
        .toCount();
    if (resCustomerBYSupportRepId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Customer.SupportRepId)');
    }
// Check sub records where in (Employee) according to DeleteRule.NO_ACTION

    final idListEmployeeBYReportsTo = toListPrimaryKeySQL(false);
    final resEmployeeBYReportsTo = await Employee()
        .select()
        .where('ReportsTo IN (${idListEmployeeBYReportsTo['sql']})',
            parameterValue: idListEmployeeBYReportsTo['args'])
        .toCount();
    if (resEmployeeBYReportsTo > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Employee.ReportsTo)');
    }

    if (Employee._softDeleteActivated && !hardDelete) {
      r = await _obj._mnEmployee.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnEmployee.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'EmployeeId IN (SELECT EmployeeId from Employee ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnEmployee.updateBatch(qparams, values);
  }

  /// This method always returns Employee Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Employee>
  Future<Employee> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnEmployee.toList(qparams);
    final data = await objFuture;
    Employee obj;
    if (data.isNotEmpty) {
      obj = Employee.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plCustomers') && */ (preloadFields ==
                null ||
            preloadFields.contains('plCustomers'))) {
          /*_loadedFields.add('Employee.plCustomers'); */
          obj.plCustomers = obj.plCustomers ??
              await obj.getCustomers().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Employee.plReportsTos') && */ (preloadFields ==
                null ||
            preloadFields.contains('plReportsTos'))) {
          /*_loadedFields.add('Employee.plReportsTos'); */
          obj.plReportsTos = obj.plReportsTos ??
              await obj.getReportsTos().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Employee.plEmployee') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plEmployee'))) {
          /*_loadedFields.add('Employee.plEmployee');*/
          obj.plEmployee = obj.plEmployee ??
              await obj.getEmployee(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Employee]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) employeeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final employeesFuture = await _obj._mnEmployee.toList(qparams);
    final int count = employeesFuture[0]['CNT'] as int;
    if (employeeCount != null) {
      employeeCount(count);
    }
    return count;
  }

  /// This method returns List<Employee> [Employee]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Employee>
  Future<List<Employee>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Employee> employeesData = await Employee.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return employeesData;
  }

  /// This method returns Json String [Employee]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Employee]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Employee]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnEmployee.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Employee>>
  Future<List<DropdownMenuItem<Employee>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Employee>> o)
          dropDownMenu]) async {
    _buildParameters();
    final employeesFuture = _obj._mnEmployee.toList(qparams);

    final data = await employeesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Employee>> items = []..add(DropdownMenuItem(
        value: Employee(),
        child: Text('Select Employee'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Employee.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['EmployeeId', displayTextColumn];
    final employeesFuture = _obj._mnEmployee.toList(qparams);

    final data = await employeesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Employee'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['EmployeeId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Employee]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EmployeeId` FROM Employee WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> EmployeeIdData = <int>[];
    qparams.selectColumns = ['EmployeeId'];
    final EmployeeIdFuture = await _obj._mnEmployee.toList(qparams);

    final int count = EmployeeIdFuture.length;
    for (int i = 0; i < count; i++) {
      EmployeeIdData.add(EmployeeIdFuture[i]['EmployeeId'] as int);
    }
    return EmployeeIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Employee]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnEmployee.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Employee.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnEmployee.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EmployeeFilterBuilder

// region EmployeeFields
class EmployeeFields {
  static TableField _fEmployeeId;
  static TableField get EmployeeId {
    return _fEmployeeId = _fEmployeeId ??
        SqlSyntax.setField(_fEmployeeId, 'employeeid', DbType.integer);
  }

  static TableField _fLastName;
  static TableField get LastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'LastName', DbType.text);
  }

  static TableField _fFirstName;
  static TableField get FirstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'FirstName', DbType.text);
  }

  static TableField _fTitle;
  static TableField get Title {
    return _fTitle =
        _fTitle ?? SqlSyntax.setField(_fTitle, 'Title', DbType.text);
  }

  static TableField _fBirthDate;
  static TableField get BirthDate {
    return _fBirthDate = _fBirthDate ??
        SqlSyntax.setField(_fBirthDate, 'BirthDate', DbType.datetime);
  }

  static TableField _fHireDate;
  static TableField get HireDate {
    return _fHireDate = _fHireDate ??
        SqlSyntax.setField(_fHireDate, 'HireDate', DbType.datetime);
  }

  static TableField _fAddress;
  static TableField get Address {
    return _fAddress =
        _fAddress ?? SqlSyntax.setField(_fAddress, 'Address', DbType.text);
  }

  static TableField _fCity;
  static TableField get City {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'City', DbType.text);
  }

  static TableField _fState;
  static TableField get State {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'State', DbType.text);
  }

  static TableField _fCountry;
  static TableField get Country {
    return _fCountry =
        _fCountry ?? SqlSyntax.setField(_fCountry, 'Country', DbType.text);
  }

  static TableField _fPostalCode;
  static TableField get PostalCode {
    return _fPostalCode = _fPostalCode ??
        SqlSyntax.setField(_fPostalCode, 'PostalCode', DbType.text);
  }

  static TableField _fPhone;
  static TableField get Phone {
    return _fPhone =
        _fPhone ?? SqlSyntax.setField(_fPhone, 'Phone', DbType.text);
  }

  static TableField _fFax;
  static TableField get Fax {
    return _fFax = _fFax ?? SqlSyntax.setField(_fFax, 'Fax', DbType.text);
  }

  static TableField _fEmail;
  static TableField get Email {
    return _fEmail =
        _fEmail ?? SqlSyntax.setField(_fEmail, 'Email', DbType.text);
  }

  static TableField _fReportsTo;
  static TableField get ReportsTo {
    return _fReportsTo = _fReportsTo ??
        SqlSyntax.setField(_fReportsTo, 'ReportsTo', DbType.integer);
  }
}
// endregion EmployeeFields

//region EmployeeManager
class EmployeeManager extends SqfEntityProvider {
  EmployeeManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Employee';
  static final List<String> _primaryKeyList = ['EmployeeId'];
  static final String _whereStr = 'EmployeeId=?';
}

//endregion EmployeeManager
// region Genre
class Genre {
  Genre({this.GenreId, this.Name}) {
    _setDefaultValues();
  }
  Genre.withFields(this.GenreId, this.Name) {
    _setDefaultValues();
  }
  Genre.withId(this.GenreId, this.Name) {
    _setDefaultValues();
  }
  Genre.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    GenreId = int.tryParse(o['GenreId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (Genre)
  int GenreId;
  String Name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Genre)

// COLLECTIONS & VIRTUALS (Genre)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track> plTracks;

  /// get Track(s) filtered by GenreId=GenreId
  TrackFilterBuilder getTracks(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (GenreId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .GenreId
        .equals(GenreId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Genre)

  static const bool _softDeleteActivated = false;
  GenreManager __mnGenre;

  GenreManager get _mnGenre {
    return __mnGenre = __mnGenre ?? GenreManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (GenreId != null) {
      map['GenreId'] = GenreId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (GenreId != null) {
      map['GenreId'] = GenreId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

// COLLECTIONS (Genre)
    if (!forQuery) {
      map['Tracks'] = await getTracks().toMapList();
    }
// END COLLECTIONS (Genre)

    return map;
  }

  /// This method returns Json String [Genre]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Genre]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [GenreId, Name];
  }

  List<dynamic> toArgsWithIds() {
    return [GenreId, Name];
  }

  static Future<List<Genre>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Genre.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Genre>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Genre>[];
    try {
      objList = list
          .map((genre) => Genre.fromMap(genre as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Genre.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Genre>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Genre> objList = <Genre>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Genre.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Genre.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Genre by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int GenreId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Genre if exist, otherwise returns null
  Future<Genre> getById(int GenreId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (GenreId == null) {
      return null;
    }
    Genre obj;
    final data = await _mnGenre.getById([GenreId]);
    if (data.length != 0) {
      obj = Genre.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Genre.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Genre) object. If the GenreId field is null, saves as a new record and returns new GenreId, if GenreId is not null then updates record

  /// <returns>Returns GenreId
  Future<int> save() async {
    if (GenreId == null || GenreId == 0 || !isSaved) {
      await _mnGenre.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // GenreId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnGenre.update(this);
    }

    return GenreId;
  }

  /// saveAll method saves the sent List<Genre> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Genre> genres) async {
    // final results = _mnGenre.saveAll('INSERT OR REPLACE INTO Genre (GenreId,Name)  VALUES (?,?)',genres);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in genres) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns GenreId
  Future<int> upsert() async {
    try {
      if (await _mnGenre.rawInsert(
              'INSERT OR REPLACE INTO Genre (GenreId,Name)  VALUES (?,?)',
              [GenreId, Name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Genre GenreId=$GenreId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Genre GenreId=$GenreId did not update');
      }
      return GenreId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Genre Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Genre>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Genre> genres) async {
    final results = await _mnGenre.rawInsertAll(
        'INSERT OR REPLACE INTO Genre (GenreId,Name)  VALUES (?,?)', genres);
    return results;
  }

  /// Deletes Genre

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Genre invoked (GenreId=$GenreId)');
    if (await Track().select().GenreId.equals(GenreId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.GenreId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnGenre.delete(
          QueryParams(whereString: 'GenreId=?', whereArguments: [GenreId]));
    } else {
      return _mnGenre.updateBatch(
          QueryParams(whereString: 'GenreId=?', whereArguments: [GenreId]),
          {'isDeleted': 1});
    }
  }

  GenreFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return GenreFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  GenreFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return GenreFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion genre

// region GenreField
class GenreField extends SearchCriteria {
  GenreField(this.genreFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  GenreFilterBuilder genreFB;

  GenreField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  GenreFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param, SqlSyntax.EQuals,
            genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param, SqlSyntax.NotEQuals,
            genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param, SqlSyntax.EQualsOrNull,
            genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder isNull() {
    genreFB._addedBlocks = setCriteria(
        0,
        genreFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      genreFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          genreFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          genreFB._addedBlocks);
      _waitingNot = '';
      genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
          genreFB._addedBlocks.retVal;
    }
    return genreFB;
  }

  GenreFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      genreFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          genreFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          genreFB._addedBlocks);
      _waitingNot = '';
      genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
          genreFB._addedBlocks.retVal;
      genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
          genreFB._addedBlocks.retVal;
    }
    return genreFB;
  }

  GenreFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      genreFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          genreFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          genreFB._addedBlocks);
      _waitingNot = '';
      genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
          genreFB._addedBlocks.retVal;
    }
    return genreFB;
  }

  GenreFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      genreFB._addedBlocks = setCriteria(
          pFirst,
          genreFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          genreFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        genreFB._addedBlocks = setCriteria(pFirst, genreFB.parameters, param,
            SqlSyntax.LessThan, genreFB._addedBlocks);
      } else {
        genreFB._addedBlocks = setCriteria(pFirst, genreFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, genreFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        genreFB._addedBlocks = setCriteria(pLast, genreFB.parameters, param,
            SqlSyntax.GreaterThan, genreFB._addedBlocks);
      } else {
        genreFB._addedBlocks = setCriteria(pLast, genreFB.parameters, param,
            SqlSyntax.LessThanOrEquals, genreFB._addedBlocks);
      }
    }
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param, SqlSyntax.GreaterThan,
            genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param,
            SqlSyntax.LessThanOrEquals, genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param, SqlSyntax.LessThan,
            genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param, SqlSyntax.LessThan,
            genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    genreFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, genreFB.parameters, param,
            SqlSyntax.LessThanOrEquals, genreFB._addedBlocks)
        : setCriteria(pValue, genreFB.parameters, param, SqlSyntax.GreaterThan,
            genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }

  GenreFilterBuilder inValues(dynamic pValue) {
    genreFB._addedBlocks = setCriteria(
        pValue,
        genreFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        genreFB._addedBlocks);
    _waitingNot = '';
    genreFB._addedBlocks.needEndBlock[genreFB._blockIndex] =
        genreFB._addedBlocks.retVal;
    return genreFB;
  }
}
// endregion GenreField

// region GenreFilterBuilder
class GenreFilterBuilder extends SearchCriteria {
  GenreFilterBuilder(Genre obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Genre _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  GenreFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  GenreFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  GenreFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  GenreFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  GenreFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  GenreFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  GenreFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  GenreFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  GenreFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  GenreFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  GenreFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  GenreField setField(GenreField field, String colName, DbType dbtype) {
    return GenreField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  GenreField _GenreId;
  GenreField get GenreId {
    return _GenreId = setField(_GenreId, 'GenreId', DbType.integer);
  }

  GenreField _Name;
  GenreField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Genre._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Genre> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYGenreId = toListPrimaryKeySQL(false);
    final resTrackBYGenreId = await Track()
        .select()
        .where('GenreId IN (${idListTrackBYGenreId['sql']})',
            parameterValue: idListTrackBYGenreId['args'])
        .toCount();
    if (resTrackBYGenreId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.GenreId)');
    }

    if (Genre._softDeleteActivated && !hardDelete) {
      r = await _obj._mnGenre.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnGenre.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'GenreId IN (SELECT GenreId from Genre ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnGenre.updateBatch(qparams, values);
  }

  /// This method always returns Genre Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Genre>
  Future<Genre> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnGenre.toList(qparams);
    final data = await objFuture;
    Genre obj;
    if (data.isNotEmpty) {
      obj = Genre.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Genre.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Genre.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Genre]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) genreCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final genresFuture = await _obj._mnGenre.toList(qparams);
    final int count = genresFuture[0]['CNT'] as int;
    if (genreCount != null) {
      genreCount(count);
    }
    return count;
  }

  /// This method returns List<Genre> [Genre]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Genre>
  Future<List<Genre>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Genre> genresData = await Genre.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return genresData;
  }

  /// This method returns Json String [Genre]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Genre]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Genre]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnGenre.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Genre>>
  Future<List<DropdownMenuItem<Genre>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Genre>> o)
          dropDownMenu]) async {
    _buildParameters();
    final genresFuture = _obj._mnGenre.toList(qparams);

    final data = await genresFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Genre>> items = []..add(DropdownMenuItem(
        value: Genre(),
        child: Text('Select Genre'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Genre.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['GenreId', displayTextColumn];
    final genresFuture = _obj._mnGenre.toList(qparams);

    final data = await genresFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Genre'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['GenreId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Genre]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `GenreId` FROM Genre WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> GenreIdData = <int>[];
    qparams.selectColumns = ['GenreId'];
    final GenreIdFuture = await _obj._mnGenre.toList(qparams);

    final int count = GenreIdFuture.length;
    for (int i = 0; i < count; i++) {
      GenreIdData.add(GenreIdFuture[i]['GenreId'] as int);
    }
    return GenreIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Genre]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnGenre.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Genre.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnGenre.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion GenreFilterBuilder

// region GenreFields
class GenreFields {
  static TableField _fGenreId;
  static TableField get GenreId {
    return _fGenreId =
        _fGenreId ?? SqlSyntax.setField(_fGenreId, 'genreid', DbType.integer);
  }

  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion GenreFields

//region GenreManager
class GenreManager extends SqfEntityProvider {
  GenreManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Genre';
  static final List<String> _primaryKeyList = ['GenreId'];
  static final String _whereStr = 'GenreId=?';
}

//endregion GenreManager
// region Invoice
class Invoice {
  Invoice(
      {this.InvoiceId,
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId}) {
    _setDefaultValues();
  }
  Invoice.withFields(
      this.InvoiceId,
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId) {
    _setDefaultValues();
  }
  Invoice.withId(
      this.InvoiceId,
      this.InvoiceDate,
      this.BillingAddress,
      this.BillingCity,
      this.BillingState,
      this.BillingCountry,
      this.BillingPostalCode,
      this.Total,
      this.CustomerId) {
    _setDefaultValues();
  }
  Invoice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InvoiceId = int.tryParse(o['InvoiceId'].toString());
    if (o['InvoiceDate'] != null) {
      InvoiceDate = int.tryParse(o['InvoiceDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['InvoiceDate'].toString()))
          : DateTime.tryParse(o['InvoiceDate'].toString());
    }
    if (o['BillingAddress'] != null) {
      BillingAddress = o['BillingAddress'] as String;
    }
    if (o['BillingCity'] != null) {
      BillingCity = o['BillingCity'] as String;
    }
    if (o['BillingState'] != null) {
      BillingState = o['BillingState'] as String;
    }
    if (o['BillingCountry'] != null) {
      BillingCountry = o['BillingCountry'] as String;
    }
    if (o['BillingPostalCode'] != null) {
      BillingPostalCode = o['BillingPostalCode'] as String;
    }
    if (o['Total'] != null) {
      Total = double.tryParse(o['Total'].toString());
    }
    CustomerId = int.tryParse(o['CustomerId'].toString());

    // RELATIONSHIPS FromMAP
    plCustomer = o['customer'] != null
        ? Customer.fromMap(o['customer'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Invoice)
  int InvoiceId;
  DateTime InvoiceDate;
  String BillingAddress;
  String BillingCity;
  String BillingState;
  String BillingCountry;
  String BillingPostalCode;
  double Total;
  int CustomerId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Invoice)

// RELATIONSHIPS (Invoice)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plCustomer', 'plField2'..]) or so on..
  Customer plCustomer;

  /// get Customer By CustomerId
  Future<Customer> getCustomer(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Customer().getById(CustomerId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Invoice)

// COLLECTIONS & VIRTUALS (Invoice)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plInvoiceLines', 'plField2'..]) or so on..
  List<InvoiceLine> plInvoiceLines;

  /// get InvoiceLine(s) filtered by InvoiceId=InvoiceId
  InvoiceLineFilterBuilder getInvoiceLines(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (InvoiceId == null) {
      return null;
    }
    return InvoiceLine()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .InvoiceId
        .equals(InvoiceId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Invoice)

  static const bool _softDeleteActivated = false;
  InvoiceManager __mnInvoice;

  InvoiceManager get _mnInvoice {
    return __mnInvoice = __mnInvoice ?? InvoiceManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (InvoiceId != null) {
      map['InvoiceId'] = InvoiceId;
    }
    if (InvoiceDate != null) {
      map['InvoiceDate'] = forJson
          ? InvoiceDate.toString()
          : forQuery ? InvoiceDate.millisecondsSinceEpoch : InvoiceDate;
    }

    if (BillingAddress != null) {
      map['BillingAddress'] = BillingAddress;
    }

    if (BillingCity != null) {
      map['BillingCity'] = BillingCity;
    }

    if (BillingState != null) {
      map['BillingState'] = BillingState;
    }

    if (BillingCountry != null) {
      map['BillingCountry'] = BillingCountry;
    }

    if (BillingPostalCode != null) {
      map['BillingPostalCode'] = BillingPostalCode;
    }

    if (Total != null) {
      map['Total'] = Total;
    }

    if (CustomerId != null) {
      map['CustomerId'] = forView ? plCustomer.FirstName : CustomerId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (InvoiceId != null) {
      map['InvoiceId'] = InvoiceId;
    }
    if (InvoiceDate != null) {
      map['InvoiceDate'] = forJson
          ? InvoiceDate.toString()
          : forQuery ? InvoiceDate.millisecondsSinceEpoch : InvoiceDate;
    }

    if (BillingAddress != null) {
      map['BillingAddress'] = BillingAddress;
    }

    if (BillingCity != null) {
      map['BillingCity'] = BillingCity;
    }

    if (BillingState != null) {
      map['BillingState'] = BillingState;
    }

    if (BillingCountry != null) {
      map['BillingCountry'] = BillingCountry;
    }

    if (BillingPostalCode != null) {
      map['BillingPostalCode'] = BillingPostalCode;
    }

    if (Total != null) {
      map['Total'] = Total;
    }

    if (CustomerId != null) {
      map['CustomerId'] = forView ? plCustomer.FirstName : CustomerId;
    }

// COLLECTIONS (Invoice)
    if (!forQuery) {
      map['InvoiceLines'] = await getInvoiceLines().toMapList();
    }
// END COLLECTIONS (Invoice)

    return map;
  }

  /// This method returns Json String [Invoice]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Invoice]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      InvoiceId,
      InvoiceDate,
      BillingAddress,
      BillingCity,
      BillingState,
      BillingCountry,
      BillingPostalCode,
      Total,
      CustomerId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      InvoiceId,
      InvoiceDate,
      BillingAddress,
      BillingCity,
      BillingState,
      BillingCountry,
      BillingPostalCode,
      Total,
      CustomerId
    ];
  }

  static Future<List<Invoice>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Invoice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Invoice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Invoice>[];
    try {
      objList = list
          .map((invoice) => Invoice.fromMap(invoice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Invoice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Invoice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Invoice> objList = <Invoice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Invoice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Invoice.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plCustomer') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          /*_loadedFields.add('Customer.plCustomer');*/
          obj.plCustomer = obj.plCustomer ??
              await obj.getCustomer(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Invoice by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int InvoiceId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Invoice if exist, otherwise returns null
  Future<Invoice> getById(int InvoiceId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (InvoiceId == null) {
      return null;
    }
    Invoice obj;
    final data = await _mnInvoice.getById([InvoiceId]);
    if (data.length != 0) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Invoice.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plCustomer') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          /*_loadedFields.add('Customer.plCustomer');*/
          obj.plCustomer = obj.plCustomer ??
              await obj.getCustomer(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Invoice) object. If the InvoiceId field is null, saves as a new record and returns new InvoiceId, if InvoiceId is not null then updates record

  /// <returns>Returns InvoiceId
  Future<int> save() async {
    if (InvoiceId == null || InvoiceId == 0 || !isSaved) {
      await _mnInvoice.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // InvoiceId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoice.update(this);
    }

    return InvoiceId;
  }

  /// saveAll method saves the sent List<Invoice> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Invoice> invoices) async {
    // final results = _mnInvoice.saveAll('INSERT OR REPLACE INTO Invoice (InvoiceId,InvoiceDate, BillingAddress, BillingCity, BillingState, BillingCountry, BillingPostalCode, Total, CustomerId)  VALUES (?,?,?,?,?,?,?,?,?)',invoices);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in invoices) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns InvoiceId
  Future<int> upsert() async {
    try {
      if (await _mnInvoice.rawInsert(
              'INSERT OR REPLACE INTO Invoice (InvoiceId,InvoiceDate, BillingAddress, BillingCity, BillingState, BillingCountry, BillingPostalCode, Total, CustomerId)  VALUES (?,?,?,?,?,?,?,?,?)',
              [
                InvoiceId,
                InvoiceDate,
                BillingAddress,
                BillingCity,
                BillingState,
                BillingCountry,
                BillingPostalCode,
                Total,
                CustomerId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Invoice InvoiceId=$InvoiceId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Invoice InvoiceId=$InvoiceId did not update');
      }
      return InvoiceId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Invoice Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Invoice>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Invoice> invoices) async {
    final results = await _mnInvoice.rawInsertAll(
        'INSERT OR REPLACE INTO Invoice (InvoiceId,InvoiceDate, BillingAddress, BillingCity, BillingState, BillingCountry, BillingPostalCode, Total, CustomerId)  VALUES (?,?,?,?,?,?,?,?,?)',
        invoices);
    return results;
  }

  /// Deletes Invoice

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Invoice invoked (InvoiceId=$InvoiceId)');
    if (await InvoiceLine().select().InvoiceId.equals(InvoiceId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.InvoiceId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnInvoice.delete(
          QueryParams(whereString: 'InvoiceId=?', whereArguments: [InvoiceId]));
    } else {
      return _mnInvoice.updateBatch(
          QueryParams(whereString: 'InvoiceId=?', whereArguments: [InvoiceId]),
          {'isDeleted': 1});
    }
  }

  InvoiceFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return InvoiceFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  InvoiceFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return InvoiceFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion invoice

// region InvoiceField
class InvoiceField extends SearchCriteria {
  InvoiceField(this.invoiceFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  InvoiceFilterBuilder invoiceFB;

  InvoiceField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  InvoiceFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param, SqlSyntax.EQuals,
            invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param, SqlSyntax.NotEQuals,
            invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.EQualsOrNull, invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder isNull() {
    invoiceFB._addedBlocks = setCriteria(
        0,
        invoiceFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      invoiceFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          invoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoiceFB._addedBlocks);
      _waitingNot = '';
      invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
          invoiceFB._addedBlocks.retVal;
    }
    return invoiceFB;
  }

  InvoiceFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      invoiceFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          invoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoiceFB._addedBlocks);
      _waitingNot = '';
      invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
          invoiceFB._addedBlocks.retVal;
      invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
          invoiceFB._addedBlocks.retVal;
    }
    return invoiceFB;
  }

  InvoiceFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      invoiceFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          invoiceFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoiceFB._addedBlocks);
      _waitingNot = '';
      invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
          invoiceFB._addedBlocks.retVal;
    }
    return invoiceFB;
  }

  InvoiceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      invoiceFB._addedBlocks = setCriteria(
          pFirst,
          invoiceFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoiceFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        invoiceFB._addedBlocks = setCriteria(pFirst, invoiceFB.parameters,
            param, SqlSyntax.LessThan, invoiceFB._addedBlocks);
      } else {
        invoiceFB._addedBlocks = setCriteria(pFirst, invoiceFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, invoiceFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        invoiceFB._addedBlocks = setCriteria(pLast, invoiceFB.parameters, param,
            SqlSyntax.GreaterThan, invoiceFB._addedBlocks);
      } else {
        invoiceFB._addedBlocks = setCriteria(pLast, invoiceFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoiceFB._addedBlocks);
      }
    }
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.GreaterThan, invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param, SqlSyntax.LessThan,
            invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param, SqlSyntax.LessThan,
            invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    invoiceFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoiceFB._addedBlocks)
        : setCriteria(pValue, invoiceFB.parameters, param,
            SqlSyntax.GreaterThan, invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }

  InvoiceFilterBuilder inValues(dynamic pValue) {
    invoiceFB._addedBlocks = setCriteria(
        pValue,
        invoiceFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoiceFB._addedBlocks);
    _waitingNot = '';
    invoiceFB._addedBlocks.needEndBlock[invoiceFB._blockIndex] =
        invoiceFB._addedBlocks.retVal;
    return invoiceFB;
  }
}
// endregion InvoiceField

// region InvoiceFilterBuilder
class InvoiceFilterBuilder extends SearchCriteria {
  InvoiceFilterBuilder(Invoice obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Invoice _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  InvoiceFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  InvoiceFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  InvoiceFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  InvoiceFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  InvoiceFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  InvoiceFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  InvoiceFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  InvoiceField setField(InvoiceField field, String colName, DbType dbtype) {
    return InvoiceField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  InvoiceField _InvoiceId;
  InvoiceField get InvoiceId {
    return _InvoiceId = setField(_InvoiceId, 'InvoiceId', DbType.integer);
  }

  InvoiceField _InvoiceDate;
  InvoiceField get InvoiceDate {
    return _InvoiceDate =
        setField(_InvoiceDate, 'InvoiceDate', DbType.datetime);
  }

  InvoiceField _BillingAddress;
  InvoiceField get BillingAddress {
    return _BillingAddress =
        setField(_BillingAddress, 'BillingAddress', DbType.text);
  }

  InvoiceField _BillingCity;
  InvoiceField get BillingCity {
    return _BillingCity = setField(_BillingCity, 'BillingCity', DbType.text);
  }

  InvoiceField _BillingState;
  InvoiceField get BillingState {
    return _BillingState = setField(_BillingState, 'BillingState', DbType.text);
  }

  InvoiceField _BillingCountry;
  InvoiceField get BillingCountry {
    return _BillingCountry =
        setField(_BillingCountry, 'BillingCountry', DbType.text);
  }

  InvoiceField _BillingPostalCode;
  InvoiceField get BillingPostalCode {
    return _BillingPostalCode =
        setField(_BillingPostalCode, 'BillingPostalCode', DbType.text);
  }

  InvoiceField _Total;
  InvoiceField get Total {
    return _Total = setField(_Total, 'Total', DbType.real);
  }

  InvoiceField _CustomerId;
  InvoiceField get CustomerId {
    return _CustomerId = setField(_CustomerId, 'CustomerId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Invoice._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Invoice> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (InvoiceLine) according to DeleteRule.NO_ACTION

    final idListInvoiceLineBYInvoiceId = toListPrimaryKeySQL(false);
    final resInvoiceLineBYInvoiceId = await InvoiceLine()
        .select()
        .where('InvoiceId IN (${idListInvoiceLineBYInvoiceId['sql']})',
            parameterValue: idListInvoiceLineBYInvoiceId['args'])
        .toCount();
    if (resInvoiceLineBYInvoiceId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.InvoiceId)');
    }

    if (Invoice._softDeleteActivated && !hardDelete) {
      r = await _obj._mnInvoice.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnInvoice.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'InvoiceId IN (SELECT InvoiceId from Invoice ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnInvoice.updateBatch(qparams, values);
  }

  /// This method always returns Invoice Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Invoice>
  Future<Invoice> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnInvoice.toList(qparams);
    final data = await objFuture;
    Invoice obj;
    if (data.isNotEmpty) {
      obj = Invoice.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Invoice.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Invoice.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Customer.plCustomer') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plCustomer'))) {
          /*_loadedFields.add('Customer.plCustomer');*/
          obj.plCustomer = obj.plCustomer ??
              await obj.getCustomer(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Invoice]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) invoiceCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicesFuture = await _obj._mnInvoice.toList(qparams);
    final int count = invoicesFuture[0]['CNT'] as int;
    if (invoiceCount != null) {
      invoiceCount(count);
    }
    return count;
  }

  /// This method returns List<Invoice> [Invoice]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Invoice>
  Future<List<Invoice>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Invoice> invoicesData = await Invoice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return invoicesData;
  }

  /// This method returns Json String [Invoice]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Invoice]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Invoice]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnInvoice.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Invoice>>
  Future<List<DropdownMenuItem<Invoice>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Invoice>> o)
          dropDownMenu]) async {
    _buildParameters();
    final invoicesFuture = _obj._mnInvoice.toList(qparams);

    final data = await invoicesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Invoice>> items = []..add(DropdownMenuItem(
        value: Invoice(),
        child: Text('Select Invoice'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Invoice.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['InvoiceId', displayTextColumn];
    final invoicesFuture = _obj._mnInvoice.toList(qparams);

    final data = await invoicesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Invoice'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['InvoiceId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Invoice]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InvoiceId` FROM Invoice WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> InvoiceIdData = <int>[];
    qparams.selectColumns = ['InvoiceId'];
    final InvoiceIdFuture = await _obj._mnInvoice.toList(qparams);

    final int count = InvoiceIdFuture.length;
    for (int i = 0; i < count; i++) {
      InvoiceIdData.add(InvoiceIdFuture[i]['InvoiceId'] as int);
    }
    return InvoiceIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Invoice]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnInvoice.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Invoice.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnInvoice.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceFilterBuilder

// region InvoiceFields
class InvoiceFields {
  static TableField _fInvoiceId;
  static TableField get InvoiceId {
    return _fInvoiceId = _fInvoiceId ??
        SqlSyntax.setField(_fInvoiceId, 'invoiceid', DbType.integer);
  }

  static TableField _fInvoiceDate;
  static TableField get InvoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'InvoiceDate', DbType.datetime);
  }

  static TableField _fBillingAddress;
  static TableField get BillingAddress {
    return _fBillingAddress = _fBillingAddress ??
        SqlSyntax.setField(_fBillingAddress, 'BillingAddress', DbType.text);
  }

  static TableField _fBillingCity;
  static TableField get BillingCity {
    return _fBillingCity = _fBillingCity ??
        SqlSyntax.setField(_fBillingCity, 'BillingCity', DbType.text);
  }

  static TableField _fBillingState;
  static TableField get BillingState {
    return _fBillingState = _fBillingState ??
        SqlSyntax.setField(_fBillingState, 'BillingState', DbType.text);
  }

  static TableField _fBillingCountry;
  static TableField get BillingCountry {
    return _fBillingCountry = _fBillingCountry ??
        SqlSyntax.setField(_fBillingCountry, 'BillingCountry', DbType.text);
  }

  static TableField _fBillingPostalCode;
  static TableField get BillingPostalCode {
    return _fBillingPostalCode = _fBillingPostalCode ??
        SqlSyntax.setField(
            _fBillingPostalCode, 'BillingPostalCode', DbType.text);
  }

  static TableField _fTotal;
  static TableField get Total {
    return _fTotal =
        _fTotal ?? SqlSyntax.setField(_fTotal, 'Total', DbType.real);
  }

  static TableField _fCustomerId;
  static TableField get CustomerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'CustomerId', DbType.integer);
  }
}
// endregion InvoiceFields

//region InvoiceManager
class InvoiceManager extends SqfEntityProvider {
  InvoiceManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Invoice';
  static final List<String> _primaryKeyList = ['InvoiceId'];
  static final String _whereStr = 'InvoiceId=?';
}

//endregion InvoiceManager
// region InvoiceLine
class InvoiceLine {
  InvoiceLine(
      {this.InvoiceLineId,
      this.UnitPrice,
      this.Quantity,
      this.TrackId,
      this.InvoiceId}) {
    _setDefaultValues();
  }
  InvoiceLine.withFields(this.InvoiceLineId, this.UnitPrice, this.Quantity,
      this.TrackId, this.InvoiceId) {
    _setDefaultValues();
  }
  InvoiceLine.withId(this.InvoiceLineId, this.UnitPrice, this.Quantity,
      this.TrackId, this.InvoiceId) {
    _setDefaultValues();
  }
  InvoiceLine.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InvoiceLineId = int.tryParse(o['InvoiceLineId'].toString());
    if (o['UnitPrice'] != null) {
      UnitPrice = double.tryParse(o['UnitPrice'].toString());
    }
    if (o['Quantity'] != null) {
      Quantity = int.tryParse(o['Quantity'].toString());
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    InvoiceId = int.tryParse(o['InvoiceId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    plInvoice = o['invoice'] != null
        ? Invoice.fromMap(o['invoice'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (InvoiceLine)
  int InvoiceLineId;
  double UnitPrice;
  int Quantity;
  int TrackId;
  int InvoiceId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (InvoiceLine)

// RELATIONSHIPS (InvoiceLine)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track plTrack;

  /// get Track By TrackId
  Future<Track> getTrack(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plInvoice', 'plField2'..]) or so on..
  Invoice plInvoice;

  /// get Invoice By InvoiceId
  Future<Invoice> getInvoice(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Invoice().getById(InvoiceId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (InvoiceLine)

  static const bool _softDeleteActivated = false;
  InvoiceLineManager __mnInvoiceLine;

  InvoiceLineManager get _mnInvoiceLine {
    return __mnInvoiceLine = __mnInvoiceLine ?? InvoiceLineManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (InvoiceLineId != null) {
      map['InvoiceLineId'] = InvoiceLineId;
    }
    if (UnitPrice != null) {
      map['UnitPrice'] = UnitPrice;
    }

    if (Quantity != null) {
      map['Quantity'] = Quantity;
    }

    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    if (InvoiceId != null) {
      map['InvoiceId'] = forView ? plInvoice.BillingAddress : InvoiceId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (InvoiceLineId != null) {
      map['InvoiceLineId'] = InvoiceLineId;
    }
    if (UnitPrice != null) {
      map['UnitPrice'] = UnitPrice;
    }

    if (Quantity != null) {
      map['Quantity'] = Quantity;
    }

    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    if (InvoiceId != null) {
      map['InvoiceId'] = forView ? plInvoice.BillingAddress : InvoiceId;
    }

    return map;
  }

  /// This method returns Json String [InvoiceLine]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InvoiceLine]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId];
  }

  List<dynamic> toArgsWithIds() {
    return [InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId];
  }

  static Future<List<InvoiceLine>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR InvoiceLine.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<InvoiceLine>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InvoiceLine>[];
    try {
      objList = list
          .map((invoiceline) =>
              InvoiceLine.fromMap(invoiceline as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR InvoiceLine.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InvoiceLine>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<InvoiceLine> objList = <InvoiceLine>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InvoiceLine.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Invoice.plInvoice') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          /*_loadedFields.add('Invoice.plInvoice');*/
          obj.plInvoice = obj.plInvoice ??
              await obj.getInvoice(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns InvoiceLine by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int InvoiceLineId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns InvoiceLine if exist, otherwise returns null
  Future<InvoiceLine> getById(int InvoiceLineId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (InvoiceLineId == null) {
      return null;
    }
    InvoiceLine obj;
    final data = await _mnInvoiceLine.getById([InvoiceLineId]);
    if (data.length != 0) {
      obj = InvoiceLine.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Invoice.plInvoice') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          /*_loadedFields.add('Invoice.plInvoice');*/
          obj.plInvoice = obj.plInvoice ??
              await obj.getInvoice(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InvoiceLine) object. If the InvoiceLineId field is null, saves as a new record and returns new InvoiceLineId, if InvoiceLineId is not null then updates record

  /// <returns>Returns InvoiceLineId
  Future<int> save() async {
    if (InvoiceLineId == null || InvoiceLineId == 0 || !isSaved) {
      await _mnInvoiceLine.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // InvoiceLineId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInvoiceLine.update(this);
    }

    return InvoiceLineId;
  }

  /// saveAll method saves the sent List<InvoiceLine> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<InvoiceLine> invoicelines) async {
    // final results = _mnInvoiceLine.saveAll('INSERT OR REPLACE INTO InvoiceLine (InvoiceLineId,UnitPrice, Quantity, TrackId, InvoiceId)  VALUES (?,?,?,?,?)',invoicelines);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in invoicelines) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns InvoiceLineId
  Future<int> upsert() async {
    try {
      if (await _mnInvoiceLine.rawInsert(
              'INSERT OR REPLACE INTO InvoiceLine (InvoiceLineId,UnitPrice, Quantity, TrackId, InvoiceId)  VALUES (?,?,?,?,?)',
              [InvoiceLineId, UnitPrice, Quantity, TrackId, InvoiceId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InvoiceLine InvoiceLineId=$InvoiceLineId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InvoiceLine InvoiceLineId=$InvoiceLineId did not update');
      }
      return InvoiceLineId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'InvoiceLine Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<InvoiceLine>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<InvoiceLine> invoicelines) async {
    final results = await _mnInvoiceLine.rawInsertAll(
        'INSERT OR REPLACE INTO InvoiceLine (InvoiceLineId,UnitPrice, Quantity, TrackId, InvoiceId)  VALUES (?,?,?,?,?)',
        invoicelines);
    return results;
  }

  /// Deletes InvoiceLine

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print(
        'SQFENTITIY: delete InvoiceLine invoked (InvoiceLineId=$InvoiceLineId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInvoiceLine.delete(QueryParams(
          whereString: 'InvoiceLineId=?', whereArguments: [InvoiceLineId]));
    } else {
      return _mnInvoiceLine.updateBatch(
          QueryParams(
              whereString: 'InvoiceLineId=?', whereArguments: [InvoiceLineId]),
          {'isDeleted': 1});
    }
  }

  InvoiceLineFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return InvoiceLineFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  InvoiceLineFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return InvoiceLineFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion invoiceline

// region InvoiceLineField
class InvoiceLineField extends SearchCriteria {
  InvoiceLineField(this.invoicelineFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  InvoiceLineFilterBuilder invoicelineFB;

  InvoiceLineField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  InvoiceLineFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param, SqlSyntax.EQuals,
            invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.NotEQuals, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.EQualsOrNull, invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder isNull() {
    invoicelineFB._addedBlocks = setCriteria(
        0,
        invoicelineFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      invoicelineFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          invoicelineFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicelineFB._addedBlocks);
      _waitingNot = '';
      invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
          invoicelineFB._addedBlocks.retVal;
    }
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      invoicelineFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          invoicelineFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicelineFB._addedBlocks);
      _waitingNot = '';
      invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
          invoicelineFB._addedBlocks.retVal;
      invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
          invoicelineFB._addedBlocks.retVal;
    }
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      invoicelineFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          invoicelineFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicelineFB._addedBlocks);
      _waitingNot = '';
      invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
          invoicelineFB._addedBlocks.retVal;
    }
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      invoicelineFB._addedBlocks = setCriteria(
          pFirst,
          invoicelineFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          invoicelineFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        invoicelineFB._addedBlocks = setCriteria(
            pFirst,
            invoicelineFB.parameters,
            param,
            SqlSyntax.LessThan,
            invoicelineFB._addedBlocks);
      } else {
        invoicelineFB._addedBlocks = setCriteria(
            pFirst,
            invoicelineFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            invoicelineFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        invoicelineFB._addedBlocks = setCriteria(
            pLast,
            invoicelineFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            invoicelineFB._addedBlocks);
      } else {
        invoicelineFB._addedBlocks = setCriteria(
            pLast,
            invoicelineFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            invoicelineFB._addedBlocks);
      }
    }
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.GreaterThan, invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.LessThan, invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.LessThan, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    invoicelineFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.LessThanOrEquals, invoicelineFB._addedBlocks)
        : setCriteria(pValue, invoicelineFB.parameters, param,
            SqlSyntax.GreaterThan, invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }

  InvoiceLineFilterBuilder inValues(dynamic pValue) {
    invoicelineFB._addedBlocks = setCriteria(
        pValue,
        invoicelineFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        invoicelineFB._addedBlocks);
    _waitingNot = '';
    invoicelineFB._addedBlocks.needEndBlock[invoicelineFB._blockIndex] =
        invoicelineFB._addedBlocks.retVal;
    return invoicelineFB;
  }
}
// endregion InvoiceLineField

// region InvoiceLineFilterBuilder
class InvoiceLineFilterBuilder extends SearchCriteria {
  InvoiceLineFilterBuilder(InvoiceLine obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  InvoiceLine _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  InvoiceLineFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  InvoiceLineFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  InvoiceLineFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  InvoiceLineFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  InvoiceLineFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  InvoiceLineFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  InvoiceLineFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceLineFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceLineFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  InvoiceLineFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  InvoiceLineFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  InvoiceLineField setField(
      InvoiceLineField field, String colName, DbType dbtype) {
    return InvoiceLineField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  InvoiceLineField _InvoiceLineId;
  InvoiceLineField get InvoiceLineId {
    return _InvoiceLineId =
        setField(_InvoiceLineId, 'InvoiceLineId', DbType.integer);
  }

  InvoiceLineField _UnitPrice;
  InvoiceLineField get UnitPrice {
    return _UnitPrice = setField(_UnitPrice, 'UnitPrice', DbType.real);
  }

  InvoiceLineField _Quantity;
  InvoiceLineField get Quantity {
    return _Quantity = setField(_Quantity, 'Quantity', DbType.integer);
  }

  InvoiceLineField _TrackId;
  InvoiceLineField get TrackId {
    return _TrackId = setField(_TrackId, 'TrackId', DbType.integer);
  }

  InvoiceLineField _InvoiceId;
  InvoiceLineField get InvoiceId {
    return _InvoiceId = setField(_InvoiceId, 'InvoiceId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (InvoiceLine._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<InvoiceLine> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (InvoiceLine._softDeleteActivated && !hardDelete) {
      r = await _obj._mnInvoiceLine.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnInvoiceLine.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'InvoiceLineId IN (SELECT InvoiceLineId from InvoiceLine ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnInvoiceLine.updateBatch(qparams, values);
  }

  /// This method always returns InvoiceLine Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<InvoiceLine>
  Future<InvoiceLine> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnInvoiceLine.toList(qparams);
    final data = await objFuture;
    InvoiceLine obj;
    if (data.isNotEmpty) {
      obj = InvoiceLine.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Invoice.plInvoice') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plInvoice'))) {
          /*_loadedFields.add('Invoice.plInvoice');*/
          obj.plInvoice = obj.plInvoice ??
              await obj.getInvoice(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [InvoiceLine]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) invoicelineCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final invoicelinesFuture = await _obj._mnInvoiceLine.toList(qparams);
    final int count = invoicelinesFuture[0]['CNT'] as int;
    if (invoicelineCount != null) {
      invoicelineCount(count);
    }
    return count;
  }

  /// This method returns List<InvoiceLine> [InvoiceLine]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<InvoiceLine>
  Future<List<InvoiceLine>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<InvoiceLine> invoicelinesData = await InvoiceLine.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return invoicelinesData;
  }

  /// This method returns Json String [InvoiceLine]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InvoiceLine]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InvoiceLine]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnInvoiceLine.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<InvoiceLine>>
  Future<List<DropdownMenuItem<InvoiceLine>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<InvoiceLine>> o)
          dropDownMenu]) async {
    _buildParameters();
    final invoicelinesFuture = _obj._mnInvoiceLine.toList(qparams);

    final data = await invoicelinesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<InvoiceLine>> items = []..add(DropdownMenuItem(
        value: InvoiceLine(),
        child: Text('Select InvoiceLine'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: InvoiceLine.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['InvoiceLineId', displayTextColumn];
    final invoicelinesFuture = _obj._mnInvoiceLine.toList(qparams);

    final data = await invoicelinesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select InvoiceLine'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['InvoiceLineId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InvoiceLine]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InvoiceLineId` FROM InvoiceLine WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> InvoiceLineIdData = <int>[];
    qparams.selectColumns = ['InvoiceLineId'];
    final InvoiceLineIdFuture = await _obj._mnInvoiceLine.toList(qparams);

    final int count = InvoiceLineIdFuture.length;
    for (int i = 0; i < count; i++) {
      InvoiceLineIdData.add(InvoiceLineIdFuture[i]['InvoiceLineId'] as int);
    }
    return InvoiceLineIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InvoiceLine]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnInvoiceLine.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await InvoiceLine.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnInvoiceLine.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InvoiceLineFilterBuilder

// region InvoiceLineFields
class InvoiceLineFields {
  static TableField _fInvoiceLineId;
  static TableField get InvoiceLineId {
    return _fInvoiceLineId = _fInvoiceLineId ??
        SqlSyntax.setField(_fInvoiceLineId, 'invoicelineid', DbType.integer);
  }

  static TableField _fUnitPrice;
  static TableField get UnitPrice {
    return _fUnitPrice = _fUnitPrice ??
        SqlSyntax.setField(_fUnitPrice, 'UnitPrice', DbType.real);
  }

  static TableField _fQuantity;
  static TableField get Quantity {
    return _fQuantity = _fQuantity ??
        SqlSyntax.setField(_fQuantity, 'Quantity', DbType.integer);
  }

  static TableField _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }

  static TableField _fInvoiceId;
  static TableField get InvoiceId {
    return _fInvoiceId = _fInvoiceId ??
        SqlSyntax.setField(_fInvoiceId, 'InvoiceId', DbType.integer);
  }
}
// endregion InvoiceLineFields

//region InvoiceLineManager
class InvoiceLineManager extends SqfEntityProvider {
  InvoiceLineManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'InvoiceLine';
  static final List<String> _primaryKeyList = ['InvoiceLineId'];
  static final String _whereStr = 'InvoiceLineId=?';
}

//endregion InvoiceLineManager
// region MediaType
class MediaType {
  MediaType({this.MediaTypeId, this.Name}) {
    _setDefaultValues();
  }
  MediaType.withFields(this.MediaTypeId, this.Name) {
    _setDefaultValues();
  }
  MediaType.withId(this.MediaTypeId, this.Name) {
    _setDefaultValues();
  }
  MediaType.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    MediaTypeId = int.tryParse(o['MediaTypeId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (MediaType)
  int MediaTypeId;
  String Name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (MediaType)

// COLLECTIONS & VIRTUALS (MediaType)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track> plTracks;

  /// get Track(s) filtered by MediaTypeId=MediaTypeId
  TrackFilterBuilder getTracks(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (MediaTypeId == null) {
      return null;
    }
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .MediaTypeId
        .equals(MediaTypeId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (MediaType)

  static const bool _softDeleteActivated = false;
  MediaTypeManager __mnMediaType;

  MediaTypeManager get _mnMediaType {
    return __mnMediaType = __mnMediaType ?? MediaTypeManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (MediaTypeId != null) {
      map['MediaTypeId'] = MediaTypeId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (MediaTypeId != null) {
      map['MediaTypeId'] = MediaTypeId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

// COLLECTIONS (MediaType)
    if (!forQuery) {
      map['Tracks'] = await getTracks().toMapList();
    }
// END COLLECTIONS (MediaType)

    return map;
  }

  /// This method returns Json String [MediaType]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [MediaType]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [MediaTypeId, Name];
  }

  List<dynamic> toArgsWithIds() {
    return [MediaTypeId, Name];
  }

  static Future<List<MediaType>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR MediaType.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<MediaType>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <MediaType>[];
    try {
      objList = list
          .map((mediatype) =>
              MediaType.fromMap(mediatype as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR MediaType.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<MediaType>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<MediaType> objList = <MediaType>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = MediaType.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('MediaType.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns MediaType by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int MediaTypeId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns MediaType if exist, otherwise returns null
  Future<MediaType> getById(int MediaTypeId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (MediaTypeId == null) {
      return null;
    }
    MediaType obj;
    final data = await _mnMediaType.getById([MediaTypeId]);
    if (data.length != 0) {
      obj = MediaType.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('MediaType.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (MediaType) object. If the MediaTypeId field is null, saves as a new record and returns new MediaTypeId, if MediaTypeId is not null then updates record

  /// <returns>Returns MediaTypeId
  Future<int> save() async {
    if (MediaTypeId == null || MediaTypeId == 0 || !isSaved) {
      await _mnMediaType.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // MediaTypeId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnMediaType.update(this);
    }

    return MediaTypeId;
  }

  /// saveAll method saves the sent List<MediaType> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<MediaType> mediatypes) async {
    // final results = _mnMediaType.saveAll('INSERT OR REPLACE INTO MediaType (MediaTypeId,Name)  VALUES (?,?)',mediatypes);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in mediatypes) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns MediaTypeId
  Future<int> upsert() async {
    try {
      if (await _mnMediaType.rawInsert(
              'INSERT OR REPLACE INTO MediaType (MediaTypeId,Name)  VALUES (?,?)',
              [MediaTypeId, Name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'MediaType MediaTypeId=$MediaTypeId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'MediaType MediaTypeId=$MediaTypeId did not update');
      }
      return MediaTypeId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'MediaType Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<MediaType>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<MediaType> mediatypes) async {
    final results = await _mnMediaType.rawInsertAll(
        'INSERT OR REPLACE INTO MediaType (MediaTypeId,Name)  VALUES (?,?)',
        mediatypes);
    return results;
  }

  /// Deletes MediaType

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete MediaType invoked (MediaTypeId=$MediaTypeId)');
    if (await Track().select().MediaTypeId.equals(MediaTypeId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.MediaTypeId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnMediaType.delete(QueryParams(
          whereString: 'MediaTypeId=?', whereArguments: [MediaTypeId]));
    } else {
      return _mnMediaType.updateBatch(
          QueryParams(
              whereString: 'MediaTypeId=?', whereArguments: [MediaTypeId]),
          {'isDeleted': 1});
    }
  }

  MediaTypeFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return MediaTypeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  MediaTypeFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return MediaTypeFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion mediatype

// region MediaTypeField
class MediaTypeField extends SearchCriteria {
  MediaTypeField(this.mediatypeFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  MediaTypeFilterBuilder mediatypeFB;

  MediaTypeField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  MediaTypeFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param, SqlSyntax.EQuals,
            mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.NotEQuals, mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.EQualsOrNull, mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder isNull() {
    mediatypeFB._addedBlocks = setCriteria(
        0,
        mediatypeFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      mediatypeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          mediatypeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          mediatypeFB._addedBlocks);
      _waitingNot = '';
      mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
          mediatypeFB._addedBlocks.retVal;
    }
    return mediatypeFB;
  }

  MediaTypeFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      mediatypeFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          mediatypeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          mediatypeFB._addedBlocks);
      _waitingNot = '';
      mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
          mediatypeFB._addedBlocks.retVal;
      mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
          mediatypeFB._addedBlocks.retVal;
    }
    return mediatypeFB;
  }

  MediaTypeFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      mediatypeFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          mediatypeFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          mediatypeFB._addedBlocks);
      _waitingNot = '';
      mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
          mediatypeFB._addedBlocks.retVal;
    }
    return mediatypeFB;
  }

  MediaTypeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      mediatypeFB._addedBlocks = setCriteria(
          pFirst,
          mediatypeFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          mediatypeFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        mediatypeFB._addedBlocks = setCriteria(pFirst, mediatypeFB.parameters,
            param, SqlSyntax.LessThan, mediatypeFB._addedBlocks);
      } else {
        mediatypeFB._addedBlocks = setCriteria(pFirst, mediatypeFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, mediatypeFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        mediatypeFB._addedBlocks = setCriteria(pLast, mediatypeFB.parameters,
            param, SqlSyntax.GreaterThan, mediatypeFB._addedBlocks);
      } else {
        mediatypeFB._addedBlocks = setCriteria(pLast, mediatypeFB.parameters,
            param, SqlSyntax.LessThanOrEquals, mediatypeFB._addedBlocks);
      }
    }
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.GreaterThan, mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param, SqlSyntax.LessThan,
            mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param, SqlSyntax.LessThan,
            mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    mediatypeFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.LessThanOrEquals, mediatypeFB._addedBlocks)
        : setCriteria(pValue, mediatypeFB.parameters, param,
            SqlSyntax.GreaterThan, mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }

  MediaTypeFilterBuilder inValues(dynamic pValue) {
    mediatypeFB._addedBlocks = setCriteria(
        pValue,
        mediatypeFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        mediatypeFB._addedBlocks);
    _waitingNot = '';
    mediatypeFB._addedBlocks.needEndBlock[mediatypeFB._blockIndex] =
        mediatypeFB._addedBlocks.retVal;
    return mediatypeFB;
  }
}
// endregion MediaTypeField

// region MediaTypeFilterBuilder
class MediaTypeFilterBuilder extends SearchCriteria {
  MediaTypeFilterBuilder(MediaType obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  MediaType _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  MediaTypeFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  MediaTypeFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  MediaTypeFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  MediaTypeFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  MediaTypeFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  MediaTypeFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  MediaTypeFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  MediaTypeFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  MediaTypeFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  MediaTypeFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  MediaTypeFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  MediaTypeField setField(MediaTypeField field, String colName, DbType dbtype) {
    return MediaTypeField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  MediaTypeField _MediaTypeId;
  MediaTypeField get MediaTypeId {
    return _MediaTypeId = setField(_MediaTypeId, 'MediaTypeId', DbType.integer);
  }

  MediaTypeField _Name;
  MediaTypeField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (MediaType._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<MediaType> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (Track) according to DeleteRule.NO_ACTION

    final idListTrackBYMediaTypeId = toListPrimaryKeySQL(false);
    final resTrackBYMediaTypeId = await Track()
        .select()
        .where('MediaTypeId IN (${idListTrackBYMediaTypeId['sql']})',
            parameterValue: idListTrackBYMediaTypeId['args'])
        .toCount();
    if (resTrackBYMediaTypeId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (Track.MediaTypeId)');
    }

    if (MediaType._softDeleteActivated && !hardDelete) {
      r = await _obj._mnMediaType.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnMediaType.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'MediaTypeId IN (SELECT MediaTypeId from MediaType ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnMediaType.updateBatch(qparams, values);
  }

  /// This method always returns MediaType Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<MediaType>
  Future<MediaType> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnMediaType.toList(qparams);
    final data = await objFuture;
    MediaType obj;
    if (data.isNotEmpty) {
      obj = MediaType.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('MediaType.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [MediaType]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) mediatypeCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final mediatypesFuture = await _obj._mnMediaType.toList(qparams);
    final int count = mediatypesFuture[0]['CNT'] as int;
    if (mediatypeCount != null) {
      mediatypeCount(count);
    }
    return count;
  }

  /// This method returns List<MediaType> [MediaType]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<MediaType>
  Future<List<MediaType>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<MediaType> mediatypesData = await MediaType.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return mediatypesData;
  }

  /// This method returns Json String [MediaType]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [MediaType]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [MediaType]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnMediaType.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<MediaType>>
  Future<List<DropdownMenuItem<MediaType>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<MediaType>> o)
          dropDownMenu]) async {
    _buildParameters();
    final mediatypesFuture = _obj._mnMediaType.toList(qparams);

    final data = await mediatypesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<MediaType>> items = []..add(DropdownMenuItem(
        value: MediaType(),
        child: Text('Select MediaType'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: MediaType.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['MediaTypeId', displayTextColumn];
    final mediatypesFuture = _obj._mnMediaType.toList(qparams);

    final data = await mediatypesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select MediaType'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['MediaTypeId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [MediaType]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `MediaTypeId` FROM MediaType WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> MediaTypeIdData = <int>[];
    qparams.selectColumns = ['MediaTypeId'];
    final MediaTypeIdFuture = await _obj._mnMediaType.toList(qparams);

    final int count = MediaTypeIdFuture.length;
    for (int i = 0; i < count; i++) {
      MediaTypeIdData.add(MediaTypeIdFuture[i]['MediaTypeId'] as int);
    }
    return MediaTypeIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [MediaType]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnMediaType.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await MediaType.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnMediaType.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion MediaTypeFilterBuilder

// region MediaTypeFields
class MediaTypeFields {
  static TableField _fMediaTypeId;
  static TableField get MediaTypeId {
    return _fMediaTypeId = _fMediaTypeId ??
        SqlSyntax.setField(_fMediaTypeId, 'mediatypeid', DbType.integer);
  }

  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion MediaTypeFields

//region MediaTypeManager
class MediaTypeManager extends SqfEntityProvider {
  MediaTypeManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'MediaType';
  static final List<String> _primaryKeyList = ['MediaTypeId'];
  static final String _whereStr = 'MediaTypeId=?';
}

//endregion MediaTypeManager
// region Playlist
class Playlist {
  Playlist({this.PlaylistId, this.Name}) {
    _setDefaultValues();
  }
  Playlist.withFields(this.PlaylistId, this.Name) {
    _setDefaultValues();
  }
  Playlist.withId(this.PlaylistId, this.Name) {
    _setDefaultValues();
  }
  Playlist.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    PlaylistId = int.tryParse(o['PlaylistId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }

    isSaved = true;
  }
  // FIELDS (Playlist)
  int PlaylistId;
  String Name;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Playlist)

// COLLECTIONS & VIRTUALS (Playlist)
  ///(RelationType.MANY_TO_MANY) (PlaylistTrack) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTracks', 'plField2'..]) or so on..
  List<Track> plTracks;

  /// get Track(s) filtered by TrackId IN PlaylistTrack
  TrackFilterBuilder getTracks(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Track()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'PlaylistId IN (SELECT TrackId FROM PlaylistTrack WHERE PlaylistId=?)',
            parameterValue: PlaylistId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Playlist)

  static const bool _softDeleteActivated = false;
  PlaylistManager __mnPlaylist;

  PlaylistManager get _mnPlaylist {
    return __mnPlaylist = __mnPlaylist ?? PlaylistManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (PlaylistId != null) {
      map['PlaylistId'] = PlaylistId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (PlaylistId != null) {
      map['PlaylistId'] = PlaylistId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

// COLLECTIONS (Playlist)
    if (!forQuery) {
      map['Tracks'] = await getTracks().toMapList();
    }
// END COLLECTIONS (Playlist)

    return map;
  }

  /// This method returns Json String [Playlist]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Playlist]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [PlaylistId, Name];
  }

  List<dynamic> toArgsWithIds() {
    return [PlaylistId, Name];
  }

  static Future<List<Playlist>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR Playlist.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Playlist>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Playlist>[];
    try {
      objList = list
          .map((playlist) => Playlist.fromMap(playlist as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Playlist.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Playlist>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Playlist> objList = <Playlist>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Playlist.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Playlist.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Playlist by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int PlaylistId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Playlist if exist, otherwise returns null
  Future<Playlist> getById(int PlaylistId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (PlaylistId == null) {
      return null;
    }
    Playlist obj;
    final data = await _mnPlaylist.getById([PlaylistId]);
    if (data.length != 0) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Playlist.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Playlist) object. If the PlaylistId field is null, saves as a new record and returns new PlaylistId, if PlaylistId is not null then updates record

  /// <returns>Returns PlaylistId
  Future<int> save() async {
    if (PlaylistId == null || PlaylistId == 0 || !isSaved) {
      await _mnPlaylist.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // PlaylistId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnPlaylist.update(this);
    }

    return PlaylistId;
  }

  /// saveAll method saves the sent List<Playlist> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Playlist> playlists) async {
    // final results = _mnPlaylist.saveAll('INSERT OR REPLACE INTO Playlist (PlaylistId,Name)  VALUES (?,?)',playlists);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in playlists) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns PlaylistId
  Future<int> upsert() async {
    try {
      if (await _mnPlaylist.rawInsert(
              'INSERT OR REPLACE INTO Playlist (PlaylistId,Name)  VALUES (?,?)',
              [PlaylistId, Name]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Playlist PlaylistId=$PlaylistId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Playlist PlaylistId=$PlaylistId did not update');
      }
      return PlaylistId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Playlist Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Playlist>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Playlist> playlists) async {
    final results = await _mnPlaylist.rawInsertAll(
        'INSERT OR REPLACE INTO Playlist (PlaylistId,Name)  VALUES (?,?)',
        playlists);
    return results;
  }

  /// Deletes Playlist

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Playlist invoked (PlaylistId=$PlaylistId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylist.delete(QueryParams(
          whereString: 'PlaylistId=?', whereArguments: [PlaylistId]));
    } else {
      return _mnPlaylist.updateBatch(
          QueryParams(
              whereString: 'PlaylistId=?', whereArguments: [PlaylistId]),
          {'isDeleted': 1});
    }
  }

  PlaylistFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PlaylistFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion playlist

// region PlaylistField
class PlaylistField extends SearchCriteria {
  PlaylistField(this.playlistFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  PlaylistFilterBuilder playlistFB;

  PlaylistField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PlaylistFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.EQuals,
            playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.NotEQuals,
            playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.EQualsOrNull, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder isNull() {
    playlistFB._addedBlocks = setCriteria(
        0,
        playlistFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
      playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      playlistFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          playlistFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks);
      _waitingNot = '';
      playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
          playlistFB._addedBlocks.retVal;
    }
    return playlistFB;
  }

  PlaylistFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      playlistFB._addedBlocks = setCriteria(
          pFirst,
          playlistFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlistFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        playlistFB._addedBlocks = setCriteria(pFirst, playlistFB.parameters,
            param, SqlSyntax.LessThan, playlistFB._addedBlocks);
      } else {
        playlistFB._addedBlocks = setCriteria(pFirst, playlistFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        playlistFB._addedBlocks = setCriteria(pLast, playlistFB.parameters,
            param, SqlSyntax.GreaterThan, playlistFB._addedBlocks);
      } else {
        playlistFB._addedBlocks = setCriteria(pLast, playlistFB.parameters,
            param, SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks);
      }
    }
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThan, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.LessThan,
            playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param, SqlSyntax.LessThan,
            playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    playlistFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlistFB._addedBlocks)
        : setCriteria(pValue, playlistFB.parameters, param,
            SqlSyntax.GreaterThan, playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }

  PlaylistFilterBuilder inValues(dynamic pValue) {
    playlistFB._addedBlocks = setCriteria(
        pValue,
        playlistFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlistFB._addedBlocks);
    _waitingNot = '';
    playlistFB._addedBlocks.needEndBlock[playlistFB._blockIndex] =
        playlistFB._addedBlocks.retVal;
    return playlistFB;
  }
}
// endregion PlaylistField

// region PlaylistFilterBuilder
class PlaylistFilterBuilder extends SearchCriteria {
  PlaylistFilterBuilder(Playlist obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Playlist _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  PlaylistFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PlaylistFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PlaylistFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PlaylistFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PlaylistFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PlaylistFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PlaylistFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PlaylistField setField(PlaylistField field, String colName, DbType dbtype) {
    return PlaylistField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  PlaylistField _PlaylistId;
  PlaylistField get PlaylistId {
    return _PlaylistId = setField(_PlaylistId, 'PlaylistId', DbType.integer);
  }

  PlaylistField _Name;
  PlaylistField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Playlist._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Playlist> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (Playlist._softDeleteActivated && !hardDelete) {
      r = await _obj._mnPlaylist.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnPlaylist.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'PlaylistId IN (SELECT PlaylistId from Playlist ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnPlaylist.updateBatch(qparams, values);
  }

  /// This method always returns Playlist Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Playlist>
  Future<Playlist> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnPlaylist.toList(qparams);
    final data = await objFuture;
    Playlist obj;
    if (data.isNotEmpty) {
      obj = Playlist.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Playlist.plTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plTracks'))) {
          /*_loadedFields.add('Playlist.plTracks'); */
          obj.plTracks = obj.plTracks ??
              await obj.getTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Playlist]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) playlistCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlistsFuture = await _obj._mnPlaylist.toList(qparams);
    final int count = playlistsFuture[0]['CNT'] as int;
    if (playlistCount != null) {
      playlistCount(count);
    }
    return count;
  }

  /// This method returns List<Playlist> [Playlist]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Playlist>
  Future<List<Playlist>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Playlist> playlistsData = await Playlist.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return playlistsData;
  }

  /// This method returns Json String [Playlist]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Playlist]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Playlist]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnPlaylist.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Playlist>>
  Future<List<DropdownMenuItem<Playlist>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Playlist>> o)
          dropDownMenu]) async {
    _buildParameters();
    final playlistsFuture = _obj._mnPlaylist.toList(qparams);

    final data = await playlistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Playlist>> items = []..add(DropdownMenuItem(
        value: Playlist(),
        child: Text('Select Playlist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Playlist.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['PlaylistId', displayTextColumn];
    final playlistsFuture = _obj._mnPlaylist.toList(qparams);

    final data = await playlistsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Playlist'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['PlaylistId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Playlist]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `PlaylistId` FROM Playlist WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> PlaylistIdData = <int>[];
    qparams.selectColumns = ['PlaylistId'];
    final PlaylistIdFuture = await _obj._mnPlaylist.toList(qparams);

    final int count = PlaylistIdFuture.length;
    for (int i = 0; i < count; i++) {
      PlaylistIdData.add(PlaylistIdFuture[i]['PlaylistId'] as int);
    }
    return PlaylistIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Playlist]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylist.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Playlist.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylist.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistFilterBuilder

// region PlaylistFields
class PlaylistFields {
  static TableField _fPlaylistId;
  static TableField get PlaylistId {
    return _fPlaylistId = _fPlaylistId ??
        SqlSyntax.setField(_fPlaylistId, 'playlistid', DbType.integer);
  }

  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }
}
// endregion PlaylistFields

//region PlaylistManager
class PlaylistManager extends SqfEntityProvider {
  PlaylistManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Playlist';
  static final List<String> _primaryKeyList = ['PlaylistId'];
  static final String _whereStr = 'PlaylistId=?';
}

//endregion PlaylistManager
// region Track
class Track {
  Track(
      {this.TrackId,
      this.Name,
      this.Composer,
      this.Milliseconds,
      this.Bytes,
      this.UnitPrice,
      this.MediaTypeId,
      this.GenreId,
      this.AlbumId}) {
    _setDefaultValues();
  }
  Track.withFields(
      this.TrackId,
      this.Name,
      this.Composer,
      this.Milliseconds,
      this.Bytes,
      this.UnitPrice,
      this.MediaTypeId,
      this.GenreId,
      this.AlbumId) {
    _setDefaultValues();
  }
  Track.withId(
      this.TrackId,
      this.Name,
      this.Composer,
      this.Milliseconds,
      this.Bytes,
      this.UnitPrice,
      this.MediaTypeId,
      this.GenreId,
      this.AlbumId) {
    _setDefaultValues();
  }
  Track.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TrackId = int.tryParse(o['TrackId'].toString());
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }
    if (o['Composer'] != null) {
      Composer = o['Composer'] as String;
    }
    if (o['Milliseconds'] != null) {
      Milliseconds = int.tryParse(o['Milliseconds'].toString());
    }
    if (o['Bytes'] != null) {
      Bytes = int.tryParse(o['Bytes'].toString());
    }
    if (o['UnitPrice'] != null) {
      UnitPrice = double.tryParse(o['UnitPrice'].toString());
    }
    MediaTypeId = int.tryParse(o['MediaTypeId'].toString());

    GenreId = int.tryParse(o['GenreId'].toString());

    AlbumId = int.tryParse(o['AlbumId'].toString());

    // RELATIONSHIPS FromMAP
    plMediaType = o['mediaType'] != null
        ? MediaType.fromMap(o['mediaType'] as Map<String, dynamic>)
        : null;
    plGenre = o['genre'] != null
        ? Genre.fromMap(o['genre'] as Map<String, dynamic>)
        : null;
    plAlbum = o['album'] != null
        ? Album.fromMap(o['album'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (Track)
  int TrackId;
  String Name;
  String Composer;
  int Milliseconds;
  int Bytes;
  double UnitPrice;
  int MediaTypeId;
  int GenreId;
  int AlbumId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (Track)

// RELATIONSHIPS (Track)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plMediaType', 'plField2'..]) or so on..
  MediaType plMediaType;

  /// get MediaType By MediaTypeId
  Future<MediaType> getMediaType(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await MediaType().getById(MediaTypeId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plGenre', 'plField2'..]) or so on..
  Genre plGenre;

  /// get Genre By GenreId
  Future<Genre> getGenre(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Genre()
        .getById(GenreId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plAlbum', 'plField2'..]) or so on..
  Album plAlbum;

  /// get Album By AlbumId
  Future<Album> getAlbum(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Album()
        .getById(AlbumId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (Track)

// COLLECTIONS & VIRTUALS (Track)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plInvoiceLines', 'plField2'..]) or so on..
  List<InvoiceLine> plInvoiceLines;

  /// get InvoiceLine(s) filtered by TrackId=TrackId
  InvoiceLineFilterBuilder getInvoiceLines(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (TrackId == null) {
      return null;
    }
    return InvoiceLine()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .TrackId
        .equals(TrackId)
        .and;
  }

  ///(RelationType.MANY_TO_MANY) (PlaylistTrack) to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPlaylists', 'plField2'..]) or so on..
  List<Playlist> plPlaylists;

  /// get Playlist(s) filtered by PlaylistId IN PlaylistTrack
  PlaylistFilterBuilder getPlaylists(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return Playlist()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .where(
            'TrackId IN (SELECT PlaylistId FROM PlaylistTrack WHERE TrackId=?)',
            parameterValue: TrackId)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plVTracks', 'plField2'..]) or so on..
  List<VTrack> plVTracks;

  /// get VTrack(s) filtered by TrackId=TrackId
  VTrackFilterBuilder getVTracks(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (TrackId == null) {
      return null;
    }
    return VTrack()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .TrackId
        .equals(TrackId)
        .and;
  }

// END COLLECTIONS & VIRTUALS (Track)

  static const bool _softDeleteActivated = false;
  TrackManager __mnTrack;

  TrackManager get _mnTrack {
    return __mnTrack = __mnTrack ?? TrackManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = TrackId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    if (Composer != null) {
      map['Composer'] = Composer;
    }

    if (Milliseconds != null) {
      map['Milliseconds'] = Milliseconds;
    }

    if (Bytes != null) {
      map['Bytes'] = Bytes;
    }

    if (UnitPrice != null) {
      map['UnitPrice'] = UnitPrice;
    }

    if (MediaTypeId != null) {
      map['MediaTypeId'] = forView ? plMediaType.Name : MediaTypeId;
    }

    if (GenreId != null) {
      map['GenreId'] = forView ? plGenre.Name : GenreId;
    }

    if (AlbumId != null) {
      map['AlbumId'] = forView ? plAlbum.Title : AlbumId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = TrackId;
    }
    if (Name != null) {
      map['Name'] = Name;
    }

    if (Composer != null) {
      map['Composer'] = Composer;
    }

    if (Milliseconds != null) {
      map['Milliseconds'] = Milliseconds;
    }

    if (Bytes != null) {
      map['Bytes'] = Bytes;
    }

    if (UnitPrice != null) {
      map['UnitPrice'] = UnitPrice;
    }

    if (MediaTypeId != null) {
      map['MediaTypeId'] = forView ? plMediaType.Name : MediaTypeId;
    }

    if (GenreId != null) {
      map['GenreId'] = forView ? plGenre.Name : GenreId;
    }

    if (AlbumId != null) {
      map['AlbumId'] = forView ? plAlbum.Title : AlbumId;
    }

// COLLECTIONS (Track)
    if (!forQuery) {
      map['InvoiceLines'] = await getInvoiceLines().toMapList();
    }
    if (!forQuery) {
      map['Playlists'] = await getPlaylists().toMapList();
    }
    if (!forQuery) {
      map['VTracks'] = await getVTracks().toMapList();
    }
// END COLLECTIONS (Track)

    return map;
  }

  /// This method returns Json String [Track]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Track]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      TrackId,
      Name,
      Composer,
      Milliseconds,
      Bytes,
      UnitPrice,
      MediaTypeId,
      GenreId,
      AlbumId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      TrackId,
      Name,
      Composer,
      Milliseconds,
      Bytes,
      UnitPrice,
      MediaTypeId,
      GenreId,
      AlbumId
    ];
  }

  static Future<List<Track>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR Track.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<Track>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Track>[];
    try {
      objList = list
          .map((track) => Track.fromMap(track as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR Track.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Track>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<Track> objList = <Track>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Track.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Track.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedFields.add('Track.plPlaylists'); */
          obj.plPlaylists = obj.plPlaylists ??
              await obj.getPlaylists().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedFields.add('Track.plVTracks'); */
          obj.plVTracks = obj.plVTracks ??
              await obj.getVTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plMediaType') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          /*_loadedFields.add('MediaType.plMediaType');*/
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Genre.plGenre') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          /*_loadedFields.add('Genre.plGenre');*/
          obj.plGenre = obj.plGenre ??
              await obj.getGenre(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Album.plAlbum') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          /*_loadedFields.add('Album.plAlbum');*/
          obj.plAlbum = obj.plAlbum ??
              await obj.getAlbum(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns Track by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int TrackId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns Track if exist, otherwise returns null
  Future<Track> getById(int TrackId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (TrackId == null) {
      return null;
    }
    Track obj;
    final data = await _mnTrack.getById([TrackId]);
    if (data.length != 0) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Track.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedFields.add('Track.plPlaylists'); */
          obj.plPlaylists = obj.plPlaylists ??
              await obj.getPlaylists().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedFields.add('Track.plVTracks'); */
          obj.plVTracks = obj.plVTracks ??
              await obj.getVTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plMediaType') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          /*_loadedFields.add('MediaType.plMediaType');*/
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Genre.plGenre') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          /*_loadedFields.add('Genre.plGenre');*/
          obj.plGenre = obj.plGenre ??
              await obj.getGenre(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Album.plAlbum') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          /*_loadedFields.add('Album.plAlbum');*/
          obj.plAlbum = obj.plAlbum ??
              await obj.getAlbum(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Track) object. If the TrackId field is null, saves as a new record and returns new TrackId, if TrackId is not null then updates record

  /// <returns>Returns TrackId
  Future<int> save() async {
    if (TrackId == null || TrackId == 0 || !isSaved) {
      await _mnTrack.insert(this);
      if (saveResult != null && saveResult.success) {
        isSaved = true;
      }
    } else {
      // TrackId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTrack.update(this);
    }

    return TrackId;
  }

  /// saveAll method saves the sent List<Track> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Track> tracks) async {
    // final results = _mnTrack.saveAll('INSERT OR REPLACE INTO Track (TrackId,Name, Composer, Milliseconds, Bytes, UnitPrice, MediaTypeId, GenreId, AlbumId)  VALUES (?,?,?,?,?,?,?,?,?)',tracks);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in tracks) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns TrackId
  Future<int> upsert() async {
    try {
      if (await _mnTrack.rawInsert(
              'INSERT OR REPLACE INTO Track (TrackId,Name, Composer, Milliseconds, Bytes, UnitPrice, MediaTypeId, GenreId, AlbumId)  VALUES (?,?,?,?,?,?,?,?,?)',
              [
                TrackId,
                Name,
                Composer,
                Milliseconds,
                Bytes,
                UnitPrice,
                MediaTypeId,
                GenreId,
                AlbumId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Track TrackId=$TrackId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Track TrackId=$TrackId did not update');
      }
      return TrackId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Track Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<Track>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<Track> tracks) async {
    final results = await _mnTrack.rawInsertAll(
        'INSERT OR REPLACE INTO Track (TrackId,Name, Composer, Milliseconds, Bytes, UnitPrice, MediaTypeId, GenreId, AlbumId)  VALUES (?,?,?,?,?,?,?,?,?)',
        tracks);
    return results;
  }

  /// Deletes Track

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete Track invoked (TrackId=$TrackId)');
    if (await InvoiceLine().select().TrackId.equals(TrackId).and.toCount() >
        0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.TrackId)');
    }
    if (await VTrack().select().TrackId.equals(TrackId).and.toCount() > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VTrack.TrackId)');
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnTrack.delete(
          QueryParams(whereString: 'TrackId=?', whereArguments: [TrackId]));
    } else {
      return _mnTrack.updateBatch(
          QueryParams(whereString: 'TrackId=?', whereArguments: [TrackId]),
          {'isDeleted': 1});
    }
  }

  TrackFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return TrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  TrackFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return TrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion track

// region TrackField
class TrackField extends SearchCriteria {
  TrackField(this.trackFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  TrackFilterBuilder trackFB;

  TrackField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  TrackFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param, SqlSyntax.EQuals,
            trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param, SqlSyntax.NotEQuals,
            trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param, SqlSyntax.EQualsOrNull,
            trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder isNull() {
    trackFB._addedBlocks = setCriteria(
        0,
        trackFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      trackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          trackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          trackFB._addedBlocks);
      _waitingNot = '';
      trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
          trackFB._addedBlocks.retVal;
    }
    return trackFB;
  }

  TrackFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      trackFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          trackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          trackFB._addedBlocks);
      _waitingNot = '';
      trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
          trackFB._addedBlocks.retVal;
      trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
          trackFB._addedBlocks.retVal;
    }
    return trackFB;
  }

  TrackFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      trackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          trackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          trackFB._addedBlocks);
      _waitingNot = '';
      trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
          trackFB._addedBlocks.retVal;
    }
    return trackFB;
  }

  TrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      trackFB._addedBlocks = setCriteria(
          pFirst,
          trackFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          trackFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        trackFB._addedBlocks = setCriteria(pFirst, trackFB.parameters, param,
            SqlSyntax.LessThan, trackFB._addedBlocks);
      } else {
        trackFB._addedBlocks = setCriteria(pFirst, trackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, trackFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        trackFB._addedBlocks = setCriteria(pLast, trackFB.parameters, param,
            SqlSyntax.GreaterThan, trackFB._addedBlocks);
      } else {
        trackFB._addedBlocks = setCriteria(pLast, trackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, trackFB._addedBlocks);
      }
    }
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param, SqlSyntax.GreaterThan,
            trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param, SqlSyntax.LessThan,
            trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param, SqlSyntax.LessThan,
            trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    trackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, trackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, trackFB._addedBlocks)
        : setCriteria(pValue, trackFB.parameters, param, SqlSyntax.GreaterThan,
            trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }

  TrackFilterBuilder inValues(dynamic pValue) {
    trackFB._addedBlocks = setCriteria(
        pValue,
        trackFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        trackFB._addedBlocks);
    _waitingNot = '';
    trackFB._addedBlocks.needEndBlock[trackFB._blockIndex] =
        trackFB._addedBlocks.retVal;
    return trackFB;
  }
}
// endregion TrackField

// region TrackFilterBuilder
class TrackFilterBuilder extends SearchCriteria {
  TrackFilterBuilder(Track obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Track _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  TrackFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  TrackFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  TrackFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  TrackFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  TrackFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  TrackFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  TrackFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TrackFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TrackFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  TrackFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  TrackFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  TrackField setField(TrackField field, String colName, DbType dbtype) {
    return TrackField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  TrackField _TrackId;
  TrackField get TrackId {
    return _TrackId = setField(_TrackId, 'TrackId', DbType.integer);
  }

  TrackField _Name;
  TrackField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  TrackField _Composer;
  TrackField get Composer {
    return _Composer = setField(_Composer, 'Composer', DbType.text);
  }

  TrackField _Milliseconds;
  TrackField get Milliseconds {
    return _Milliseconds =
        setField(_Milliseconds, 'Milliseconds', DbType.integer);
  }

  TrackField _Bytes;
  TrackField get Bytes {
    return _Bytes = setField(_Bytes, 'Bytes', DbType.integer);
  }

  TrackField _UnitPrice;
  TrackField get UnitPrice {
    return _UnitPrice = setField(_UnitPrice, 'UnitPrice', DbType.real);
  }

  TrackField _MediaTypeId;
  TrackField get MediaTypeId {
    return _MediaTypeId = setField(_MediaTypeId, 'MediaTypeId', DbType.integer);
  }

  TrackField _GenreId;
  TrackField get GenreId {
    return _GenreId = setField(_GenreId, 'GenreId', DbType.integer);
  }

  TrackField _AlbumId;
  TrackField get AlbumId {
    return _AlbumId = setField(_AlbumId, 'AlbumId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (Track._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<Track> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Check sub records where in (InvoiceLine) according to DeleteRule.NO_ACTION

    final idListInvoiceLineBYTrackId = toListPrimaryKeySQL(false);
    final resInvoiceLineBYTrackId = await InvoiceLine()
        .select()
        .where('TrackId IN (${idListInvoiceLineBYTrackId['sql']})',
            parameterValue: idListInvoiceLineBYTrackId['args'])
        .toCount();
    if (resInvoiceLineBYTrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (InvoiceLine.TrackId)');
    }
// Check sub records where in (VTrack) according to DeleteRule.NO_ACTION

    final idListVTrackBYTrackId = toListPrimaryKeySQL(false);
    final resVTrackBYTrackId = await VTrack()
        .select()
        .where('TrackId IN (${idListVTrackBYTrackId['sql']})',
            parameterValue: idListVTrackBYTrackId['args'])
        .toCount();
    if (resVTrackBYTrackId > 0) {
      return BoolResult(
          success: false,
          errorMessage:
              'SQFENTITY ERROR: The DELETE statement conflicted with the REFERENCE RELATIONSHIP (VTrack.TrackId)');
    }

    if (Track._softDeleteActivated && !hardDelete) {
      r = await _obj._mnTrack.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnTrack.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'TrackId IN (SELECT TrackId from Track ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnTrack.updateBatch(qparams, values);
  }

  /// This method always returns Track Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Track>
  Future<Track> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnTrack.toList(qparams);
    final data = await objFuture;
    Track obj;
    if (data.isNotEmpty) {
      obj = Track.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plInvoiceLines') && */ (preloadFields ==
                null ||
            preloadFields.contains('plInvoiceLines'))) {
          /*_loadedFields.add('Track.plInvoiceLines'); */
          obj.plInvoiceLines = obj.plInvoiceLines ??
              await obj.getInvoiceLines().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plPlaylists') && */ (preloadFields ==
                null ||
            preloadFields.contains('plPlaylists'))) {
          /*_loadedFields.add('Track.plPlaylists'); */
          obj.plPlaylists = obj.plPlaylists ??
              await obj.getPlaylists().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('Track.plVTracks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plVTracks'))) {
          /*_loadedFields.add('Track.plVTracks'); */
          obj.plVTracks = obj.plVTracks ??
              await obj.getVTracks().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('MediaType.plMediaType') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plMediaType'))) {
          /*_loadedFields.add('MediaType.plMediaType');*/
          obj.plMediaType = obj.plMediaType ??
              await obj.getMediaType(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Genre.plGenre') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plGenre'))) {
          /*_loadedFields.add('Genre.plGenre');*/
          obj.plGenre = obj.plGenre ??
              await obj.getGenre(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Album.plAlbum') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plAlbum'))) {
          /*_loadedFields.add('Album.plAlbum');*/
          obj.plAlbum = obj.plAlbum ??
              await obj.getAlbum(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [Track]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) trackCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tracksFuture = await _obj._mnTrack.toList(qparams);
    final int count = tracksFuture[0]['CNT'] as int;
    if (trackCount != null) {
      trackCount(count);
    }
    return count;
  }

  /// This method returns List<Track> [Track]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<Track>
  Future<List<Track>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<Track> tracksData = await Track.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tracksData;
  }

  /// This method returns Json String [Track]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Track]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Track]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnTrack.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Track>>
  Future<List<DropdownMenuItem<Track>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Track>> o)
          dropDownMenu]) async {
    _buildParameters();
    final tracksFuture = _obj._mnTrack.toList(qparams);

    final data = await tracksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Track>> items = []..add(DropdownMenuItem(
        value: Track(),
        child: Text('Select Track'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Track.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['TrackId', displayTextColumn];
    final tracksFuture = _obj._mnTrack.toList(qparams);

    final data = await tracksFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select Track'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['TrackId'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Track]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `TrackId` FROM Track WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> TrackIdData = <int>[];
    qparams.selectColumns = ['TrackId'];
    final TrackIdFuture = await _obj._mnTrack.toList(qparams);

    final int count = TrackIdFuture.length;
    for (int i = 0; i < count; i++) {
      TrackIdData.add(TrackIdFuture[i]['TrackId'] as int);
    }
    return TrackIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Track]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnTrack.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await Track.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnTrack.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TrackFilterBuilder

// region TrackFields
class TrackFields {
  static TableField _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'trackid', DbType.integer);
  }

  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField _fComposer;
  static TableField get Composer {
    return _fComposer =
        _fComposer ?? SqlSyntax.setField(_fComposer, 'Composer', DbType.text);
  }

  static TableField _fMilliseconds;
  static TableField get Milliseconds {
    return _fMilliseconds = _fMilliseconds ??
        SqlSyntax.setField(_fMilliseconds, 'Milliseconds', DbType.integer);
  }

  static TableField _fBytes;
  static TableField get Bytes {
    return _fBytes =
        _fBytes ?? SqlSyntax.setField(_fBytes, 'Bytes', DbType.integer);
  }

  static TableField _fUnitPrice;
  static TableField get UnitPrice {
    return _fUnitPrice = _fUnitPrice ??
        SqlSyntax.setField(_fUnitPrice, 'UnitPrice', DbType.real);
  }

  static TableField _fMediaTypeId;
  static TableField get MediaTypeId {
    return _fMediaTypeId = _fMediaTypeId ??
        SqlSyntax.setField(_fMediaTypeId, 'MediaTypeId', DbType.integer);
  }

  static TableField _fGenreId;
  static TableField get GenreId {
    return _fGenreId =
        _fGenreId ?? SqlSyntax.setField(_fGenreId, 'GenreId', DbType.integer);
  }

  static TableField _fAlbumId;
  static TableField get AlbumId {
    return _fAlbumId =
        _fAlbumId ?? SqlSyntax.setField(_fAlbumId, 'AlbumId', DbType.integer);
  }
}
// endregion TrackFields

//region TrackManager
class TrackManager extends SqfEntityProvider {
  TrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'Track';
  static final List<String> _primaryKeyList = ['TrackId'];
  static final String _whereStr = 'TrackId=?';
}

//endregion TrackManager
// region VTrack
class VTrack {
  VTrack({this.Name, this.album, this.media, this.genres, this.TrackId}) {
    _setDefaultValues();
  }
  VTrack.withFields(
      this.Name, this.album, this.media, this.genres, this.TrackId) {
    _setDefaultValues();
  }
  VTrack.withId(this.Name, this.album, this.media, this.genres, this.TrackId) {
    _setDefaultValues();
  }
  VTrack.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['Name'] != null) {
      Name = o['Name'] as String;
    }
    if (o['album'] != null) {
      album = o['album'] as String;
    }
    if (o['media'] != null) {
      media = o['media'] as String;
    }
    if (o['genres'] != null) {
      genres = o['genres'] as String;
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (VTrack)
  String Name;
  String album;
  String media;
  String genres;
  int TrackId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (VTrack)

// RELATIONSHIPS (VTrack)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track plTrack;

  /// get Track By TrackId
  Future<Track> getTrack(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (VTrack)

  static const bool _softDeleteActivated = false;
  VTrackManager __mnVTrack;

  VTrackManager get _mnVTrack {
    return __mnVTrack = __mnVTrack ?? VTrackManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (Name != null) {
      map['Name'] = Name;
    }

    if (album != null) {
      map['album'] = album;
    }

    if (media != null) {
      map['media'] = media;
    }

    if (genres != null) {
      map['genres'] = genres;
    }

    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (Name != null) {
      map['Name'] = Name;
    }

    if (album != null) {
      map['album'] = album;
    }

    if (media != null) {
      map['media'] = media;
    }

    if (genres != null) {
      map['genres'] = genres;
    }

    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    return map;
  }

  /// This method returns Json String [VTrack]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VTrack]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [Name, album, media, genres, TrackId];
  }

  List<dynamic> toArgsWithIds() {
    return [Name, album, media, genres, TrackId];
  }

  static Future<List<VTrack>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR VTrack.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<VTrack>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VTrack>[];
    try {
      objList = list
          .map((vtrack) => VTrack.fromMap(vtrack as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR VTrack.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VTrack>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<VTrack> objList = <VTrack>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VTrack.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  VTrackFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return VTrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  VTrackFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return VTrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion vtrack

// region VTrackField
class VTrackField extends SearchCriteria {
  VTrackField(this.vtrackFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  VTrackFilterBuilder vtrackFB;

  VTrackField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  VTrackFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.EQuals,
            vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.NotEQuals,
            vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.EQualsOrNull, vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder isNull() {
    vtrackFB._addedBlocks = setCriteria(
        0,
        vtrackFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      vtrackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          vtrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vtrackFB._addedBlocks);
      _waitingNot = '';
      vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
          vtrackFB._addedBlocks.retVal;
    }
    return vtrackFB;
  }

  VTrackFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      vtrackFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          vtrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vtrackFB._addedBlocks);
      _waitingNot = '';
      vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
          vtrackFB._addedBlocks.retVal;
      vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
          vtrackFB._addedBlocks.retVal;
    }
    return vtrackFB;
  }

  VTrackFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      vtrackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          vtrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vtrackFB._addedBlocks);
      _waitingNot = '';
      vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
          vtrackFB._addedBlocks.retVal;
    }
    return vtrackFB;
  }

  VTrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      vtrackFB._addedBlocks = setCriteria(
          pFirst,
          vtrackFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          vtrackFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        vtrackFB._addedBlocks = setCriteria(pFirst, vtrackFB.parameters, param,
            SqlSyntax.LessThan, vtrackFB._addedBlocks);
      } else {
        vtrackFB._addedBlocks = setCriteria(pFirst, vtrackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vtrackFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        vtrackFB._addedBlocks = setCriteria(pLast, vtrackFB.parameters, param,
            SqlSyntax.GreaterThan, vtrackFB._addedBlocks);
      } else {
        vtrackFB._addedBlocks = setCriteria(pLast, vtrackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vtrackFB._addedBlocks);
      }
    }
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.GreaterThan,
            vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.LessThan,
            vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.LessThan,
            vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    vtrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, vtrackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, vtrackFB._addedBlocks)
        : setCriteria(pValue, vtrackFB.parameters, param, SqlSyntax.GreaterThan,
            vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }

  VTrackFilterBuilder inValues(dynamic pValue) {
    vtrackFB._addedBlocks = setCriteria(
        pValue,
        vtrackFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        vtrackFB._addedBlocks);
    _waitingNot = '';
    vtrackFB._addedBlocks.needEndBlock[vtrackFB._blockIndex] =
        vtrackFB._addedBlocks.retVal;
    return vtrackFB;
  }
}
// endregion VTrackField

// region VTrackFilterBuilder
class VTrackFilterBuilder extends SearchCriteria {
  VTrackFilterBuilder(VTrack obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  VTrack _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  VTrackFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  VTrackFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  VTrackFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  VTrackFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  VTrackFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  VTrackFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  VTrackFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VTrackFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VTrackFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  VTrackFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  VTrackFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  VTrackField setField(VTrackField field, String colName, DbType dbtype) {
    return VTrackField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  VTrackField _Name;
  VTrackField get Name {
    return _Name = setField(_Name, 'Name', DbType.text);
  }

  VTrackField _album;
  VTrackField get album {
    return _album = setField(_album, 'album', DbType.text);
  }

  VTrackField _media;
  VTrackField get media {
    return _media = setField(_media, 'media', DbType.text);
  }

  VTrackField _genres;
  VTrackField get genres {
    return _genres = setField(_genres, 'genres', DbType.text);
  }

  VTrackField _TrackId;
  VTrackField get TrackId {
    return _TrackId = setField(_TrackId, 'TrackId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (VTrack._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// This method always returns VTrack Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VTrack>
  Future<VTrack> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnVTrack.toList(qparams);
    final data = await objFuture;
    VTrack obj;
    if (data.isNotEmpty) {
      obj = VTrack.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [VTrack]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) vtrackCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vtracksFuture = await _obj._mnVTrack.toList(qparams);
    final int count = vtracksFuture[0]['CNT'] as int;
    if (vtrackCount != null) {
      vtrackCount(count);
    }
    return count;
  }

  /// This method returns List<VTrack> [VTrack]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<VTrack>
  Future<List<VTrack>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<VTrack> vtracksData = await VTrack.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vtracksData;
  }

  /// This method returns Json String [VTrack]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VTrack]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VTrack]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnVTrack.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VTrack]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `` FROM VTracks WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VTrack]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnVTrack.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await VTrack.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnVTrack.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VTrackFilterBuilder

// region VTrackFields
class VTrackFields {
  static TableField _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField _fAlbum;
  static TableField get album {
    return _fAlbum =
        _fAlbum ?? SqlSyntax.setField(_fAlbum, 'album', DbType.text);
  }

  static TableField _fMedia;
  static TableField get media {
    return _fMedia =
        _fMedia ?? SqlSyntax.setField(_fMedia, 'media', DbType.text);
  }

  static TableField _fGenres;
  static TableField get genres {
    return _fGenres =
        _fGenres ?? SqlSyntax.setField(_fGenres, 'genres', DbType.text);
  }

  static TableField _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }
}
// endregion VTrackFields

//region VTrackManager
class VTrackManager extends SqfEntityProvider {
  VTrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'VTracks';
  static final List<String> _primaryKeyList = [''];
  static final String _whereStr = '';
}

//endregion VTrackManager
// region PlaylistTrack
class PlaylistTrack {
  PlaylistTrack({this.TrackId, this.PlaylistId}) {
    _setDefaultValues();
  }
  PlaylistTrack.withFields(this.TrackId, this.PlaylistId) {
    _setDefaultValues();
  }
  PlaylistTrack.withId(this.TrackId, this.PlaylistId) {
    _setDefaultValues();
  }
  PlaylistTrack.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TrackId = int.tryParse(o['TrackId'].toString());

    PlaylistId = int.tryParse(o['PlaylistId'].toString());

    // RELATIONSHIPS FromMAP
    plTrack = o['track'] != null
        ? Track.fromMap(o['track'] as Map<String, dynamic>)
        : null;
    plPlaylist = o['playlist'] != null
        ? Playlist.fromMap(o['playlist'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP

    isSaved = true;
  }
  // FIELDS (PlaylistTrack)
  int TrackId;
  int PlaylistId;
  bool isSaved;
  BoolResult saveResult;
  // end FIELDS (PlaylistTrack)

// RELATIONSHIPS (PlaylistTrack)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plTrack', 'plField2'..]) or so on..
  Track plTrack;

  /// get Track By TrackId
  Future<Track> getTrack(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Track()
        .getById(TrackId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plPlaylist', 'plField2'..]) or so on..
  Playlist plPlaylist;

  /// get Playlist By PlaylistId
  Future<Playlist> getPlaylist(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await Playlist().getById(PlaylistId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (PlaylistTrack)

  static const bool _softDeleteActivated = false;
  PlaylistTrackManager __mnPlaylistTrack;

  PlaylistTrackManager get _mnPlaylistTrack {
    return __mnPlaylistTrack = __mnPlaylistTrack ?? PlaylistTrackManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    if (PlaylistId != null) {
      map['PlaylistId'] = forView ? plPlaylist.Name : PlaylistId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (TrackId != null) {
      map['TrackId'] = forView ? plTrack.Name : TrackId;
    }

    if (PlaylistId != null) {
      map['PlaylistId'] = forView ? plPlaylist.Name : PlaylistId;
    }

    return map;
  }

  /// This method returns Json String [PlaylistTrack]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PlaylistTrack]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [TrackId, PlaylistId];
  }

  List<dynamic> toArgsWithIds() {
    return [TrackId, PlaylistId];
  }

  static Future<List<PlaylistTrack>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR PlaylistTrack.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<PlaylistTrack>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PlaylistTrack>[];
    try {
      objList = list
          .map((playlisttrack) =>
              PlaylistTrack.fromMap(playlisttrack as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR PlaylistTrack.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PlaylistTrack>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<PlaylistTrack> objList = <PlaylistTrack>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PlaylistTrack.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Playlist.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedFields.add('Playlist.plPlaylist');*/
          obj.plPlaylist = obj.plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns PlaylistTrack by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int TrackId, int PlaylistId
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns PlaylistTrack if exist, otherwise returns null
  Future<PlaylistTrack> getById(int TrackId, int PlaylistId,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (TrackId == null) {
      return null;
    }
    PlaylistTrack obj;
    final data = await _mnPlaylistTrack.getById([TrackId, PlaylistId]);
    if (data.length != 0) {
      obj = PlaylistTrack.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Playlist.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedFields.add('Playlist.plPlaylist');*/
          obj.plPlaylist = obj.plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PlaylistTrack) object. If the Primary Key (TrackId) field is null, returns Error.
  ///
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  ///
  /// Call the saveAs() method if you do not want to save it when there is another row with the same TrackId

  /// <returns>Returns BoolResult
  Future<BoolResult> save() async {
    final result = BoolResult(success: false);
    try {
      await _mnPlaylistTrack.rawInsert(
          'INSERT ${isSaved ? 'OR REPLACE' : ''} INTO PlaylistTrack (TrackId, PlaylistId)  VALUES (?,?)',
          toArgsWithIds());
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<PlaylistTrack> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PlaylistTrack> playlisttracks) async {
    // final results = _mnPlaylistTrack.saveAll('INSERT OR REPLACE INTO PlaylistTrack (TrackId, PlaylistId)  VALUES (?,?)',playlisttracks);
    // return results; removed in sqfentity_gen 1.3.0+6
    await Chinookdb().batchStart();
    for (final obj in playlisttracks) {
      await obj.save();
    }
    //    return Chinookdb().batchCommit();
    final result = await Chinookdb().batchCommit();

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns 1
  Future<int> upsert() async {
    try {
      if (await _mnPlaylistTrack.rawInsert(
              'INSERT OR REPLACE INTO PlaylistTrack (TrackId, PlaylistId)  VALUES (?,?)',
              [TrackId, PlaylistId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PlaylistTrack TrackId=$TrackId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PlaylistTrack TrackId=$TrackId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PlaylistTrack Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<PlaylistTrack>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<PlaylistTrack> playlisttracks) async {
    final results = await _mnPlaylistTrack.rawInsertAll(
        'INSERT OR REPLACE INTO PlaylistTrack (TrackId, PlaylistId)  VALUES (?,?)',
        playlisttracks);
    return results;
  }

  /// Deletes PlaylistTrack

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete PlaylistTrack invoked (TrackId=$TrackId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPlaylistTrack.delete(QueryParams(
          whereString: 'TrackId=? AND PlaylistId=?',
          whereArguments: [TrackId, PlaylistId]));
    } else {
      return _mnPlaylistTrack.updateBatch(
          QueryParams(
              whereString: 'TrackId=? AND PlaylistId=?',
              whereArguments: [TrackId, PlaylistId]),
          {'isDeleted': 1});
    }
  }

  PlaylistTrackFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistTrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  PlaylistTrackFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return PlaylistTrackFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion playlisttrack

// region PlaylistTrackField
class PlaylistTrackField extends SearchCriteria {
  PlaylistTrackField(this.playlisttrackFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  PlaylistTrackFilterBuilder playlisttrackFB;

  PlaylistTrackField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  PlaylistTrackFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.EQuals, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.NotEQuals, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.EQualsOrNull, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder isNull() {
    playlisttrackFB._addedBlocks = setCriteria(
        0,
        playlisttrackFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      playlisttrackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          playlisttrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlisttrackFB._addedBlocks);
      _waitingNot = '';
      playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
          playlisttrackFB._addedBlocks.retVal;
    }
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      playlisttrackFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          playlisttrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlisttrackFB._addedBlocks);
      _waitingNot = '';
      playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
          playlisttrackFB._addedBlocks.retVal;
      playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
          playlisttrackFB._addedBlocks.retVal;
    }
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      playlisttrackFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          playlisttrackFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlisttrackFB._addedBlocks);
      _waitingNot = '';
      playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
          playlisttrackFB._addedBlocks.retVal;
    }
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      playlisttrackFB._addedBlocks = setCriteria(
          pFirst,
          playlisttrackFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          playlisttrackFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        playlisttrackFB._addedBlocks = setCriteria(
            pFirst,
            playlisttrackFB.parameters,
            param,
            SqlSyntax.LessThan,
            playlisttrackFB._addedBlocks);
      } else {
        playlisttrackFB._addedBlocks = setCriteria(
            pFirst,
            playlisttrackFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            playlisttrackFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        playlisttrackFB._addedBlocks = setCriteria(
            pLast,
            playlisttrackFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            playlisttrackFB._addedBlocks);
      } else {
        playlisttrackFB._addedBlocks = setCriteria(
            pLast,
            playlisttrackFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            playlisttrackFB._addedBlocks);
      }
    }
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.GreaterThan, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.LessThan, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.LessThan, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    playlisttrackFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.LessThanOrEquals, playlisttrackFB._addedBlocks)
        : setCriteria(pValue, playlisttrackFB.parameters, param,
            SqlSyntax.GreaterThan, playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }

  PlaylistTrackFilterBuilder inValues(dynamic pValue) {
    playlisttrackFB._addedBlocks = setCriteria(
        pValue,
        playlisttrackFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        playlisttrackFB._addedBlocks);
    _waitingNot = '';
    playlisttrackFB._addedBlocks.needEndBlock[playlisttrackFB._blockIndex] =
        playlisttrackFB._addedBlocks.retVal;
    return playlisttrackFB;
  }
}
// endregion PlaylistTrackField

// region PlaylistTrackFilterBuilder
class PlaylistTrackFilterBuilder extends SearchCriteria {
  PlaylistTrackFilterBuilder(PlaylistTrack obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  PlaylistTrack _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  PlaylistTrackFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  PlaylistTrackFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  PlaylistTrackFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  PlaylistTrackFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  PlaylistTrackFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  PlaylistTrackFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  PlaylistTrackFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistTrackFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistTrackFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  PlaylistTrackFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  PlaylistTrackFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  PlaylistTrackField setField(
      PlaylistTrackField field, String colName, DbType dbtype) {
    return PlaylistTrackField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  PlaylistTrackField _TrackId;
  PlaylistTrackField get TrackId {
    return _TrackId = setField(_TrackId, 'TrackId', DbType.integer);
  }

  PlaylistTrackField _PlaylistId;
  PlaylistTrackField get PlaylistId {
    return _PlaylistId = setField(_PlaylistId, 'PlaylistId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (PlaylistTrack._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<PlaylistTrack> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (PlaylistTrack._softDeleteActivated && !hardDelete) {
      r = await _obj._mnPlaylistTrack.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnPlaylistTrack.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'TrackId IN (SELECT TrackId from PlaylistTrack ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnPlaylistTrack.updateBatch(qparams, values);
  }

  /// This method always returns PlaylistTrack Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistTrack>
  Future<PlaylistTrack> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnPlaylistTrack.toList(qparams);
    final data = await objFuture;
    PlaylistTrack obj;
    if (data.isNotEmpty) {
      obj = PlaylistTrack.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('Track.plTrack') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plTrack'))) {
          /*_loadedFields.add('Track.plTrack');*/
          obj.plTrack = obj.plTrack ??
              await obj.getTrack(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('Playlist.plPlaylist') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plPlaylist'))) {
          /*_loadedFields.add('Playlist.plPlaylist');*/
          obj.plPlaylist = obj.plPlaylist ??
              await obj.getPlaylist(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [PlaylistTrack]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) playlisttrackCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final playlisttracksFuture = await _obj._mnPlaylistTrack.toList(qparams);
    final int count = playlisttracksFuture[0]['CNT'] as int;
    if (playlisttrackCount != null) {
      playlisttrackCount(count);
    }
    return count;
  }

  /// This method returns List<PlaylistTrack> [PlaylistTrack]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<PlaylistTrack>
  Future<List<PlaylistTrack>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<PlaylistTrack> playlisttracksData =
        await PlaylistTrack.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return playlisttracksData;
  }

  /// This method returns Json String [PlaylistTrack]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PlaylistTrack]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PlaylistTrack]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnPlaylistTrack.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PlaylistTrack]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `TrackId`PlaylistId` FROM PlaylistTrack WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<TrackId,PlaylistId> [PlaylistTrack]
  /// <returns>List<TrackId,PlaylistId>
  Future<List<PlaylistTrack>> toListPrimaryKey(
      [bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    qparams.selectColumns = ['TrackId', 'PlaylistId'];
    final playlisttrackFuture = await _obj._mnPlaylistTrack.toList(qparams);
    return await PlaylistTrack.fromMapList(playlisttrackFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PlaylistTrack]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylistTrack.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await PlaylistTrack.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnPlaylistTrack.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PlaylistTrackFilterBuilder

// region PlaylistTrackFields
class PlaylistTrackFields {
  static TableField _fTrackId;
  static TableField get TrackId {
    return _fTrackId =
        _fTrackId ?? SqlSyntax.setField(_fTrackId, 'TrackId', DbType.integer);
  }

  static TableField _fPlaylistId;
  static TableField get PlaylistId {
    return _fPlaylistId = _fPlaylistId ??
        SqlSyntax.setField(_fPlaylistId, 'PlaylistId', DbType.integer);
  }
}
// endregion PlaylistTrackFields

//region PlaylistTrackManager
class PlaylistTrackManager extends SqfEntityProvider {
  PlaylistTrackManager()
      : super(Chinookdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'PlaylistTrack';
  static final List<String> _primaryKeyList = ['TrackId', 'PlaylistId'];
  static final String _whereStr = 'TrackId=? AND PlaylistId=?';
}

//endregion PlaylistTrackManager
class ChinookdbSequenceManager extends SqfEntityProvider {
  ChinookdbSequenceManager() : super(Chinookdb());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (Album)
class AlbumToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'AlbumId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Title';
  //static String formListSubTitleField = 'ArtistId';
}

class AlbumController extends Album {
  String formListTitleField = 'Title';
  String formListSubTitleField = 'ArtistId';
  static SQFViewList getController = SQFViewList(
    AlbumController(),
    primaryKeyName: 'AlbumId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['AlbumToTrack'] = 'Album To Track(AlbumId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'AlbumToTrack':
        return SQFViewList(
          AlbumToTrackControllerSub(),
          primaryKeyName: AlbumToTrackControllerSub.primaryKeyName,
          useSoftDeleting: AlbumToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Title',
          //formListSubTitleField: 'ArtistId',
          filterExpression:
              '${AlbumToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return AlbumAdd(obj == null
        ? Album()
        : await Album().getById(obj['AlbumId'] as int) ?? Album());
  }
}
// END CONTROLLER (Album)

// BEGIN CONTROLLER (Artist)
class ArtistToAlbumControllerSub extends AlbumController {
  static String relationshipFieldName = 'ArtistId';
  static String primaryKeyName = 'AlbumId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class ArtistController extends Artist {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    ArtistController(),
    primaryKeyName: 'ArtistId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['ArtistToAlbum'] = 'Artist To Album(ArtistId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'ArtistToAlbum':
        return SQFViewList(
          ArtistToAlbumControllerSub(),
          primaryKeyName: ArtistToAlbumControllerSub.primaryKeyName,
          useSoftDeleting: ArtistToAlbumControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${ArtistToAlbumControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return ArtistAdd(obj == null
        ? Artist()
        : await Artist().getById(obj['ArtistId'] as int) ?? Artist());
  }
}
// END CONTROLLER (Artist)

// BEGIN CONTROLLER (Customer)
class CustomerToInvoiceControllerSub extends InvoiceController {
  static String relationshipFieldName = 'CustomerId';
  static String primaryKeyName = 'InvoiceId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'FirstName';
  //static String formListSubTitleField = 'LastName';
}

class CustomerController extends Customer {
  String formListTitleField = 'FirstName';
  String formListSubTitleField = 'LastName';
  static SQFViewList getController = SQFViewList(
    CustomerController(),
    primaryKeyName: 'CustomerId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['CustomerToInvoice'] = 'Customer To Invoice(CustomerId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'CustomerToInvoice':
        return SQFViewList(
          CustomerToInvoiceControllerSub(),
          primaryKeyName: CustomerToInvoiceControllerSub.primaryKeyName,
          useSoftDeleting: CustomerToInvoiceControllerSub.useSoftDeleting,
          //formListTitleField: 'FirstName',
          //formListSubTitleField: 'LastName',
          filterExpression:
              '${CustomerToInvoiceControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return CustomerAdd(obj == null
        ? Customer()
        : await Customer().getById(obj['CustomerId'] as int) ?? Customer());
  }
}
// END CONTROLLER (Customer)

// BEGIN CONTROLLER (Employee)
class EmployeeToCustomerControllerSub extends CustomerController {
  static String relationshipFieldName = 'SupportRepId';
  static String primaryKeyName = 'CustomerId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'LastName';
  //static String formListSubTitleField = 'FirstName';
}

class EmployeeToEmployeeControllerSub extends EmployeeController {
  static String relationshipFieldName = 'ReportsTo';
  static String primaryKeyName = 'EmployeeId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'LastName';
  //static String formListSubTitleField = 'FirstName';
}

class EmployeeController extends Employee {
  String formListTitleField = 'LastName';
  String formListSubTitleField = 'FirstName';
  static SQFViewList getController = SQFViewList(
    EmployeeController(),
    primaryKeyName: 'EmployeeId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['EmployeeToCustomer'] = 'Employee To Customer(SupportRepId)';
    menu['EmployeeToEmployee'] = 'Employee To Employee(ReportsTo)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'EmployeeToCustomer':
        return SQFViewList(
          EmployeeToCustomerControllerSub(),
          primaryKeyName: EmployeeToCustomerControllerSub.primaryKeyName,
          useSoftDeleting: EmployeeToCustomerControllerSub.useSoftDeleting,
          //formListTitleField: 'LastName',
          //formListSubTitleField: 'FirstName',
          filterExpression:
              '${EmployeeToCustomerControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'EmployeeToEmployee':
        return SQFViewList(
          EmployeeToEmployeeControllerSub(),
          primaryKeyName: EmployeeToEmployeeControllerSub.primaryKeyName,
          useSoftDeleting: EmployeeToEmployeeControllerSub.useSoftDeleting,
          //formListTitleField: 'LastName',
          //formListSubTitleField: 'FirstName',
          filterExpression:
              '${EmployeeToEmployeeControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return EmployeeAdd(obj == null
        ? Employee()
        : await Employee().getById(obj['EmployeeId'] as int) ?? Employee());
  }
}
// END CONTROLLER (Employee)

// BEGIN CONTROLLER (Genre)
class GenreToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'GenreId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class GenreController extends Genre {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    GenreController(),
    primaryKeyName: 'GenreId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['GenreToTrack'] = 'Genre To Track(GenreId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'GenreToTrack':
        return SQFViewList(
          GenreToTrackControllerSub(),
          primaryKeyName: GenreToTrackControllerSub.primaryKeyName,
          useSoftDeleting: GenreToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${GenreToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return GenreAdd(obj == null
        ? Genre()
        : await Genre().getById(obj['GenreId'] as int) ?? Genre());
  }
}
// END CONTROLLER (Genre)

// BEGIN CONTROLLER (Invoice)
class InvoiceToInvoiceLineControllerSub extends InvoiceLineController {
  static String relationshipFieldName = 'InvoiceId';
  static String primaryKeyName = 'InvoiceLineId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'BillingAddress';
  //static String formListSubTitleField = 'BillingCity';
}

class InvoiceController extends Invoice {
  String formListTitleField = 'BillingAddress';
  String formListSubTitleField = 'BillingCity';
  static SQFViewList getController = SQFViewList(
    InvoiceController(),
    primaryKeyName: 'InvoiceId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['InvoiceToInvoiceLine'] = 'Invoice To InvoiceLine(InvoiceId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'InvoiceToInvoiceLine':
        return SQFViewList(
          InvoiceToInvoiceLineControllerSub(),
          primaryKeyName: InvoiceToInvoiceLineControllerSub.primaryKeyName,
          useSoftDeleting: InvoiceToInvoiceLineControllerSub.useSoftDeleting,
          //formListTitleField: 'BillingAddress',
          //formListSubTitleField: 'BillingCity',
          filterExpression:
              '${InvoiceToInvoiceLineControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return InvoiceAdd(obj == null
        ? Invoice()
        : await Invoice().getById(obj['InvoiceId'] as int) ?? Invoice());
  }
}
// END CONTROLLER (Invoice)

// BEGIN CONTROLLER (InvoiceLine)

class InvoiceLineController extends InvoiceLine {
  String formListTitleField = 'InvoiceLineId';
  String formListSubTitleField = 'UnitPrice';
  static SQFViewList getController = SQFViewList(
    InvoiceLineController(),
    primaryKeyName: 'InvoiceLineId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return InvoiceLineAdd(obj == null
        ? InvoiceLine()
        : await InvoiceLine().getById(obj['InvoiceLineId'] as int) ??
            InvoiceLine());
  }
}
// END CONTROLLER (InvoiceLine)

// BEGIN CONTROLLER (MediaType)
class MediaTypeToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'MediaTypeId';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class MediaTypeController extends MediaType {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    MediaTypeController(),
    primaryKeyName: 'MediaTypeId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['MediaTypeToTrack'] = 'MediaType To Track(MediaTypeId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'MediaTypeToTrack':
        return SQFViewList(
          MediaTypeToTrackControllerSub(),
          primaryKeyName: MediaTypeToTrackControllerSub.primaryKeyName,
          useSoftDeleting: MediaTypeToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              '${MediaTypeToTrackControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return MediaTypeAdd(obj == null
        ? MediaType()
        : await MediaType().getById(obj['MediaTypeId'] as int) ?? MediaType());
  }
}
// END CONTROLLER (MediaType)

// BEGIN CONTROLLER (Playlist)
class PlaylistToTrackControllerSub extends TrackController {
  static String relationshipFieldName = 'mPlaylistTrack';
  static String primaryKeyName = 'TrackId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = '';
}

class PlaylistController extends Playlist {
  String formListTitleField = 'Name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    PlaylistController(),
    primaryKeyName: 'PlaylistId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['PlaylistToTrack'] = 'Playlist To Track(mPlaylistTrack)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'PlaylistToTrack':
        return SQFViewList(
          PlaylistToTrackControllerSub(),
          primaryKeyName: PlaylistToTrackControllerSub.primaryKeyName,
          useSoftDeleting: PlaylistToTrackControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: '',
          filterExpression:
              'TrackId IN (SELECT TrackId FROM PlaylistTrack WHERE PlaylistId=?)',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return PlaylistAdd(obj == null
        ? Playlist()
        : await Playlist().getById(obj['PlaylistId'] as int) ?? Playlist());
  }
}
// END CONTROLLER (Playlist)

// BEGIN CONTROLLER (Track)
class TrackToInvoiceLineControllerSub extends InvoiceLineController {
  static String relationshipFieldName = 'TrackId';
  static String primaryKeyName = 'InvoiceLineId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = 'Composer';
}

class TrackToPlaylistControllerSub extends PlaylistController {
  static String relationshipFieldName = 'TrackTrackId';
  static String primaryKeyName = 'PlaylistId';
  static bool useSoftDeleting = false;
  //static String formListTitleField = 'Name';
  //static String formListSubTitleField = 'Composer';
}

class TrackController extends Track {
  String formListTitleField = 'Name';
  String formListSubTitleField = 'Composer';
  static SQFViewList getController = SQFViewList(
    TrackController(),
    primaryKeyName: 'TrackId',
    useSoftDeleting: false,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};
    menu['TrackToInvoiceLine'] = 'Track To InvoiceLine(TrackId)';
    menu['TrackToPlaylist'] = 'Track To Playlist(TrackTrackId)';

    return menu;
  }

  SQFViewList subList(int id, String controllerName) {
    switch (controllerName) {
      case 'TrackToInvoiceLine':
        return SQFViewList(
          TrackToInvoiceLineControllerSub(),
          primaryKeyName: TrackToInvoiceLineControllerSub.primaryKeyName,
          useSoftDeleting: TrackToInvoiceLineControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: 'Composer',
          filterExpression:
              '${TrackToInvoiceLineControllerSub.relationshipFieldName}=?',
          filterParameter: id,
        );
      case 'TrackToPlaylist':
        return SQFViewList(
          TrackToPlaylistControllerSub(),
          primaryKeyName: TrackToPlaylistControllerSub.primaryKeyName,
          useSoftDeleting: TrackToPlaylistControllerSub.useSoftDeleting,
          //formListTitleField: 'Name',
          //formListSubTitleField: 'Composer',
          filterExpression:
              'PlaylistId IN (SELECT PlaylistId FROM PlaylistTrack WHERE TrackId=?)',
          filterParameter: id,
        );

      default:
        return null;
    }
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return TrackAdd(obj == null
        ? Track()
        : await Track().getById(obj['TrackId'] as int) ?? Track());
  }
}
// END CONTROLLER (Track)

// END OF CONTROLLERS
